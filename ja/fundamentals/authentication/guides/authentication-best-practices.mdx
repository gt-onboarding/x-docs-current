---
title: ベストプラクティス
keywords: ["認証のベストプラクティス", "OAuth のベストプラクティス", "セキュリティのベストプラクティス", "API キーのセキュリティ", "トークンのセキュリティ", "認証／認可のセキュリティ"]
---

import { Button } from "/snippets/ja/button.mdx";

API のキーとトークンは、細心の注意を払って保護する必要があります。 

これらの認証情報は、あなたの [developer App](/ja/resources/fundamentals/developer-apps) と、あなたがその代わりにリクエストを送信することを許可した X アカウントに直接ひも付いています。キーが漏えいした場合、悪意のある第三者がそれらを使って、あなたの developer App やその認可ユーザーの代わりに X API のエンドポイントへリクエストを送信する可能性があります。その結果として、想定外のレート制限に達してしまったり、有料アクセスの割り当てを使い切ってしまったり、最悪の場合は developer App が停止されてしまうことさえあります。

以下のセクションでは、API のキーとトークンを管理する際に考慮すべきベストプラクティスについて説明します。

<div id="regenerate-api-keys-and-tokens">
  ## API キーとトークンを再生成する
</div>

API キーが漏えいした可能性がある場合は、次の手順に従って API キーを再生成してください。

1. [developer portal の「Projects and Apps」ページ](https://developer.x.com/en/portal/projects-and-apps.html)に移動します。
2. 該当する App の横にある「Keys and tokens」アイコン (🗝) をクリックします。
3. 再生成したいキーとトークンのセットの横にある「Regenerate」ボタンをクリックします。 

アクセストークンまたは Bearer Token をプログラムから再生成したい場合は、認証エンドポイントを使用して実行できます。

* アクセストークンを再生成したい場合は、まず [POST oauth/invalidate&#95;token](/ja/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) エンドポイントを使用してトークンを無効化し、その後 [3-legged OAuth フロー](/ja/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens) を使用してトークンを再生成する必要があります。
* Bearer Token を再生成したい場合は、まず [POST oauth2/invalidate&#95;token](/ja/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) エンドポイントを使用してトークンを無効化し、その後 [POST oauth2/token](/ja/resources/fundamentals/authentication/api-reference#post-oauth2-token) エンドポイントを使用してトークンを再生成する必要があります。

<div id="having-a-central-file-for-your-secrets">
  ## シークレットを一元管理するファイルを用意する
</div>

`.env` ファイルや、その他の `.yaml` ファイルなどにシークレットをまとめて格納する方法は有用な場合がありますが、それらを誤って git リポジトリにコミットしてしまわないよう、必ずそれらを除外できる適切な `.gitignore` ファイル（設定）を用意してください。 

<div id="environment-variables">
  ## 環境変数
</div>

環境変数を利用するコードを書くと役立つ場合があります。 

これを Python で書くと次のようになります。

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

ターミナルで次のように入力します：

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## ソースコードとバージョン管理
</div>

開発者が犯しがちなセキュリティ上のミスとして最も一般的なのは、GitHub や BitBucket などのバージョン管理システム上のソースコードに API のキーとトークンをコミットしてしまうことです。これらのコードリポジトリの多くは誰でも閲覧可能な状態になっています。公開リポジトリでこのミスがあまりにも頻繁に起きるため、API キーを探し回って収集することで利益を上げているボットさえ存在します。

* サーバーの環境変数を使用してください。API キーを環境変数に保存すれば、コードやバージョン管理システムに含めずに済みます。これにより、環境ごとに異なるキーも簡単に使い分けられます。
* ソース管理から除外した設定ファイルを使用してください。ファイルをバージョン管理の追跡対象から除外するには、そのファイル名を [.gitignore](https://git-scm.com/docs/gitignore) ファイルに追加します。
* 一度バージョン管理下に置いたコードから API キーを削除しても、コードベースの以前のバージョンにアクセスすれば API キーが依然として取得できてしまう可能性があります。次のセクションの説明に従って API キーを再生成してください。

<div id="databases">
  ## データベース
</div>

アクセストークンをデータベースに保存する必要がある場合は、次の点に注意してください。

* アクセストークンが、そのトークンの所有者のみ読み取り可能になるように、データベースへのアクセスを制限してください。
* アクセストークン用のデータベーステーブルへの編集／書き込み権限を制限してください。これはキー管理システムで自動化されている必要があります。
* いかなるデータストアに保存する場合でも、保存前にアクセストークンを暗号化してください。

<div id="password-management-tools">
  ## パスワード管理ツール
</div>

1Password や LastPass などのパスワード管理ツールは、キーとトークンを安全な場所に保管するのに役立ちます。こうした情報を、チームで共有しているパスワード管理ツール内で共有することは避けたほうがよい場合があります。

<div id="web-storage-cookies">
  ## Web storage &amp; cookies
</div>

Web storage には、LocalStorage と SessionStorage の 2 種類があります。これらは Cookie の改良版として作られたもので、Web Storage の方が Cookie よりもはるかに大きな容量を扱えます。ただし、それぞれのストレージ方式には異なる長所と短所があります。
 

**Web Storage: LocalStorage**

ローカルの Web Storage に保存されたものは永続的です。つまり、そのデータが明示的に削除されるまで保持され続けます。プロジェクトの要件によっては、これはメリットといえるでしょう。一方で、LocalStorage を使用する際には注意が必要です。データへの変更や追加は、該当のウェブページへの今後のすべての訪問で利用可能になるためです。通常、LocalStorage の使用はあまり推奨しませんが、いくつか例外があるかもしれません。LocalStorage を使うことにした場合、LocalStorage は same-origin policy をサポートしているため、ここに保存されるデータは同一オリジンからのみ利用できる、という点を知っておくとよいでしょう。LocalStorage を使用することで得られる追加のパフォーマンス上の利点として、クライアントとサーバー間のトラフィックが減少することが挙げられます。これは、すべての HTTP リクエストごとにデータをサーバーへ送り返す必要がないためです。
 

**Web Storage: SessionStorage**

SessionStorage は LocalStorage と似ていますが、決定的な違いは SessionStorage は永続的ではないという点です。SessionStorage に書き込みを行ったウィンドウ（あるいは使用しているブラウザによってはタブ）が閉じられると、データは失われます。これは、ユーザーセッション内でトークンの読み取りアクセスを制限するのに役立ちます。セキュリティの観点では、通常は LocalStorage よりも SessionStorage を使用する方が望ましいといえます。LocalStorage と同様に、same-origin policy のサポートやクライアントとサーバー間のトラフィック削減といった利点は SessionStorage にも当てはまります。
 

**Cookies**

Cookies はセッションデータを保存する、従来から使われている方法です。各 Cookie に有効期限を設定できるため、取り消しやアクセス制限を容易に行うことができます。ただし、データがすべての HTTP リクエストごとにサーバーへ送り返されるため、Cookies を使用するとクライアントとサーバー間のトラフィックは確実に増加します。Cookies を使用する場合は、セッションハイジャックに対する防御が必要です。デフォルトでは Cookies は HTTP 上で平文送信されるため、その内容はパケットスニッフィングや、攻撃者がトラフィックを改ざんしうる man-in-the-middle 攻撃に対して脆弱です。データの転送中の保護のため、常に HTTPS を強制するべきです。これにより、機密性、完全性（データの整合性）、および認証が提供されます。ただし、ウェブアプリケーションやサイトが HTTP と HTTPS の両方で利用可能な場合は、Cookie に &#39;Secure&#39; フラグを付与することも必要になります。これにより、攻撃者がユーザーに対してサイトの HTTP 版へのリンクを送信し、その結果生成される HTTP リクエストを盗聴することを防止できます。

Cookies を使用する際のセッションハイジャックに対する追加の防御策としては、重大な処理を行う前にユーザーの身元を再度検証することが挙げられます。Cookies のセキュリティを向上させるために検討すべき別のフラグとして &#39;HttpOnly&#39; フラグがあります。このフラグは、問題の Cookie をブラウザのクライアントサイドスクリプトからは参照できないよう指示するものです。クライアントサイドスクリプトからのアクセス試行はこのフラグによって禁止されるため、ほとんどのクロスサイトスクリプティング（XSS）攻撃に対する保護に役立ちます。