---
title: ベストプラクティス
keywords: ["認証のベストプラクティス", "OAuth のベストプラクティス", "セキュリティのベストプラクティス", "API キーのセキュリティ", "トークンのセキュリティ", "認証のセキュリティ"]
---

import { Button } from "/snippets/ja/button.mdx";

APIのキーとトークンは、細心の注意を払って保護する必要があります。 

これらの認証情報は、あなたの[developer App](/ja/resources/fundamentals/developer-apps)および、あなたが自分に代わってリクエストを送信することを許可したXアカウントに直接紐づいています。キーが漏えいした場合、悪意のある第三者がそれらを使って、あなたのdeveloper Appまたはその承認ユーザーに代わってXのエンドポイントにリクエストを送信する可能性があります。その結果、想定外のレート制限に達したり、有料アクセスの割り当てを使い切ってしまったり、さらにはdeveloper Appが停止されてしまうことさえ考えられます。

以下のセクションでは、APIキーとトークンを管理する際に考慮すべきベストプラクティスを紹介します。

<div id="regenerate-api-keys-and-tokens">
  ## API キーとトークンを再生成する
</div>

API キーが漏えいした可能性がある場合は、次の手順に従って API キーを再生成してください。

1. [developer portal の「Projects and Apps」ページ](https://developer.x.com/en/portal/projects-and-apps.html)を開きます。
2. 対象の App の横にある「Keys and tokens」アイコン (🗝 ) をクリックします。
3. 再生成したいキーとトークンのセットの横にある「Regenerate」ボタンをクリックします。 

アクセストークンや Bearer Token をプログラムから再生成したい場合は、認証エンドポイントを使用できます。

* アクセストークンを再生成する場合は、まず [POST oauth/invalidate&#95;token](/ja/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) エンドポイントを使用してトークンを失効させ、その後 [3-legged OAuth フロー](/ja/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)を使用してトークンを再生成する必要があります。
* Bearer Token を再生成する場合は、まず [POST oauth2/invalidate&#95;token](/ja/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) エンドポイントを使用してトークンを失効させ、その後 [POST oauth2/token](/ja/resources/fundamentals/authentication/api-reference#post-oauth2-token) エンドポイントを使用してトークンを再生成する必要があります。

<div id="having-a-central-file-for-your-secrets">
  ## シークレットを一元管理するファイルを用意する
</div>

`.env` ファイルや、その他の種類の `.yaml` ファイルなどにシークレットを格納する方法は有用な選択肢になり得ます。ただし、それらを誤って Git リポジトリにコミットしてしまわないよう、必ず適切に設定された `.gitignore` ファイルを用意してください。 

<div id="environment-variables">
  ## 環境変数
</div>

環境変数を利用するコードを書いておくと役立つ場合があります。 

例えば、Python では次のように記述できます。

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

ターミナルでは、次のように入力します。

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## ソースコードとバージョン管理
</div>

開発者が犯しがちな最も一般的なセキュリティ上のミスは、GitHub や Bitbucket のような、誰でもアクセス可能なバージョン管理システム上のソースコードに API キーとトークンをコミットしてしまうことです。これらのコードリポジトリの多くは公開されています。公開リポジトリでこのミスは非常に頻繁に発生するため、API キーをスクレイピングして収益を上げているボットも存在します。

* サーバーの環境変数を使用してください。API キーを環境変数に保存することで、コードやバージョン管理の対象から外すことができます。これにより、環境ごとに異なるキーを簡単に使い分けることも可能になります。
* バージョン管理から除外された設定ファイルを使用してください。バージョン管理で追跡されないように、そのファイル名を [.gitignore](https://git-scm.com/docs/gitignore) ファイルに追加します。
* 一度バージョン管理に追加した後にコードから API キーを削除しても、コードベースの過去バージョンにアクセスすれば API キーが依然として取得できる可能性があります。次のセクションで説明するように、API キーを再生成してください。

<div id="databases">
  ## データベース
</div>

アクセストークンをデータベースに保存する必要がある場合は、次の点に注意してください。

* アクセストークンがその所有者だけに読み取れるよう、データベースへのアクセスを制限します。
* アクセストークン用のデータベーステーブルへの編集／書き込み権限を制限します。これはキー管理システムで自動化してください。
* いかなるデータストアに保存する場合も、事前にアクセストークンを暗号化します。

<div id="password-management-tools">
  ## パスワード管理ツール
</div>

1Password や LastPass のようなパスワード管理ツールは、キーとトークンを安全な場所に保管するのに役立ちます。共有チーム用のパスワード管理ツール内で、これらを共有することは避けたほうがよいでしょう。

<div id="web-storage-cookies">
  ## Web storage &amp; cookies
</div>

Web Storage には LocalStorage と SessionStorage の 2 種類があります。これらは Cookie の改善版として作られたもので、Web Storage のほうが Cookie よりも格納できる容量が大きくなっています。ただし、それぞれのストレージ方式には異なる長所と短所があります。
 

**Web Storage: LocalStorage**

ローカルの Web Storage に保存されたものは永続的です。つまり、そのデータが明示的に削除されるまで保持され続けます。プロジェクトの要件によっては、これはメリットと捉えられるかもしれません。しかし、LocalStorage を使用する際は注意が必要です。というのも、データへの変更や追加が、今後その Web ページを訪れるたびに反映されることになるためです。一般的には LocalStorage の使用は推奨しませんが、いくつか例外がある場合もあります。LocalStorage を使用する場合、同一オリジンポリシーをサポートしていることを把握しておくとよいでしょう。ここに保存されたすべてのデータは、同一オリジンからのみ利用可能です。LocalStorage を使用することによる追加のパフォーマンス上の利点としては、すべての HTTP リクエストでデータをサーバーに送り返す必要がないため、クライアントとサーバー間のトラフィックが減少することが挙げられます。
 

**Web Storage: SessionStorage**

SessionStorage は LocalStorage と似ていますが、最も大きな違いは SessionStorage は永続的ではないという点です。SessionStorage に書き込みを行ったウィンドウ（またはブラウザによってはタブ）が閉じられると、データは失われます。これは、ユーザーセッション内でトークンへの読み取りアクセスを制限するうえで有用です。セキュリティの観点からは、通常 LocalStorage よりも SessionStorage を使用するほうが望ましいと考えられます。LocalStorage と同様に、SessionStorage にも同一オリジンポリシーのサポートやクライアント・サーバー間トラフィックの削減といった利点があります。
 

**Cookies**

Cookies は、セッションデータを保存する、より従来から使われている方法です。各 Cookie に有効期限を設定できるため、取り消しを容易にし、アクセスを制限しやすくなります。ただし、Cookie を使用すると、すべての HTTP リクエストでデータがサーバーに送り返されるため、クライアント・サーバー間のトラフィックは確実に増加します。Cookie を使用する場合は、セッションハイジャックへの対策が必要です。デフォルトでは、Cookie は HTTP 上で平文のまま送信されるため、内容がパケットスニッフィングや、攻撃者がトラフィックを改ざんする中間者攻撃（man-in-the-middle）に対して脆弱になります。通信中のデータを保護するため、常に HTTPS を強制すべきです。これにより、機密性、完全性（データの）、および認証が提供されます。ただし、ウェブアプリケーションやサイトが HTTP と HTTPS の両方で利用可能な場合は、Cookie に &#39;Secure&#39; フラグを付与する必要もあります。これにより、攻撃者がサイトの HTTP 版へのリンクをユーザーに送り、その結果生成される HTTP リクエストを盗聴することを防げます。

Cookie 使用時におけるセッションハイジャックへの二次的な防御策として、影響の大きい処理を実行する前に、再度ユーザーの本人確認を行うことが挙げられます。Cookie のセキュリティを高めるために検討すべきもう 1 つのフラグは &#39;HttpOnly&#39; フラグです。このフラグは、対象の Cookie をクライアント側スクリプトからはアクセスできないようブラウザに指示します。クライアント側スクリプトからのアクセス試行はこのフラグによって禁止されるため、ほとんどのクロスサイトスクリプティング（XSS）攻撃から保護することに役立ちます。