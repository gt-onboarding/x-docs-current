---
title: クエリを構築する
sidebarTitle: クエリを構築する
keywords: ["クエリを構築", "検索クエリ", "クエリビルダー", "検索演算子", "クエリ構文", "検索クエリを構築", "クエリガイド"]
---

<div id="building-queries-for-search-posts">
  ## ポスト検索用クエリの構築
</div>

Search エンドポイントは、GET リクエストで 1 つのクエリを受け取り、そのクエリに一致する過去のポストの集合を返します。クエリは、さまざまなポスト属性に対して一致させるために使用されるオペレーターで構成されます。 

<div id="table-of-contents">
  ### 目次
</div>

* [クエリの構築](#build)
* [クエリの制限](#limits)
* [演算子の利用可否](#availability)
* [演算子の種類: 単独利用と論理結合必須](#types)
* [ブール演算子とグルーピング](#boolean)
* [演算の優先順位](#order-of-operations)
* [句読点、ダイアクリティカルマーク、大文字小文字の区別](#punctuation)
* [具体性と効率性](#specificity)
* [引用ポストのマッチング動作](#quote-tweets)
* [クエリを段階的に構築する](#iterative)
* [リクエストへのクエリの追加](#adding-a-query)
* [クエリ例](#examples)
* [演算子一覧](#list)

<div id="building-a-query">
  ### クエリの構築
</div>

<div id="query-limitations">
  #### クエリの制限事項
</div>

利用している [アクセスレベル](/ja/x-api/getting-started/about-x-api) によって、クエリの制限は異なります。 

Basic または Pro アクセスの場合、recent search エンドポイントで使用できるクエリは最大 512 文字です。 

Pro アクセスの場合、full archive search エンドポイントで使用できるクエリは最大 1,024 文字です。 

<div id="operator-availability">
  #### オペレーターの利用可否
</div>

ほとんどのオペレーターはすべての開発者が利用できますが、一部のオペレーターは特定のアクセスレベル専用となっています。各オペレーターがどのアクセスレベルで利用可能かは、次のラベルを用いて [オペレーターの一覧](/ja/x-api/posts/search/integrate/operators) の表に記載しています。

* **Core operators:** 任意の [プロジェクト](/ja/resources/fundamentals/projects) を使用している場合に利用可能。
* **Advanced operators:** 特定のアクセスレベルを持つプロジェクトを使用している場合に利用可能。

<div id="operator-types-standalone-and-conjunction-required">
  #### 演算子の種類: 単独利用可能と連結必須
</div>

**単独利用可能な演算子** は、それ単体でも、また（連結が必要なものを含む）他の任意の演算子と組み合わせても使用できます。

たとえば、次のクエリは、単独利用可能な `#hashtag` 演算子を使用しているため有効なクエリになります。

`#xapiv2`

**連結必須の演算子** は、クエリ内でそれ単体では使用できません。少なくとも 1 つの単独利用可能な演算子と一緒に使用する必要があります。これは、これらの演算子だけを使用すると条件が非常に一般的になりすぎて、極めて大量のポストにマッチしてしまうためです。

たとえば、次のクエリは、連結必須の演算子だけを含んでいるためサポートされていません。

`has:media`

`has:links OR is:retweet`

ここで、`"X data"` のような単独利用可能な演算子を追加すると、そのクエリは正しく機能するようになります。

`"X data" has:mentions (has:media OR has:links)`

<div id="boolean-operators-and-grouping">
  #### Boolean operators and grouping
</div>

1つのクエリ内で複数のオペレーターを組み合わせて使いたい場合は、次のような方法が利用できます。

|     |     |
| :--- | :--- |
| **AND logic** | オペレーター同士をスペースで区切って連続して指定すると、ブール演算の「AND」ロジックになります。これは、両方の条件を満たした場合にのみポストがマッチすることを意味します。たとえば、`snow day #NoSchool` は、snow と day という語と、ハッシュタグ #NoSchool を含むポストにマッチします。 |
| **OR logic** | オペレーター同士を OR で区切って連続して指定すると、OR ロジックになります。これは、どちらか一方の条件を満たした場合にポストがマッチすることを意味します。たとえば、`grumpy OR cat OR #meme` を指定すると、少なくとも grumpy または cat という語、あるいはハッシュタグ #meme を含む任意のポストにマッチします。 |
| **NOT logic, negation** | キーワード（または任意のオペレーター）の前にダッシュ (-) を付けると、それを否定（NOT）できます。たとえば、`cat #meme -grumpy` は、ハッシュタグ #meme と語 cat を含み、かつ語 grumpy を含まないポストにマッチします。よく使われるクエリ句として `-is:retweet` があり、これはリツイートにはマッチせず、オリジナルのポスト、引用ポスト、返信のみにマッチします。すべてのオペレーターは否定できますが、否定されたオペレーターだけを単独で使うことはできません。 |
| **Grouping** | かっこを使用してオペレーターをグループ化できます。たとえば、`(grumpy cat) OR (#meme has:images)` は、grumpy と cat という語を両方含むポスト、または画像を持ちハッシュタグ #meme を含むポストのいずれかを返します。AND が先に適用され、その後に OR が適用されることに注意してください。 |

**否定についての注意事項**

オペレーター `is:nullcast` は、常に否定形（`-is:nullcast`）で使用する必要があります。

否定されたオペレーターを単独で使用することはできません。

1組のかっこでグループ化されたオペレーター集合全体をまとめて否定しないでください。代わりに、各オペレーターを個別に否定してください。たとえば、`skiing -(snow OR day OR noschool)` を使う代わりに、`skiing -snow -day -noschool` を使用することを推奨します。 

<div id="order-of-operations">
  #### 演算の順序
</div>

AND と OR のロジックを組み合わせる場合、クエリがどのように評価されるかは次の演算の順序によって決まります。

1. AND ロジックで接続された演算子が最初にまとめて評価される
2. 次に、OR ロジックで接続された演算子が適用される

例:

* `apple OR iphone ipad` は `apple OR (iphone ipad)` として評価されます
* `ipad iphone OR android` は `(iphone ipad) OR android` として評価されます

曖昧さを排除し、クエリが意図したとおりに評価されるようにするために、必要に応じて丸括弧で語句をグループ化してください。 

例:

* `(apple OR iphone) ipad`
* `iphone (ipad OR android)`

<div id="punctuation-diacritics-and-case-sensitivity">
  #### 句読点、ダイアクリティカルマーク、大文字小文字の区別
</div>

文字のアクセントやダイアクリティカルマークを含むキーワードまたはハッシュタグでクエリを指定した場合、そのキーワードやハッシュタグについては、アクセントやダイアクリティカルマークが付いたものと、それらのない通常の文字のみから成るものの両方を含むポストのテキストにマッチします。たとえば、キーワード `Diacrítica` やハッシュタグ `#cumpleaños` を使ったクエリは、*Diacrítica* や *#cumpleaños* だけでなく、í のチルダやエニェ（ñ）のない *Diacritica* や *#cumpleanos* にもマッチします。

アクセントやダイアクリティカルマークを含む文字は、通常の文字と同じように扱われ、単語境界としては扱われません。たとえば、キーワード `cumpleaños` を使ったクエリは、単語 *cumpleaños* を含むアクティビティにのみマッチし、*cumplea*、*cumplean*、*os* を含むアクティビティにはマッチしません。

すべてのオペレーターは大文字と小文字を区別せずに評価されます。たとえば、クエリ `cat` は、*cat*、*CAT*、*Cat* を含むポストすべてにマッチします。

[filtered stream](/ja/x-api/posts/filtered-stream) のマッチング動作は、Search Posts とは異なります。[filtered stream ルールを作成する](/ja/x-api/posts/filtered-stream#building-rules-for-filtered-stream)場合、アクセントやダイアクリティカルマークを含むキーワードやハッシュタグは、同じアクセントやダイアクリティカルマークを含む用語にのみマッチし、代わりに通常の文字を使用している用語にはマッチしないことに注意してください。 

たとえば、filtered stream ルールにキーワード `Diacrítica` やハッシュタグ `#cumpleaños` を含めた場合、それらは *Diacrítica* および *#cumpleaños* の用語にのみマッチし、í のチルダやエニェ（ñ）のない *Diacritica* や *#cumpleanos* にはマッチしません。

<div id="specificity-and-efficiency">
  #### 具体性と効率性
</div>

クエリを作成し始めるときは、いくつか注意すべき点があります。

* 単一のキーワードや #ハッシュタグ のような、広範で単独のオペレーターだけをクエリに使うことは、一般的には推奨されません。膨大な数のポストにマッチしてしまう可能性が高いためです。より堅牢なクエリを作成することで、より絞り込まれたポストにマッチさせることができ、ペイロード内のノイズが減り、有益なインサイトを見つけるためにふるいにかける必要のあるデータ量を減らすことが期待できます。 
  * たとえば、クエリが `happy` という単一キーワードだけの場合、1 日あたり 200,000 ～ 300,000 件のポストが返ってくる可能性があります。
  * さらに条件オペレーターを追加すると検索結果が絞り込まれます。例: `(happy OR happiness) place_country:GB -birthday -is:retweet`
* 効率的なクエリを作成することは、クエリの文字数制限を守るうえでも有益です。文字数には、スペースやオペレーターを含むクエリ文字列全体がカウントされます。
  * たとえば、次のクエリは 59 文字です: `(happy OR happiness) place_country:GB -birthday -is:retweet`

<div id="quote-tweet-matching-behavior">
  #### 引用ポストのマッチング動作
</div>

Search Posts エンドポイントを使用する場合、オペレーターは引用された元のポストのコンテンツにはマッチせず、引用ポストに含まれるコンテンツにのみマッチします。

ただし、[filtered stream](/ja/x-api/posts/filtered-stream) では、引用された元のポストのコンテンツと引用ポストのコンテンツの両方にマッチする点に注意してください。

<div id="iteratively-building-a-query">
  #### クエリを反復的に作成する
</div>

<div id="test-your-query-early-and-often">
  ##### クエリは早めに、そして頻繁にテストする
</div>

一度目の試行で「正しい」結果を返すクエリを作成できることは稀です。X には非常に多くの情報があり、最初は一見して分からないものもありますし、上で説明したクエリ構文を、望む検索内容にうまく合わせるのが難しい場合もあります。クエリを構築する際は、途中の段階でも定期的に試しに実行してみることが重要です。

このセクションでは、次のクエリから開始し、テストで得られた結果に基づいて調整していきます。 

`happy OR happiness`

<div id="use-results-to-narrow-the-query">
  ##### クエリを絞り込むために結果を活用する
</div>

クエリをテストする際には、返されるポストを確認し、期待しているデータが含まれているかどうかを確認する必要があります。最初は範囲の広いクエリと、ポストにマッチする結果のスーパーセットから始めることで、結果をレビューしながらクエリを絞り込み、不要な結果をフィルタリングできます。  

サンプルクエリをテストしたところ、さまざまな言語のポストが取得されることに気付きました。この場合、英語のポストのみを取得したいので、`lang:` オペレーターを追加します:

`(happy OR happiness) lang:en`

テストの結果、人にハッピーバースデーを祝うポストが多数返ってきたため、否定キーワードオペレーターとして `-birthday` を追加します。また、オリジナルのポストのみを取得したいので、否定オペレーター `-is:retweet` も追加します:

`(happy OR happiness) lang:en -birthday -is:retweet`

<div id="adjust-for-inclusion-where-needed">
  ##### 必要に応じて包含条件を調整する
</div>

期待しているデータが返ってこない一方で、実際には返ってきてほしい既存のポストがあることが分かっている場合は、目的のデータを除外している可能性のあるオペレーターを削除して、クエリの範囲を広げる必要があるかもしれません。 

この例では、探している感情を表現しているにもかかわらずテスト結果には含まれていない他のポストが、自分のタイムラインに存在することに気付きました。網羅性を高めるために、キーワード `excited` と `elated` を追加します。

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet`

<div id="adjust-for-popular-trendsbursts-over-the-time-period">
  ##### 期間中の人気トレンドや急増に合わせて調整する
</div>

X ではトレンドの移り変わりが非常に速く起こります。クエリは継続的にメンテナンスする必要があります。クエリをしばらく使い続ける予定がある場合は、定期的に受信しているデータを確認し、調整が必要かどうかを判断することをおすすめします。

この例では、人々に「happy holidays」と伝えるポストが取得され始めていることに気付きました。これらのポストを結果に含めたくないため、否定キーワード `-holidays` を追加します。

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet -holidays`

<div id="adding-a-query-to-your-request">
  ### リクエストへのクエリの追加
</div>

クエリをリクエストに追加するには、`query` パラメータを使用する必要があります。ほかのクエリパラメータと同様に、作成したクエリは必ず HTTP エンコードしてください。

以下は、cURL コマンドを使った例です。ここでは追加で `tweet.fields` と `max_results` パラメータも含めています。このコマンドを使用する場合は、必ず `$BEARER_TOKEN` をご自身の [Bearer Token](/ja/resources/fundamentals/authentication#oauth-2-0) に置き換えてください。

```bash
curl https://api.x.com/2/tweets/search/recent?query=cat%20has%3Amedia%20-grumpy&tweet.fields=created_at&max_results=100 -H "Authorization: Bearer $BEARER_TOKEN"
```

<div id="query-examples">
  ### クエリ例
</div>

<div id="tracking-a-natural-disaster">
  #### 自然災害の追跡
</div>

次のクエリは、2017 年にヒューストンを襲った Hurricane Harvey について言及している気象機関や観測所からのオリジナルのポストにマッチするものです。

HTTP エンコード前のクエリは次のようになります：

`has:geo (from:NWSNHC OR from:NHC\_Atlantic OR from:NWSHouston OR from:NWSSanAntonio OR from:USGS\_TexasRain OR from:USGS_TexasFlood OR from:JeffLindner1) -is:retweet`

HTTP エンコードを行い、クエリパラメーターと recent search エンドポイントの URI を含めると、クエリは次のようになります：

`https://api.x.com/2/tweets/search/recent?query=-is%3Aretweet%20has%3Ageo%20(from%3ANWSNHC%20OR%20from%3ANHC\_Atlantic%20OR%20from%3ANWSHouston%20OR%20from%3ANWSSanAntonio%20OR%20from%3AUSGS\_TexasRain%20OR%20from%3AUSGS_TexasFlood%20OR%20from%3AJeffLindner1)`

<div id="reviewing-the-sentiment-of-a-conversation">
  #### 会話のセンチメントを確認する
</div>

次のルールは、ハッシュタグ *#nowplaying* を中心に展開している会話のセンチメントをよりよく理解するために使用できます。ただし、北米内で公開されたポストのみに範囲を限定しています。

以下は、ポジティブ用とネガティブ用それぞれの 2 つのクエリを、HTTP エンコードなしで記述した場合の例です。

`#nowplaying (happy OR exciting OR excited OR favorite OR fav OR amazing OR lovely OR incredible) (place\_country:US OR place\_country:MX OR place_country:CA) -horrible -worst -sucks -bad -disappointing`

`#nowplaying (horrible OR worst OR sucks OR bad OR disappointing) (place\_country:US OR place\_country:MX OR place_country:CA) -happy -exciting -excited -favorite -fav -amazing -lovely -incredible`

そして、HTTP エンコード済みのクエリパラメータと recent search URI を含めると、クエリは次のようになります。

`https://api.x.com/2/tweets/search/recent?query=%23nowplaying%20(happy%20OR%20exciting%20OR%20excited%20OR%20favorite%20OR%20fav%20OR%20amazing%20OR%20lovely%20OR%20incredible)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place_country%3ACA)%20-horrible%20-worst%20-sucks%20-bad%20-disappointing`

`https://api.x.com/2/tweets/search/recent?query=%23nowplaying%20(horrible%20OR%20worst%20OR%20sucks%20OR%20bad%20OR%20disappointing)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place_country%3ACA)%20-happy%20-exciting%20-excited%20-favorite%20-fav%20-amazing%20-lovely%20-incredible`

<div id="find-posts-that-relate-to-a-specific-post-annotation">
  #### 特定の Post アノテーションに関連するポストを探す
</div>

このルールは、ポスト内の言語が日本語と判定されていて、かつ猫ではないペットの画像を含むオリジナルポストを検索するために作成されています。そのために、`context:` 演算子を使用して、[Post annotation](/ja/x-api/fundamentals/post-annotations) 機能を活用しました。まず、[Post lookup](/ja/x-api/posts/lookup/introduction) エンドポイントと `tweet.fields=context_annotations` フィールドパラメータを使用し、クエリで使用する必要がある domain.entity ID を特定しました。

* 猫に関連するポストは、`domain` 66（Interests and Hobbies カテゴリ）と entity 852262932607926273（Cats）を返します。
* ペットに関連するポストは、`domain` 65（Interests and Hobbies Vertical）と entity 852262932607926273（Pets）を返します。

HTTP エンコードを行わない場合、クエリは次のようになります。

`context:65.852262932607926273 -context:66.852262932607926273 -is:retweet has:images lang:ja`

HTTP エンコード後のクエリ、`query` パラメータ、および recent search エンドポイントの URI は次のようになります。

`https://api.x.com/2/tweets/search/recent?query=context%3A65.852262932607926273%20-context%3A66.852262932607926273%20-is%3Aretweet%20has%3Aimages%20lang%3Aja`

追加のサポートが必要な場合は、[クエリビルダーツール](https://developer.x.com/apitools/query?query=) を試してみてください。