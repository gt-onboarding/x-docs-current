---
title: ページネーション
sidebarTitle: ページネーション
keywords: ["検索結果のページネーション", "ページネーションガイド", "結果をページングする", "ページネーショントークン", "検索結果のページネーション", "next_token"]
---

<div id="recent-search-pagination">
  ### Recent search エンドポイントのページネーション
</div>

<div id="introduction">
  #### はじめに
</div>

検索クエリは、通常 1 回の API レスポンスで返せる数を超えるポストにマッチします。その場合、データは一連の「ページ」に分割されて返されます。ページネーションとは、すべてのページを順番にリクエストして、データセット全体を取得するための手法を指します。

以下は、recent search のページネーションの基本事項です。

* recent search エンドポイントは、クエリに対して少なくとも 1 ページ分のレスポンスを返し、追加のページが利用可能な場合は JSON レスポンス内に next&#95;token を含めます。一致するポストをすべて取得するには、レスポンスにトークンが含まれなくなるまで、この処理を繰り返します。

* next&#95;token は有効期限が切れません。同じ next&#95;token の値を使用した複数のリクエストは、リクエストしたタイミングに関係なく、同じ結果を受け取ります。

* ポストは UTC タイムゾーンで新しい順（逆時系列）に返されます。これは個々のページ内だけでなく、複数ページにまたがっても同様です。 
  * 最初のレスポンスの最初のポストが、クエリにマッチする中で最も新しいポストになります。
  * 最後のレスポンスの最後のポストが、クエリにマッチする中で最も古いポストになります。

* max&#95;results リクエストパラメータを使用すると、レスポンスごとに返されるポスト数を指定できます。デフォルトは 10 ポストで、最大値は 100 です。 

* すべてのページネーション実装では、レスポンスペイロードから next&#95;token をパースして取り出し、それを「次のページ」の検索リクエストに含める必要があります。これらの「次のページ」リクエストの構築方法については、後述の詳細を参照してください。
   

recent search エンドポイントは、次の 2 つの基本的な利用パターンをサポートするように設計されています。

* **履歴の取得 (Get historical)** - 関心のある期間に投稿された、一致するポストをリクエストします。これは一般的に、履歴調査を目的とした一度きりのリクエストです。検索リクエストは start&#95;time と end&#95;time リクエストパラメータに基づいて行うことができます。recent search エンドポイントは、最も新しい一致ポストから始めて、ポストを新しい順（逆時系列）に返します。 

* **ポーリング (Polling)** - 直前に取得したポスト以降に投稿された、一致するポストをリクエストします。これらのユースケースは、ほぼリアルタイムなニーズを持つケースが多く、新しい関心のあるポストを「待ち受ける」頻繁なリクエストが特徴です。recent search エンドポイントは、「ポーリング」パターンをサポートするために since&#95;id リクエストパラメータを提供しています。ポスト ID を使ったナビゲーションを容易にするため、until&#95;id リクエストパラメータも利用できます。
   

次に、履歴モードについて説明します。これは recent search エンドポイントのデフォルトモードであり、ページネーションの基本を示すものです。その後、ポーリングのユースケースの例について説明します。ポーリングがページネーションを引き起こす場合、検索リクエストを管理するための追加ステップが必要になります。
 

<div id="retrieving-historical-data">
  #### 過去データの取得
</div>

このセクションでは、`start_time` と `end_time` リクエストパラメータを使用して、関心のある期間（現在は過去 7 日間に限定）からポストを取得する方法の概要を説明します。過去データのリクエストは、通常、調査や分析を目的とした一度きりのリクエストです。 

特定の期間に対するデータのリクエストは、recent search エンドポイントのデフォルト動作です。検索リクエストで `start_time`、`end_time`、`since_id` のいずれのリクエストパラメータも指定しない場合、`end_time` は「現在」（実際にはクエリ実行時刻の 30 秒前）に、`start_time` は 7 日前に自動的に設定されます。

エンドポイントは、最も新しいポストから始まる逆時系列で並んだ、最初の「ページ」分のポストを返します。レスポンス JSON ペイロードには、追加のデータページがある場合に `next_token` も含まれます。マッチするポストをページ数に関係なくすべて収集するには、`next_token` が返されなくなるまでリクエストを繰り返します。 

例えば、直近 1 週間においてキーワード snow を含むポストに対する最初のリクエストは次のようになります。

[https://api.x.com/2/tweets/search/recent?query=snow](https://api.x.com/2/tweets/search/recent?query=snow)

このレスポンスには、最新の 10 件のポストとともに、JSON レスポンス内の次の「meta」属性が含まれます。

```
"meta": {
        "newest_id": "1204860593741553664",
        "oldest_id": "1204860580630278147",
        "next_token": "b26v89c19zqg8o3fobd8v73egzbdt3qao235oql",
        "result_count": 10
    }
```

次の10件のポストを取得するには、この next&#95;token を元のリクエストに追加します。リクエストは次のようになります。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;next&#95;token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql](https://api.x.com/2/tweets/search/recent?query=snow\&next_token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql)

next&#95;token を探して、それを次のリクエストに含める処理は、すべての（または任意の数の）ポストが収集されるまで、あるいは指定した回数のリクエストが行われるまで繰り返すことができます。データの網羅性（クエリにマッチするものをすべて収集すること）がユースケースで重要な場合は、単純な「request.next&#95;token が null になるまで繰り返す」という設計で十分です。

<div id="polling-and-listening-use-cases">
  #### ポーリングおよびリスニングのユースケース
</div>

このセクションでは、`since_id` リクエストパラメータを使用して recent search エンドポイントをポーリングすることで、最近のポストを取得する方法を説明します。 

ポーリングのユースケースでは、「関心のある新しいポストはあるか？」というクエリを継続的かつ高頻度で実行します。リクエストを時間基準で行う履歴系ユースケースとは異なり、ポーリングユースケースでは一般的にポスト ID を基準にリクエストを行います。

ポーリング利用パターンの中心となる考え方は、すべての新しいポストには [unique ID](/ja/resources/fundamentals/x-ids) があり、これは X プラットフォームから一般的に昇順になるように「発行」されるという点です。あるポストの ID が別のポストより小さい場合、そのポストの方が先に投稿されたことを意味します。

recent search エンドポイントは、ポスト ID によるポストアーカイブのナビゲーションをサポートしています。エンドポイントからのレスポンスには、`oldest_id` と `newest_id` のポスト ID が含まれます。ポーリングモードでは、これまでに受け取った中で最大／最新の ID を `since_id` に設定してリクエストを行います。 

たとえば、「snow」に関する新しいポストを 5 分ごとにクエリし、最後に受け取ったポストのポスト ID が 10000 だったとします。ポーリングするタイミングになったら、リクエストは次のようになります。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=10000](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=10000)

次に、前回のリクエスト以降に 7 件のポストが投稿されたとします。これらがすべて 1 つのデータ「ページ」に収まる場合、`next_token` は存在しません。レスポンスには、最新（newest）のポスト ID が含まれます。

```
"meta": {
        "newest_id": "12000",
        "oldest_id": "10005",
        "result_count": 7
    }
```

次のポーリングクエリを行うには、この newest&#95;id の値を使って次の since&#95;id パラメータを設定します。

`https://api.x.com/2/tweets/search/recent?query=snow&since_id=12000`

利用可能な追加データがあり、next トークンが返される場合は、結果の最初のページに含まれる newest&#95;id の値だけを使えば十分です。各ページのデータには newest&#95;id と oldest&#95;id の値が含まれますが、次の定期的なポーリングリクエストに必要なのは最初のページで返される値だけです。したがって、ポーリング方式を実装する場合や、ID の範囲でポストを検索する場合、ページネーションロジックは少し複雑になります。 

ここで、新たに一致するポストが 18 件あるとします。エンドポイントは、この 5 分間の期間から次のデータページを要求するための、1 ページ分の完全なデータと next&#95;token を含む最初のレスポンスを返します。また、次の 5 分後のポーリング間隔で必要となる最新のポスト ID も含まれます。

```
"meta": {
        "newest_id": "13800",
        "oldest_id": "12500",
        "next_token": "fnsih9chihsnkjbvkjbsc",
        "result_count": 10
    }
```

この5分間にマッチするすべてのデータを取得するには、前回のリクエストと同じ since&#95;id の値を指定したうえで、next&#95;token を次のリクエストに渡します。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=12000&amp;next&#95;token=fnsih9chihsnkjbvkjbsc](https://api.x.com/2/tweets/search/recent?query=snow\&since\\_id=12000\&next\\_token=fnsih9chihsnkjbvkjbsc)

```
"meta": {
        "newest_id": "12300",
        "oldest_id": "12010",
        "result_count": 8
    }
```

この 2 回目のレスポンスでは、残りの 8 件のポストが返され、next&#95;token は含まれません。newest&#95;id の値 (12300) は更新せず、代わりに次回の since&#95;id を指定したリクエストは最初のレスポンスの newest&#95;id の値に基づいて送信する点に注意してください:

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=13800](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=13800)
