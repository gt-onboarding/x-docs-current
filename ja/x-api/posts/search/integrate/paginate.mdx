---
title: ページネーション
sidebarTitle: ページネーション
keywords: ["検索結果のページネーション", "ページネーションガイド", "結果をページングする", "ページネーショントークン", "検索 ページネーション", "next token"]
---

<div id="recent-search-pagination">
  ### Recent search におけるページネーション
</div>

<div id="introduction">
  #### はじめに
</div>

検索クエリは、通常 1 回の API レスポンスで返せる数より多くのポストにマッチします。その場合、データは複数の「ページ」に分割されて返されます。ページネーションとは、データセット全体を取得するために、すべてのページを順番にリクエストする方法を指します。

ここでは、recent search のページネーションに関する基本的なポイントを説明します。

* recent search エンドポイントは、クエリに対して少なくとも 1 ページを返し、追加のページが利用可能な場合は JSON レスポンス内に next&#95;token を含めます。一致するポストをすべて取得するには、このプロセスを、レスポンスにトークンが含まれなくなるまで繰り返します。

* next&#95;token は有効期限切れになりません。同じ next&#95;token の値を使った複数のリクエストは、リクエストを行ったタイミングに関係なく、同じ結果を返します。

* ポストは UTC タイムゾーンにおいて、新しいものから古いものへと並ぶ逆時系列順で配信されます。これは各ページ内でも、複数ページにまたがる場合でも同様です。 
  * 最初のレスポンス内の最初のポストは、クエリにマッチした中で最も新しいポストになります。
  * 最後のレスポンス内の最後のポストは、クエリにマッチした中で最も古いポストになります。

* max&#95;results リクエストパラメータを使用すると、1 回のレスポンスで返されるポスト数を設定できます。デフォルトは 10 件のポストで、最大は 100 件です。 

* すべてのページネーション実装では、レスポンスペイロードから next&#95;token をパースし、それを「次ページ」の検索リクエストに含める必要があります。これらの「次ページ」リクエストをどのように構築するかについては、以下で詳しく説明します。
   

recent search エンドポイントは、次の 2 つの基本的な利用パターンをサポートするよう設計されています。

* **履歴データの取得 (Get historical)** - 関心のある期間に投稿された、一致するポストをリクエストします。通常、履歴調査を目的とした一度きりのリクエストです。検索リクエストは start&#95;time と end&#95;time のリクエストパラメータに基づいて行うことができます。recent search エンドポイントは、一致する中で最も新しいポストから開始し、逆時系列順でポストを返します。 

* **ポーリング (Polling)** - 最後に受信したポスト以降に投稿された、一致するポストをリクエストします。これらのユースケースは、しばしばほぼリアルタイムな性質を持ち、新しい関心対象のポストを「待ち受ける」頻繁なリクエストが特徴です。recent search エンドポイントは、この「ポーリング」パターンをサポートするために since&#95;id リクエストパラメータを提供します。ポスト ID によるナビゲーションを容易にするため、until&#95;id リクエストパラメータも利用できます。
   

次に、履歴モードについて説明します。これは recent search エンドポイントのデフォルトモードであり、ページネーションの基本を示すものです。その後、ポーリングのユースケースの例について説明します。ポーリングによってページネーションが発生する場合、検索リクエストを管理するための追加ステップが必要になります。
 

<div id="retrieving-historical-data">
  #### 過去データの取得
</div>

このセクションでは、`start_time` と `end_time` リクエストパラメータを使用して、関心のある期間（現在は直近 7 日間に限定）からポストを取得する方法について説明します。過去データのリクエストは、通常、調査や分析を目的とした一度きりのリクエストです。 

一定期間のデータを取得するリクエストは、recent search エンドポイントのデフォルトの動作です。検索リクエストで `start_time`、`end_time`、または `since_id` リクエストパラメータが指定されていない場合、`end_time` は「現在」（実際にはクエリ実行時刻の 30 秒前）がデフォルトとなり、`start_time` は 7 日前がデフォルトとなります。

エンドポイントは、もっとも新しいポストから始まる逆時系列の最初の「ページ」のポストを返します。レスポンスの JSON ペイロードには、追加のデータページが存在する場合、`next_token` も含まれます。一致するポストの集合をページ数に関係なくすべて収集するには、`next_token` が返されなくなるまでリクエストを繰り返します。 

たとえば、直近 1 週間に投稿された、キーワード snow を含むポストに対する最初のリクエストは次のようになります。

[https://api.x.com/2/tweets/search/recent?query=snow](https://api.x.com/2/tweets/search/recent?query=snow)

レスポンスには、もっとも新しい 10 件のポストとともに、JSON レスポンス内の次の「meta」属性が含まれます。

```
"meta": {
        "newest_id": "1204860593741553664",
        "oldest_id": "1204860580630278147",
        "next_token": "b26v89c19zqg8o3fobd8v73egzbdt3qao235oql",
        "result_count": 10
    }
```

次の 10 件のポストを取得するには、この next&#95;token を元のリクエストに追加します。リクエストは次のようになります。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;next&#95;token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql](https://api.x.com/2/tweets/search/recent?query=snow\&next_token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql)

next&#95;token を探し、それを次のリクエストに含める処理は、すべての（または所定の件数分の）ポストが収集されるまで、あるいは指定された回数のリクエストが行われるまで繰り返すことができます。データの完全取得（クエリに一致するものをすべて収集すること）がユースケースで重要な場合は、単純な「request.next&#95;token が null になるまで繰り返す」という設計で十分です。

<div id="polling-and-listening-use-cases">
  #### ポーリングおよびリッスンのユースケース
</div>

このセクションでは、`since_id` リクエストパラメータを使用して recent search エンドポイントをポーリングすることで、最新のポストを取得する方法を説明します。 

ポーリングのユースケースでは、「新しく関心のあるポストはあるか？」という問い合わせを継続的かつ頻繁に行います。時間を基準にリクエストを行う履歴系のユースケースとは異なり、ポーリングのユースケースでは、一般的にポスト ID を基準にリクエストを行います。

ポーリング利用パターンの中心となるのは、すべての新しいポストには [unique ID](/ja/resources/fundamentals/x-ids) があり、X プラットフォームから概ね昇順で「発行」されるという点です。あるポストの ID が別のポストの ID より小さい場合、そのポストの方が先に投稿されたことを意味します。

recent search エンドポイントは、ポスト ID を使ってポストアーカイブをたどれるようになっています。エンドポイントからのレスポンスには、`oldest_id` と `newest_id` のポスト ID が含まれます。ポーリングモードでは、これまでに受け取った中で最大／最新の ID を `since_id` に設定してリクエストを行います。 

たとえば、「snow」に関する新しいポストのクエリを 5 分ごとに行っていて、最後に受け取ったポストのポスト ID が 10000 だったとします。ポーリングするタイミングになったとき、リクエストは次のようになります。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=10000](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=10000)

次に、前回のリクエスト以降に 7 件のポストが投稿されたとします。これらはすべて 1 つのデータ「ページ」に収まるため、`next_token` は存在しません。返されるレスポンスには、もっとも新しい（最新の）ポストのポスト ID が含まれます。

```
"meta": {
        "newest_id": "12000",
        "oldest_id": "10005",
        "result_count": 7
    }
```

次のポーリングクエリを行うには、この newest&#95;id の値を使って次の since&#95;id パラメータを設定します:

`https://api.x.com/2/tweets/search/recent?query=snow&since_id=12000`

利用可能な追加データがあり、next&#95;token が返される場合は、結果の最初のページに含まれる newest&#95;id の値だけが必要です。各ページのデータには newest&#95;id と oldest&#95;id の値が含まれますが、次の定期的なポーリングリクエストに必要なのは、最初のページで提供される値だけです。したがって、ポーリング方式を実装する場合や、ID の範囲でポストを検索する場合、ページネーションのロジックはやや複雑になります。 

ここで、新たに一致するポストが 18 件あるとします。エンドポイントは、この 5 分間の期間について 1 ページ分のデータと、次のページのデータを要求するための next&#95;token を含む最初のレスポンスを返します。また、次の 5 分後のポーリング間隔で必要となる最新のポスト ID も含まれます。

```
"meta": {
        "newest_id": "13800",
        "oldest_id": "12500",
        "next_token": "fnsih9chihsnkjbvkjbsc",
        "result_count": 10
    }
```

この5分間の対象期間にマッチするすべてのデータを収集するには、前回のリクエストと同じ since&#95;id の値とあわせて、次回のリクエストで next&#95;token を指定してください。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=12000&amp;next&#95;token=fnsih9chihsnkjbvkjbsc](https://api.x.com/2/tweets/search/recent?query=snow\&since\\_id=12000\&next\\_token=fnsih9chihsnkjbvkjbsc)

```
"meta": {
        "newest_id": "12300",
        "oldest_id": "12010",
        "result_count": 8
    }
```

この2回目のレスポンスでは、残りの8件のポストが返され、next&#95;token は含まれません。newest&#95;id の値（12300）は更新せず、代わりに次回の since&#95;id を指定したリクエストは、最初のレスポンスの newest&#95;id の値に基づいて行う点に注意してください。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=13800](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=13800)
