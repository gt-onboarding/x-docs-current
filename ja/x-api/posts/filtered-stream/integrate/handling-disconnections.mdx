---
title: 切断の処理
sidebarTitle: 切断の処理
keywords: ["ストリーミングの切断", "切断の処理", "ストリームの再接続", "ストリーム再接続", "切断時の処理", "ストリームエラー"]
---

<div id="what-is-a-disconnection">
  ### 切断とは何ですか？
</div>

streaming API への接続を確立するということは、非常に長時間にわたって有効な HTTPS リクエストを発行し、そのレスポンスを逐次的に解析することを意味します。filtered stream エンドポイントに接続する場合は、HTTPS リクエストを作成し、現実的に可能な限り長く、その結果として返されるストリームを受信し続ける必要があります。サーバー側のエラー、クライアント側の過度な遅延、ネットワークの問題、定期的なサーバーメンテナンス、または重複ログインがない限り、当社のサーバーは接続を無期限に維持します。streaming エンドポイントへの接続では、切断が発生する可能性が高く、その発生を前提として再接続ロジックを実装しておく必要があります。
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### ストリーミング接続が切断される理由
</div>

ストリームはいくつかの理由で切断される可能性があります。失敗の理由を把握するために、ストリームから返されるエラーメッセージを確認してください。切断される主な理由には次のようなものがあります。

* 認証エラー（誤ったトークンの使用や、不適切な認証方式の利用など）。
* X 側でストリーミングサーバーが再起動された場合。これは通常、コードのデプロイに関連しており、一般的に発生しうる事象として想定し、それを前提に設計しておく必要があります。
* クライアントがストリームから配信されるポストの量に処理が追いつかない、またはデータの読み取りが遅すぎる場合。すべてのストリーミング接続には、クライアントに送信されるメッセージのキューが存在します。このキューが時間の経過とともに大きくなりすぎると、接続は閉じられます。
* アカウントが日次／月次のポスト数に対するクオータを超過した場合。
* 冗長なアクティブ接続が多すぎる場合。
* クライアントが突然データの読み取りを停止した場合。ストリームから読み取られるポストのレートが急激に低下すると、接続は閉じられます。
* サーバーとクライアント間のネットワークに問題が発生している場合。
* 一時的なサーバー側の問題、計画メンテナンスやアップデートが行われている場合（[ステータスページ](https://api.twitterstat.us/)を確認してください）。
   

<div id="common-disconnection-errors-include">
  #### 代表的な切断エラーには次のようなものがあります:
</div>

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "このストリームは運用上の理由により上流で切断されました。",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "このストリームは現在、許可されている最大接続数に達しています。",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### 切断を想定し、再接続する
</div>

ポストのストリーミングでは、切断が発生しうることを認識しつつ、できるだけ長く接続を維持することが目標です。エンドポイントは 20 秒間隔のキープアライブのハートビート（改行文字として送信されます）を提供します。このシグナルを使って、切断されていないかどうかを検出してください。

1. 新しいコンテンツとハートビートの両方が届かなくなったことを、コードで検出できるようにします。
2. その場合、コードは再接続ロジックを起動する必要があります。一部のクライアントや言語では読み取りタイムアウトを指定できるので、これを 20 秒に設定できます。
3. サービスはこれらの切断を検出し、可能な限り早く再接続する必要があります。

一度確立した接続が切れた場合は、直ちに再接続を試みてください。再接続に失敗した場合は、発生したエラーの種類に応じて、再接続試行の間隔を延ばしてください。

* TCP/IP レベルのネットワークエラーに対しては、線形にバックオフします。これらの問題は一般的に一時的であり、すぐに解消される傾向があります。再接続までの遅延を試行ごとに 250ms ずつ増やし、最大 16 秒までとします。
* 再接続が適切な HTTP エラーに対しては、指数関数的にバックオフします。5 秒待機から開始し、試行ごとに待機時間を 2 倍にし、最大 320 秒までとします。
* HTTP 429 エラー（レート制限超過）に対しては、指数関数的にバックオフします。1 分待機から開始し、試行ごとに待機時間を 2 倍にします。HTTP 429 を受信するたびに、アカウントに対するレート制限が解除されるまで待機しなければならない時間が増加する点に注意してください。
   

<div id="recovering-lost-data">
  #### 失われたデータの復旧
</div>

切断が発生した場合でも、取り逃した可能性のあるデータをすべて確実に取得するために使える、いくつかの有効な方法があります。取り逃したデータを復旧するために実行できる主なステップについては、[データの復旧](/ja/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features) に関する連携ガイドで解説しています。 
 

<div id="rate-limits-and-usage">
  #### レート制限と使用状況
</div>

接続制限を確認するには、レスポンスで 3 つのヘッダーが返されます。これは、ルール用エンドポイントを何回使用できるか、およびストリーミングエンドポイントに対して何回再接続試行が許可されているかを把握するのに役立ちます。

* `x-rate-limit-limit` は、15 分間のウィンドウ内でクライアントが実行できるリクエスト数の上限を示します。

* `x-rate-limit-remaining` は、15 分間のウィンドウ内で残っているリクエスト数を示します。

* `x-rate-limit-reset` は、15 分間のウィンドウがいつ再開し、その際に `x-rate-limit-remaining` が 0 にリセットされるかを示す UNIX タイムスタンプです。

filter stream エンドポイントは現在、使用状況データを報告しません。配信されたポストの数を確認するには、必要に応じて消費量を計測および一時停止できるよう、コード側でメータリングロジックを実装することで対応できます。 

ストリームのクライアント側をホストするコードは、受信したポストを先入れ先出し (FIFO) キューまたは同様のメモリ構造に単純に挿入し、別のプロセス／スレッドがそのキューからポストを取り出して解析し、保存用にコンテンツを準備します。この設計により、受信するポスト量が大幅に変動した場合でも効率的にスケールできるサービスを実装できます。概念的には、HTTP 経由で無限に長いファイルをダウンロードしているようなイメージです。

<div id="reconnection-best-practices">
  #### 再接続のベストプラクティス
</div>

**バックオフ戦略をテストする**

バックオフ実装をテストするよい方法は、無効な認可情報を使い、再接続試行を確認することです。適切な実装であれば、HTTP 429 応答を一切受け取りません。

**複数回の再接続に対してアラートを発行する**

クライアントの再接続間隔が設定した上限しきい値に達した場合は、接続に影響している問題を切り分けられるよう、通知を送信する必要があります。

**DNS の変更を処理する**

クライアントプロセスが DNS の Time To Live（TTL）に従っていることをテストしてください。一部のスタックは、プロセスの存続期間中、解決済みアドレスをキャッシュし、指定された TTL 内の DNS 変更を反映しないことがあります。このような過度のキャッシュは、X が IP アドレス間で負荷分散を行う際に、クライアント側のサービス中断につながります。

**User Agent**

`user-agent` HTTP ヘッダーにクライアントのバージョンが含まれていることを確認してください。これは X 側で問題を診断するうえで非常に重要です。実行環境の制約で `user-agent` フィールドを設定できない場合は、代わりに `x-user-agent` ヘッダーを設定してください。