---
title: 切断時の対処
sidebarTitle: 切断時の対処
keywords: ["ストリーミングの切断", "切断への対処", "ストリームの再接続", "ストリーム再接続", "切断時の処理", "ストリームエラー"]
---

<div id="what-is-a-disconnection">
  ### 切断とは何ですか？
</div>

streaming API への接続を確立するということは、非常に長時間にわたる HTTPS リクエストを行い、そのレスポンスを逐次的に解析することを意味します。filtered stream エンドポイントに接続する場合は、HTTPS リクエストを送信し、可能な限り長くその結果のストリームを受信し続ける必要があります。サーバー側のエラー、クライアント側の過度な遅延、ネットワークの問題、定期的なサーバーメンテナンス、または重複ログインが発生しない限り、当社のサーバーは接続を無期限に維持します。streaming エンドポイントへの接続では、接続が切断される可能性は高く、それを前提として再接続ロジックを実装しておく必要があります。
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### ストリーミング接続が切断される理由
</div>

ストリームは、さまざまな理由で切断されることがあります。失敗の理由を把握するために、ストリームから返されるエラーメッセージを確認してください。切断される主な理由は次のとおりです。

* 誤ったトークンや誤った認証方式の使用などによる認証エラー。
* X 側でストリーミングサーバーが再起動された場合。これは通常、コードのデプロイに関連して発生し、起こりうるものとしてあらかじめ想定し、設計に織り込む必要があります。
* クライアントがストリームから配信されるポストの量についていけていない、またはデータを読む速度が遅すぎる場合。すべてのストリーミング接続には、クライアントに送信されるメッセージのキューが存在します。このキューが時間とともに大きくなりすぎると、接続は閉じられます。
* アカウントが 1 日または 1 か月あたりのポスト数のクォータを超過した場合。
* 冗長なアクティブ接続が多すぎる場合。
* クライアントが突然データの読み取りを停止した場合。ストリームから読み取られるポストのレートが急激に低下すると、接続は閉じられます。
* サーバーとクライアント間のネットワーク上の問題が発生している場合。
* 一時的なサーバー側の問題、計画メンテナンスやアップデートが行われている場合。（[ステータスページ](https://api.twitterstat.us/) を確認してください）
   

<div id="common-disconnection-errors-include">
  #### よく発生する切断エラーには次のようなものがあります:
</div>

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "このストリームは運用上の理由により上流で切断されました。",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "このストリームは現在、許可されている最大接続数に達しています。",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### 切断を予期し再接続する
</div>

ポストをストリーミングする際の目標は、切断が発生し得ることを念頭に置きつつ、可能な限り長く接続を維持することです。エンドポイントは 20 秒ごとにキープアライブ用のハートビート（改行文字として現れます）を送信します。このシグナルを使って、切断されていないかどうかを検知してください。

1. 新しいコンテンツとハートビートの両方が届かなくなったことをコードで検知する必要があります。
2. その場合、コードは再接続ロジックを起動する必要があります。一部のクライアントや言語では読み取りタイムアウトを指定できるため、これを 20 秒に設定できます。
3. サービスはこれらの切断を検知し、できるだけ早く再接続する必要があります。

一度確立された接続が途切れたら、直ちに再接続を試みてください。再接続に失敗した場合は、発生したエラーの種類に応じて、再接続試行の頻度を下げてください。

* TCP/IP レベルのネットワークエラーの場合は線形バックオフを行います。これらの問題は一般的に一時的であり、すぐに解消される傾向があります。再接続の遅延を試行ごとに 250ms ずつ増やし、最大で 16 秒までとします。
* 再接続が適切な HTTP エラーの場合は指数バックオフを行います。待機時間を 5 秒から開始し、試行ごとに 2 倍にして、最大で 320 秒までとします。
* HTTP 429 エラー（Rate limit exceeded）の場合も指数バックオフを行います。待機時間を 1 分から開始し、試行ごとに 2 倍にします。HTTP 429 を受信するたびに、そのアカウントに対するレート制限が解除されるまで待機しなければならない時間が増加することに注意してください。
   

<div id="recovering-lost-data">
  #### 欠損データの復旧
</div>

切断が発生した場合、取り逃した可能性のあるすべてのデータを確実に受信できるようにするために利用できる、いくつかの戦略があります。取り逃したデータを復旧するために実行できる主な手順については、[recovering data](/ja/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features) に関するインテグレーションガイドで説明しています。 
 

<div id="rate-limits-and-usage">
  #### レート制限と使用状況
</div>

接続制限を確認するには、レスポンスとして 3 つのヘッダーが返されます。これは、ルールエンドポイントを何回使用できるか、およびストリーミングエンドポイントに対して何回再接続を試行できるかを把握するのに役立ちます。

* `x-rate-limit-limit` は、15 分間のウィンドウ内でクライアントが実行できる許可されているリクエスト数を示します。

* `x-rate-limit-remaining` は、15 分間のウィンドウ内で残っているリクエスト数を示します。

* `x-rate-limit-reset` は、15 分間のウィンドウが再開し、`x-rate-limit-remaining` が 0 にリセットされる時刻を示す UNIX タイムスタンプです。

filter stream エンドポイントは現在、使用状況データを報告しません。配信されたポスト数を確認するには、コード側で計測ロジックを実装し、必要に応じて消費量を測定したり一時停止したりできるようにします。 

ストリームのクライアント側をホストするコードは、受信したポストを単純に先入れ先出し (FIFO) キューまたは類似のメモリ構造に挿入します。別のプロセスやスレッドが、そのキューからポストを取り出して解析し、保存用にコンテンツを準備します。この設計により、受信ポスト量が大きく変動した場合でも効率的にスケールできるサービスを実装できます。概念的には、HTTP 経由で無限に長いファイルをダウンロードしていると考えることができます。

<div id="reconnection-best-practices">
  #### 再接続のベストプラクティス
</div>

**バックオフ戦略をテストする**

バックオフ実装をテストする良い方法は、無効な認証情報を使用し、再接続試行を確認することです。適切な実装であれば、429 レスポンスを一切受け取りません。

**複数回の再接続に対してアラートを出す**

クライアントが再接続間隔の上限しきい値に達した場合は、接続に影響している問題をトリアージできるよう、通知を送信する必要があります。

**DNS 変更を処理する**

クライアントプロセスが DNS の Time To Live (TTL) を順守しているかどうかを確認してください。一部のスタックは、プロセスの存続期間中、解決済みアドレスをキャッシュし、指定された TTL 内の DNS 変更を反映しない場合があります。このような過度なキャッシュは、X が IP アドレス間で負荷を分散する際に、クライアント側でサービス障害を引き起こす原因になります。

**User Agent**

`user-agent` HTTP ヘッダーにクライアントのバージョンが含まれるようにしてください。これは X 側で問題を診断するうえで重要になります。環境の制約により `user-agent` フィールドを設定できない場合は、代わりに `x-user-agent` ヘッダーを設定してください。