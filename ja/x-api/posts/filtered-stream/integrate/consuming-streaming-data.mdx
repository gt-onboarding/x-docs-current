---
title: ストリーミングデータの受信
sidebarTitle: ストリーミングデータの受信
keywords: ["ストリーミングデータの受信", "ストリーミングデータ", "ストリームの処理", "ストリーム処理", "ストリーム処理", "ストリームの受信"]
---

<div id="building-a-client-to-consume-streaming-data">
  ### ストリーミングデータを処理するクライアントの構築
</div>

ストリーミングエンドポイントを効率的に利用するために、考慮すべき一般的なベストプラクティスがいくつかあります。  
 

<div id="client-design">
  #### クライアント設計
</div>

filter stream エンドポイントを使ってソリューションを構築する場合、次の機能を備えたクライアントが必要です。

1. filter stream エンドポイントへの HTTPS ストリーミング接続を確立する。
2. ストリームのルールを追加および削除するために、filter stream rules エンドポイントへ POST リクエストを非同期に送信する。
3. 低ボリュームのデータを処理する – ストリーミング接続を維持し、Post オブジェクトとキープアライブシグナルを検出する。
4. 高ボリュームのデータを処理する – 非同期処理を用いてストリームの取り込みを追加処理から切り離し、クライアント側バッファが定期的にフラッシュされるようにする。
5. クライアント側で消費ボリュームのトラッキングを管理する。
6. ストリーム切断を検出し、状況を評価して、自動的にストリームへ再接続する。
    

<div id="connecting-to-a-streaming-endpoint">
  #### ストリーミングエンドポイントへの接続
</div>

X API v2 のストリーミングエンドポイントへの接続を確立するということは、非常に長時間にわたって持続する HTTP リクエストを発行し、レスポンスを逐次的にパースすることを意味します。概念的には、HTTP 経由で無限に長いファイルをダウンロードしているようなものだと考えることができます。接続が一度確立されると、その接続が開いている限り、X サーバーはその接続を通じて Post イベントを配信します。
 

<div id="consuming-data">
  #### データの受信
</div>

個々の JSON オブジェクトのフィールドには順序がなく、また、あらゆる状況で常にすべてのフィールドが存在するとは限らないことに注意してください。同様に、個々のアクティビティは並べ替えられた順序で配信されるわけではなく、重複したメッセージが含まれる場合があります。時間の経過とともに、新しいメッセージ種別が追加されてストリーム経由で送信される可能性があることも念頭に置いてください。

したがって、クライアントは次の点を許容できる必要があります。

* 任意の順序で現れるフィールド
* 想定外のフィールドや欠落しているフィールド
* ソートされていないポスト
* 重複メッセージ
* ストリームを通じていつでも送られてくる新しい任意のメッセージ種別

関連するポストデータおよびリクエストしたフィールドパラメータに加えて、ストリーム接続上では次の種類のメッセージが配信される場合があります。この一覧は網羅的ではない可能性があり、追加のオブジェクトがストリームに導入されることがあります。パーサーが想定外のメッセージ形式にも耐性を持つようにしてください。
 

<div id="buffering">
  #### バッファリング
</div>

ストリーミングエンドポイントは、データが利用可能になり次第できるだけ速く送信するため、多くの場合、大量のデータが流れる可能性があります。X サーバーが新しいデータをすぐにストリームへ書き込めない場合（たとえば、クライアントの読み取りが十分に速くないとき。詳しくは [handling disconnections](/ja/x-api/posts/filtered-stream#what-is-a-disconnection) を参照）、クライアントが追いつけるようにサーバー側でコンテンツがバッファリングされます。しかし、このバッファがいっぱいになると、接続を切断するための強制切断が行われ、そのバッファにたまっていたポストは破棄され、再送されません。詳細は以下を参照してください。

アプリが処理に追いついていないタイミングを特定する 1 つの方法は、受信しているポストのタイムスタンプと現在時刻を比較し、その差を時間経過とともに追跡することです。

パブリックインターネット上で発生しうるレイテンシーや一時的な不具合により、ストリームの滞留を完全になくすことはできませんが、アプリを適切に構成することで大部分を解消できます。バックアップの発生を最小化するには、次の点に留意してください。

* クライアントがストリームを十分な速度で読み取っていることを確認してください。通常、ストリームを読み取りながら実際の処理を行うべきではありません。ストリームを読み取り、そのアクティビティを別のスレッド／プロセス／データストアに渡して、非同期で処理するようにしてください。
* データセンターの受信帯域幅が、大量の継続的なデータ量だけでなく、そのかなり大きなスパイク（例：通常の 5～10 倍のボリューム）にも対応できる十分な容量を持つことを確認してください。filtered stream の場合、発生するボリュームと、それに対応して必要となる帯域幅は、ルールによってマッチしているポストに完全に依存します。
   

<div id="usage-tracking-and-rule-management">
  #### 利用状況の追跡とルール管理
</div>

開発者ごとに、自身のストリームにとってどれくらいのデータ量が「通常」かという期待値が異なるため、特定の割合での増減や期間について、一般的な推奨値は設けていません。 

ストリームのデータ量について、予期しない変動がないか監視することを検討してください。データ量の減少は、ストリーム切断とは異なる問題の兆候である可能性があります。このような状況では、ストリームは引き続きキープアライブ信号や一部の新しいアクティビティデータを受信しているはずです。しかし、ポスト数が大きく減少した場合は、アプリケーションやネットワークへの受信データ量が減少している原因がないか調査し、関連するお知らせがないか[ステータスページ](https://api.twitterstat.us/)を確認してください。

このような監視を行うには、一定時間内に受信すると見込んでいる新規ポスト数を追跡する方法があります。ストリームのデータ量が指定したしきい値を大きく下回り、かつ一定期間内に回復しない場合は、アラートや通知を発報するようにしてください。また、特に filtered stream でルールの変更作業を行っている場合や、ポストのアクティビティがスパイクするようなイベントが発生した場合には、データ量の大幅な増加についても監視することをお勧めします。

filtered stream を通じて配信されるポストは、月間ポスト総量にカウントされることに注意してください。最適化のために、消費量を追跡し、調整する必要があります。ボリュームが高い場合は、必要に応じて各ルールに sample: 演算子を追加し、マッチング率を 100% から sample:50 や sample:25 に下げることを検討してください。 

さらに、事前に設定したしきい値を超えた場合にチームへアラートが送信されるよう、アプリ内に仕組みを実装することを推奨します。あわせて、過剰なデータを取り込んでいるルールの自動削除や、極端な状況ではストリームから完全に切断するといった対策を導入することも検討してください。
 

<div id="responding-to-system-messages">
  #### システムメッセージへの応答
</div>

キープアライブ信号
少なくとも 20 秒ごとに、ストリームは開かれている接続を通じて \r\n キャリッジリターンの形式でキープアライブ信号（ハートビート）を送信し、クライアントがタイムアウトしないようにします。クライアントアプリケーションは、ストリーム内の \r\n 文字を許容できるようにする必要があります。

クライアントが HTTP ライブラリで読み取りタイムアウトを正しく実装していれば、指定期間内にデータが読み取られなかった場合に、HTTP プロトコルおよび HTTP ライブラリが例外のスローなどのイベントを発生させてくれるため、明示的に \r\n 文字を監視する必要はありません。

このイベントは通常、例外のスローや、使用している HTTP ライブラリに応じたその他のイベントになります。これらのタイムアウトを検出するために、HTTP メソッドをエラー／イベントハンドラーでラップすることを強く推奨します。タイムアウト発生時には、アプリケーションは再接続を試行する必要があります。

エラーメッセージ
v2 ストリーミングエンドポイントは、ストリーム内でエラーメッセージを配信する場合もあります。以下に、これらのメッセージの基本フォーマットと、いくつかの例を示します。配信されるメッセージは変更される可能性があり、新しいメッセージが追加されることもあります。クライアントアプリケーションは、変更される可能性のあるシステムメッセージのペイロードを扱えるようにしておく必要があります。

エラーメッセージには、問題の解決方法を説明するドキュメントへのリンクが含まれることに注意してください。

メッセージ形式:

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "このストリームは運用上の理由により上流で切断されました。",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

バッファが一杯になったことによる強制切断を通知するエラーメッセージは、その強制切断を引き起こしたバックアップが原因でメッセージ自体が送信されず、クライアントに届かない可能性があります。そのため、再接続を開始するきっかけとして、これらのメッセージに依存するようなアプリ設計にはしないでください。
