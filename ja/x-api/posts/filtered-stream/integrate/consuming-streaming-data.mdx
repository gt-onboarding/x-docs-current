---
title: ストリーミングデータの取得
sidebarTitle: ストリーミングデータの取得
keywords: ["ストリーミングデータの取得", "ストリーミングデータ", "ストリームの処理", "ストリームのハンドリング", "ストリーム処理", "ストリームの利用"]
---

<div id="building-a-client-to-consume-streaming-data">
  ### ストリーミングデータを取得するクライアントの構築
</div>

ストリーミングエンドポイントを利用する際には、効率的に活用するために押さえておくべき一般的なベストプラクティスがいくつかあります。  
 

<div id="client-design">
  #### クライアント設計
</div>

filter stream エンドポイントを使ってソリューションを構築する場合、次のことが可能なクライアントが必要です。

1. filter stream エンドポイントへの HTTPS ストリーミング接続を確立する。
2. 非同期に POST リクエストを filter stream rules エンドポイントに送信して、ストリームのルールを追加および削除する。
3. 少量のデータを処理する – ストリーミング接続を維持し、Post オブジェクトとキープアライブ信号を検出する。
4. 大量のデータを処理する – 非同期プロセスを使用してストリームの取り込み処理を追加処理から切り離し、クライアント側バッファーが定期的にフラッシュされるようにする。
5. クライアント側で使用量のトラッキングを管理する。
6. ストリーム切断を検出し、状況を評価したうえでストリームに自動的に再接続する。
    

<div id="connecting-to-a-streaming-endpoint">
  #### ストリーミングエンドポイントへの接続
</div>

X API v2 のストリーミングエンドポイントへの接続を確立するということは、非常に長時間にわたって維持される HTTP リクエストを送り、レスポンスを逐次解析していくことを意味します。概念的には、HTTP 経由で無限に長いファイルをダウンロードしていると考えることができます。接続が一度確立されると、その接続が開いている限り、X サーバーはその接続を通じてポストイベントを配信し続けます。
 

<div id="consuming-data">
  #### データの取得
</div>

JSON オブジェクトの各フィールドには順序がなく、すべての状況で必ずしもすべてのフィールドが存在するわけではない点に注意してください。同様に、個々のアクティビティはソートされた順序で配信されるわけではなく、重複したメッセージが発生する可能性があります。時間の経過とともに、新しいメッセージタイプが追加され、ストリーム経由で送信される場合があることも念頭に置いてください。

したがって、クライアント実装では、次の点に対応できるようにしておく必要があります。

* 任意の順序で出現するフィールド
* 予期しないフィールドや欠落しているフィールド
* 順序が保証されないポスト
* 重複したメッセージ
* いつでもストリームに流れてくる新たな任意のメッセージタイプ

関連するポストのデータとリクエストしたフィールドパラメータに加えて、ストリーム接続上では次の種類のメッセージが配信される可能性があります。この一覧は網羅的なものではなく、ストリームに追加のオブジェクトが導入される可能性がある点に注意してください。パーサーが予期しないメッセージ形式にも対応できるようにしてください。
 

<div id="buffering">
  #### バッファリング
</div>

ストリーミングエンドポイントは、データが利用可能になり次第すばやく送信するため、多くの場合、非常に大量のデータになる可能性があります。X サーバーがすぐに新しいデータを書き込めない場合（たとえばクライアント側の読み取りが十分に速くない場合。詳細は「[切断の処理](/ja/x-api/posts/filtered-stream#what-is-a-disconnection)」を参照）、クライアントが追いつけるようにサーバー側でコンテンツをバッファリングします。ただし、このバッファがいっぱいになると、接続を切断するために強制切断が行われ、その時点までにバッファリングされていたポストは破棄され、再送されません。詳細は以下を参照してください。

アプリの処理が遅れ始めているタイミングを特定する 1 つの方法は、受信しているポストのタイムスタンプを現在時刻と比較し、その差分を時間経過とともに追跡することです。

パブリックインターネット上では潜在的なレイテンシーや一時的な問題が発生し得るため、ストリームのバックアップ（滞留）を完全になくすことはできませんが、アプリを適切に構成することで、その多くは防ぐことができます。バックアップの発生を最小限に抑えるには、次の点に注意してください。

* クライアントがストリームを十分な速度で読み取っていることを確認してください。通常、ストリームを読み取る際には、実際の処理作業を行うべきではありません。ストリームを読み取り、そのデータを別スレッド／別プロセス／別のデータストアへ渡し、処理は非同期に実行してください。
* データセンターに、大きな持続的データボリュームと、それを大きく上回るスパイク（例: 平常時の 5〜10 倍のボリューム）を受け入れられるだけの受信帯域幅があることを確認してください。filtered stream の場合、発生するボリュームと、それに対応してあなたの側で必要となる帯域幅は、ルールがマッチしているポストに完全に依存します。
   

<div id="usage-tracking-and-rule-management">
  #### 利用状況の追跡とルール管理
</div>

開発者が自分のストリームにとっての「通常」のデータボリュームを把握していることを前提としているため、特定のパーセンテージでどの程度増減すべきかや、その期間について一般的な推奨値は提示していません。 

ストリームのデータボリュームを監視し、想定外の変動がないか確認することを検討してください。データボリュームの減少は、ストリームの切断とは異なる問題の兆候である可能性があります。このような場合でも、ストリームは keep-alive シグナルや新しいアクティビティデータを引き続き受信しているはずです。しかし、ポスト数が大幅に減少した場合は、アプリケーションまたはネットワークへの受信データボリュームを減少させている要因がないか調査し、関連する通知がないか [status page](https://api.twitterstat.us/)（ステータスページ）を確認する必要があります。

このような監視を行うには、一定時間内に取得されると予想される新規ポスト数を追跡するとよいでしょう。ストリームのデータボリュームが指定したしきい値を大きく下回り、かつ一定期間内に回復しない場合は、アラートや通知を送信する必要があります。また、特に filtered stream のルールを変更している最中や、ポストアクティビティが急増するイベントが発生した場合には、データボリュームの大幅な増加についても監視することをお勧めします。

filtered stream を通じて配信されるポストは、月間ポスト総ボリュームに含まれる点に注意してください。最適化のため、利用状況を追跡し、消費量を調整する必要があります。ボリュームが高い場合は、必要に応じて各ルールに sample: 演算子を追加し、100% マッチから sample:50 や sample:25 に絞り込むことを検討してください。 

さらに、アプリ内に、ボリュームが事前に設定したしきい値を超えた場合にチームへ通知する仕組みを実装することを推奨します。加えて、過剰なデータを取り込んでいるルールの自動削除や、極端な状況ではストリームから完全に切断するといった他の対策を導入することも検討してください。
 

<div id="responding-to-system-messages">
  #### システムメッセージへの応答
</div>

キープアライブ信号
少なくとも 20 秒ごとに、ストリームは開いている接続を通じて \r\n キャリッジリターンの形式でキープアライブ信号（ハートビート）を送信し、クライアントのタイムアウトを防ぎます。クライアントアプリケーションは、ストリーム内の \r\n 文字を許容する必要があります。

クライアントで HTTP ライブラリに対して読み取りタイムアウトを正しく実装していれば、この期間内にデータが読み取られなかった場合に、HTTP プロトコルと HTTP ライブラリによってイベントが発生するため、\r\n 文字を明示的に監視する必要はありません。

このイベントは通常、例外がスローされる、または使用している HTTP ライブラリに応じて何らかの別のイベントとして発生します。これらのタイムアウトを検知するために、HTTP メソッドをエラー／イベントハンドラーでラップすることを強く推奨します。タイムアウト発生時には、アプリケーションは再接続を試みる必要があります。

エラーメッセージ
v2 ストリーミングエンドポイントは、ストリーム内でエラーメッセージを配信する場合があります。以下に、これらのメッセージの基本フォーマットといくつかの例を示します。配信されるメッセージは変更され、新しいメッセージが追加される可能性がある点に注意してください。クライアントアプリケーションは、変化するシステムメッセージのペイロードを許容する必要があります。

エラーメッセージには、問題の解決方法を説明しているドキュメントへのリンクが含まれることに注意してください。

メッセージ形式:

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "このストリームは運用上の理由により上流で切断されました。",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

バッファが一杯になったことによる強制切断を示すエラーメッセージは、その強制切断の原因となったバッファの滞留によってメッセージ自体が配送されず、クライアントに届かない場合があります。そのため、再接続のきっかけとしてこれらのメッセージに依存するようなアプリの設計は行わないでください。
