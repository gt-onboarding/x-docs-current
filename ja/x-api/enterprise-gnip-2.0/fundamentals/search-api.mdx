---
title: "検索 API: Enterprise"
sidebarTitle: Search API
keywords: ["enterprise search", "GNIP search", "enterprise search API", "search API enterprise", "enterprise search endpoints"]
---

> **ご注意ください：**
>
> [ポスト検索](/ja/x-api/posts/search/introduction) と [ポスト件数](/ja/x-api/posts/counts/introduction) の新しいバージョンを [X API v2](/ja/x-api/getting-started/about-x-api) でリリースしました。X API v2 での[新機能をご確認](/ja/x-api/migrate/overview)いただくことをおすすめします。
>
> これらのエンドポイントは、ポスト編集に関するメタデータを含むように更新されています。これらのメタデータの詳細は、「[ポストの編集」基礎ページ](/ja/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets)をご覧ください。 

<div id="overview">
  ## Overview
</div>

`Enterprise`

*Enterprise API は、当社が管理するアクセスレベル内でのみ利用可能です。これらの API を利用するには、まず当社の Enterprise 営業チームを通じてアカウントを開設する必要があります。詳しくは [こちら](https://developer.x.com/en/products/x-api/enterprise) をご覧ください。*

*X API の検索系ポスト関連のすべてのオファリングは [こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api) から確認できます。*

Enterprise 検索 API には 2 種類あります。

1. 30-Day Search API は、直近 30 日間のデータを提供します。
2. Full-Archive Search API は、2006 年 3 月の最初のポストまでさかのぼる、X データの全アーカイブに対する完全かつ即時のアクセスを提供します。

これらの RESTful API は、1 リクエストあたり最大 2,048 文字の単一クエリをサポートします。クエリは PowerTrack ルール構文で記述します。詳細は [ルールとフィルタリング](/ja/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#getting-started-with-enterprise-rules-and-queries) を参照してください。ユーザーは、1 分単位の精度で任意の時間範囲を指定できます。ただし、レスポンスは指定した maxResults の値、または 31 日間のいずれか小さい方に制限され、次の結果セットをページングするための next トークンが含まれます。時間パラメータが指定されていない場合、API は直近 30 日間の一致するデータを返します。

Enterprise 検索 API は、ポストアーカイブに対して、低レイテンシでロスのないクエリベースのアクセスを 1 分単位の粒度で提供します。ポストデータは、クエリに一致する最新のポストから始まり、新しいものから古いものへ時系列を逆順に返されます。ポストは、公開後おおよそ 30 秒で検索 API から利用可能になります。

これらの検索エンドポイントは、編集されたポストのメタデータを提供します。2022 年 9 月 29 日以降に作成されたすべてのポストのオブジェクトには、ポストが一度も編集されていない場合でも、ポスト編集メタデータが含まれます。ポストが編集されるたびに、新しい Post ID が作成されます。ポストの編集履歴は、元の ID から始まる Post ID の配列として記録されます。

これらのエンドポイントは常に、最新の編集内容と、存在する場合は編集履歴の両方を返します。30 分間の編集可能時間を過ぎて収集されたポストは、最終版を表します。Edit Post メタデータの詳細については、[Edit Posts の基本](/ja/x-api/fundamentals/edit-posts) ページを参照してください。

リクエストには、各 API レスポンスで返すポストの最大数を指定する maxResults パラメータが含まれます。クエリに関連するポストが、1 レスポンスあたりのこの最大件数を超える場合、レスポンスには next トークンが含まれます。これらの next トークンは、同じクエリに関連するポストの全セットをページングする後続リクエストで使用されます。

これらの Enterprise 検索 API には、クエリに関連付けられたデータボリュームをリクエストできる *counts* エンドポイントが用意されています。 

<div id="request-types">
  ### リクエストの種類
</div>

Enterprise 検索 API では、2 種類のリクエストをサポートしています。

<div id="search-requests-data">
  #### Search requests (data)
</div>

Enterprise search API に対して検索リクエストを送信すると、指定した期間について、1 回のレスポンスあたり最大 500 件の結果を取得でき、ページネーションによって追加のデータも取得できます。`maxResults` パラメータを使用して、表示用途に合わせて小さいページサイズを指定したり（ユーザーが必要に応じてさらに結果を要求できるようにする）、大規模なデータ取得のために大きいページサイズ（最大 500）を指定したりできます。データは逆時系列で返され、返却時点でコンプライアンス要件に準拠した状態になっています。

<div id="counts-requests-post-count">
  #### カウントリクエスト（ポスト件数）
</div>

カウントリクエストを使用すると、指定した期間内に、特定のクエリに一致して発生したアクティビティの過去の件数を取得できます。レスポンスでは、日、時間、または分ごと（デフォルトのバケットは *hour*）に区切られた件数のヒストグラムが返されます。カウント結果は、ポストが公開されてからかなり後（7日以上）に発生するコンプライアンスイベント（例: ポストの削除）を必ずしも反映しない点に注意してください。そのため、同じクエリについて、カウントのメトリクスがデータリクエストの結果と常に一致するとは限りません。

**課金に関する注意:** データエンドポイントとカウントエンドポイントに対して行われる各リクエスト（*ページネーション用のリクエストも含みます*）は、課金対象のリクエストとして計上されます。したがって、単一のクエリに対して複数ページの結果がある場合、結果の X ページを順に取得すると、課金上は X 件のリクエストに相当します。

<div id="available-operators">
  ### 使用可能なオペレーター
</div>

Enterprise search API では、ルールは最大 2,048 文字までサポートされています。Enterprise search API がサポートしているオペレーターは以下のとおりです。詳細な説明は[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)を参照してください。 

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| **ポスト内容にマッチさせる:** | **対象アカウントにマッチさせる:** | **ポスト属性:** | **地理空間オペレーター:** |
| * keyword<br />* “quoted phrase”<br />* “keyword1 keyword2”~N<br />* #<br />* @<br />* $<br />* url:<br />* lang: | * from:<br />* to:<br />* retweets&#95;of: | * is:retweet  <br />    <br />* has:mentions<br />* has:hashtags<br />* has:media<br />* has:videos<br />* has:images<br />* has:links<br />* has:symbols<br />* is:verified  <br />    <br />* -is:nullcast (否定専用オペレーター) | * bounding&#95;box:[west&#95;long south&#95;lat east&#95;long north&#95;lat]<br />* point&#95;radius:[lon lat radius]<br />* has:geo<br />* place:<br />* place&#95;country:<br />* has:profile&#95;geo<br />* profile&#95;country:<br />* profile&#95;region:<br />* profile&#95;locality: |

注記: オペレーターを入れ子にしないでください（&quot;#cats&quot; は search API では cats として解釈されます）。  「lang:」オペレーターおよびすべての「is:」「has:」オペレーターは単独では使用できず、必ず別の句と組み合わせる必要があります（例: @XDevelopers has:links）。    

Search API 群では、トークン化とマッチング機能の制約により、使用できるオペレーターは限定されています。Enterprise のリアルタイム API とバッチ履歴 API では、さらに多くのオペレーターが提供されています。詳細は[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#operators-by-product)を参照してください。

さらに詳しい情報については、[オペレーターの使用を開始する](/ja/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#building-rules-and-queries)ガイドを参照してください。

<div id="data-availability-important-date">
  ### データの可用性 / 重要な日付
</div>

Full-Archive Search API を使用する際は、X プラットフォームは 2006 年以降も進化し続けていることに留意してください。新機能が追加されるたびに、その基盤となる JSON オブジェクトには新しいメタデータが追加されてきました。そのため、検索オペレーターが照合対象とするポスト属性がいつ追加されたのかを理解しておくことが重要です。以下は、重要なメタデータ群についての、代表的な「誕生日」にあたる日付です。ポスト属性が最初に導入されたタイミングについて詳しくは、[このガイド](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#full-archive-search-metadata-timeline)を参照してください。  

* 最初のポスト: 3/21/2006
* 最初のネイティブリツイート: 11/6/2009
* 最初のジオタグ付きポスト: 11/19/2009
* URL が初めてフィルタリング用にインデックスされた日: 8/27/2011
* 拡張 URL 展開メタデータ（ウェブサイトのタイトルと説明）: 12/1/2014
* Profile Geo 拡張メタデータおよびフィルタリング: 2/17/2015

<div id="data-updates-and-mutability">
  ### データの更新と可変性
</div>

Enterprise 検索 API では、ポスト内の一部のデータは可変であり、初回のアーカイブ後に更新または変更される可能性があります。

この可変データは、次の 2 つのカテゴリに分類されます。

* User オブジェクトのメタデータ:
  * ユーザーの @handle（数値の id は決して変わりません）
  * 自己紹介文（Bio）
  * 件数: statuses、followers、friends、favorites、lists
  * プロフィールの場所
  * タイムゾーンと言語など、その他の詳細
* ポストの統計情報 - つまり、ユーザーのアクションによってプラットフォーム上で変更可能なもの（以下は例）:
  * Favorites 件数
  * Retweet 件数

これらのほとんどのケースでは、検索 API はポスト生成時ではなく、*クエリ時点* にプラットフォーム上に存在するデータを返します。ただし、select 演算子（例: from, to, @, is:verified）を使用するクエリの場合は、この限りではない可能性があります。データはインデックス内で定期的に更新されており、直近の期間については更新頻度が高くなっています。その結果、返されるデータが X.com 上に現在表示されているデータと完全には一致しない場合がありますが、最後にインデックス化された時点のデータとは一致します。

なお、この不一致の問題は、演算子が可変データに適用されるクエリにのみ当てはまります。たとえばユーザー名によるフィルタリングが該当し、この場合の最良の回避策は、これらのクエリで @handle ではなくユーザーの数値 ID を使用することです。

<div id="single-vs-multi-threaded-requests">
  ### シングルスレッド vs. マルチスレッドでのリクエスト
</div>

各顧客には、検索エンドポイントに対して定義されたレート制限があります。フルアーカイブ検索のデフォルトのレート制限は 1 分あたり 120 リクエストであり、平均すると 1 秒あたり 2 クエリ（QPS）です。この平均 QPS は、理論上は毎秒 2 件のリクエストを API に対して行えることを意味します。本製品のページネーション機能を考えると、1 年分のクエリに 100 万件のポストが関連付けられていて、それが 1 年を通して均等に分布している場合、すべてのデータを受信するには 2,000 回超のリクエストが必要になります（`maxResults` が 500 であると仮定）。1 応答あたり 2 秒かかると仮定すると、前の応答の &quot;next&quot; トークンを使って 1 秒あたり 1 リクエストという単一スレッドで直列／逐次的にすべてのデータを取得するには、4,000 秒（約 1 時間強）かかります。悪くありません。

次に、12 本の並列スレッドを使用してデータを受信する状況を考えてみます。100 万件のポストが 1 年間にわたって均等に分布していると仮定すると、リクエストを 12 本の並列スレッド（マルチスレッド）に分割し、単一の「ジョブ」に対する 1 秒あたりのレート制限をより有効に活用できます。言い換えると、関心のある各月ごとに 1 本のスレッドを実行することができ、その結果、データを 12 倍の速さ（約 6 分）で取得できます。

このマルチスレッドの例は、Counts エンドポイントにも同様に適用できます。たとえば、2 年間の期間に対するポスト件数を取得したい場合、シングルスレッドのリクエストを行い、31 日単位で件数をページングしながらさかのぼることができます。1 応答あたり 2 秒かかると仮定すると、24 回の API リクエストを行い、件数の全セットを取得するのに約 48 秒かかります。しかし、同時に複数の 1 か月分のリクエストを行うことも可能です。1 秒あたり 12 リクエストを行う場合、件数の全セットは約 2 秒で取得できます。

<div id="retry-logic">
  ### リトライロジック
</div>

Enterprise 検索 API で 503 エラーが発生した場合、多くは一時的なエラーであり、短時間待ってからリクエストを再試行することで解決できます。

リクエストが連続して 4 回失敗し、かつ各失敗の間で少なくとも 10 分待っている場合は、次の手順でトラブルシューティングを行ってください。

* 対象としている時間範囲を短くしてからリクエストを再試行します。うまくいかない場合は、最小で 6 時間の時間ウィンドウになるまで、範囲をさらに狭めて繰り返します。
* 多数のキーワードを OR で組み合わせている場合は、それらを別々のルールに分割し、それぞれを個別に再試行します。
* ルール内で多数の除外条件を使用している場合は、ルール内の否定項目の数を減らし、再試行します。

<div id="quick-start">
  ## クイックスタート
</div>

<div id="getting-started-with-enterprise-search-posts-30-day-api">
  ### Enterprise Search Posts: 30-Day API の利用を開始する
</div>

Enterprise Search Posts: 30-Day API を使用すると、過去 30 日間に投稿されたポストを取得できます。ポストは、リクエストで指定したクエリに基づいてマッチしたものが返されます。クエリとは、取得するポストにどのような内容を含めるかを定義するためのルールです。このチュートリアルでは、X アカウント @XDevelopers から英語で投稿されたポストを検索します。

レスポンスで返されるポストは、ポストの完全なペイロードを取得できる data 形式、またはマッチしたポストの数値的な件数データを取得できる counts 形式のいずれかになります。このチュートリアルでは、cURL を使用して data エンドポイントと counts エンドポイントにリクエストを送信します。

以下が必要になります。

* [Enterprise アカウント]https://developer.x.com/en/products/x-api/enterprise
* ユーザー名、パスワード、アカウント名
* console.gnip.com に表示されている検索エンドポイントに関連付けられたラベル

<div id="accessing-the-data-endpoint">
  #### データエンドポイントへのアクセス
</div>

データエンドポイントは、一致したポストの完全なペイロードを返します。`from:` と `lang:` 演算子を使用して、英語で @XDevelopers から投稿されたポストを取得します。 *他の演算子については [こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)を参照してください。*

<Tabs>
  <Tab title="cURL">
    *cURL は、URL 構文を使用してファイルを取得または送信するためのコマンドラインツールです。*

    次の項目を変更したうえで、以下の cURL リクエストをコマンドラインにコピーしてください。

    * **Username** `<USERNAME>` 例: `email@domain.com`

    * **Account name** `<ACCOUNT-NAME>` 例: `john-doe`

    * **Label** `<LABEL>` 例: `prod`

    * **fromDate と toDate** 例: `"fromDate":"201811010000", "toDate":"201811122359"`

    *リクエストを送信すると、パスワードの入力を求められます。*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/30day/accounts/<ACCOUNT-NAME>/<LABEL>.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>"}'
    ```
  </Tab>

  <Tab title="cURL の例">
    ```bash
    _これは cURL リクエストの例です。実行しても動作しません。_

    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/30day/accounts/john-doe/prod.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"201811100000","toDate":"201812012359"}'
    ```
  </Tab>
</Tabs>

#### データエンドポイントのレスポンスペイロード

API リクエストに対するレスポンスのペイロードは、以下のとおり JSON 形式になります。

```json
{
	"results": [
		{
			"created_at": "Fri Nov 02 17:18:31 +0000 2018",
			"id": 1058408022936977409,
			"id_str": "1058408022936977409",
			"text": "RT @harmophone: \"The innovative crowdsourcing that the Tagboard, Twitter and TEGNA collaboration enables is surfacing locally relevant conv…",
			"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter Web Client<\/a>",
			"truncated": false,
			"in_reply_to_status_id": null,
			"in_reply_to_status_id_str": null,
			"in_reply_to_user_id": null,
			"in_reply_to_user_id_str": null,
			"in_reply_to_screen_name": null,
			"user": {
				"id": 2244994945,
				"id_str": "2244994945",
				"name": "Twitter Dev",
				"screen_name": "TwitterDev",
				"location": "Internet",
				"url": "https:\/\/developer.x.com\/",
				"description": "Your official source for Twitter Platform news, updates & events. Need technical help? Visit https:\/\/devcommunity.com\/ ⌨️ #TapIntoTwitter",
				"translator_type": "null",
				"protected": false,
				"verified": true,
				"followers_count": 503828,
				"friends_count": 1477,
				"listed_count": 1437,
				"favourites_count": 2199,
				"statuses_count": 3380,
				"created_at": "Sat Dec 14 04:35:55 +0000 2013",
				"utc_offset": null,
				"time_zone": null,
				"geo_enabled": true,
				"lang": "en",
				"contributors_enabled": false,
				"is_translator": false,
				"profile_background_color": "null",
				"profile_background_image_url": "null",
				"profile_background_image_url_https": "null",
				"profile_background_tile": null,
				"profile_link_color": "null",
				"profile_sidebar_border_color": "null",
				"profile_sidebar_fill_color": "null",
				"profile_text_color": "null",
				"profile_use_background_image": null,
				"profile_image_url": "null",
				"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/880136122604507136\/xHrnqf1T_normal.jpg",
				"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/2244994945\/1498675817",
				"default_profile": false,
				"default_profile_image": false,
				"following": null,
				"follow_request_sent": null,
				"notifications": null
			},
			"geo": null,
			"coordinates": null,
			"place": null,
			"contributors": null,
			"retweeted_status": {
				"created_at": "Tue Oct 30 21:30:25 +0000 2018",
				"id": 1057384253116289025,
				"id_str": "1057384253116289025",
				"text": "\"The innovative crowdsourcing that the Tagboard, Twitter and TEGNA collaboration enables is surfacing locally relev… https:\/\/t.co\/w46U5TRTzQ",
				"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter Web Client<\/a>",
				"truncated": true,
				"in_reply_to_status_id": null,
				"in_reply_to_status_id_str": null,
				"in_reply_to_user_id": null,
				"in_reply_to_user_id_str": null,
				"in_reply_to_screen_name": null,
				"user": {
					"id": 175187944,
					"id_str": "175187944",
					"name": "Tyler Singletary",
					"screen_name": "harmophone",
					"location": "San Francisco, CA",
					"url": "http:\/\/medium.com\/@harmophone",
					"description": "SVP Product at @Tagboard. Did some Data, biz, and product @Klout & for @LithiumTech; @BBI board member; @Insightpool advisor. World's worst whiteboarder.",
					"translator_type": "null",
					"protected": false,
					"verified": false,
					"followers_count": 1982,
					"friends_count": 1877,
					"listed_count": 245,
					"favourites_count": 23743,
					"statuses_count": 12708,
					"created_at": "Thu Aug 05 22:59:29 +0000 2010",
					"utc_offset": null,
					"time_zone": null,
					"geo_enabled": false,
					"lang": "en",
					"contributors_enabled": false,
					"is_translator": false,
					"profile_background_color": "null",
					"profile_background_image_url": "null",
					"profile_background_image_url_https": "null",
					"profile_background_tile": null,
					"profile_link_color": "null",
					"profile_sidebar_border_color": "null",
					"profile_sidebar_fill_color": "null",
					"profile_text_color": "null",
					"profile_use_background_image": null,
					"profile_image_url": "null",
					"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/719985428632240128\/WYFHcK-m_normal.jpg",
					"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/175187944\/1398653841",
					"default_profile": false,
					"default_profile_image": false,
					"following": null,
					"follow_request_sent": null,
					"notifications": null
				},
				"geo": null,
				"coordinates": null,
				"place": null,
				"contributors": null,
				"is_quote_status": false,
				"extended_tweet": {
					"full_text": "\"Tagboard、Twitter、TEGNA の連携によって可能になる革新的なクラウドソーシングは、地域に関連性の高い会話をリアルタイムで可視化し、討論会の最中に有権者が質問できるようにしています\"  -- @adamostrow, @TEGNA\n詳しくは: https:\/\/t.co\/ivAFtanfje",
					"display_text_range": [
						0,
						259
					],
					"entities": {
						"hashtags": [],
						"urls": [
							{
								"url": "https:\/\/t.co\/ivAFtanfje",
								"expanded_url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
								"display_url": "blog.tagboard.com\/twitter-and-ta…",
								"unwound": {
									"url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
									"status": 200,
									"title": "Twitter and Tagboard Collaborate to Bring Best Election Content to News Outlets With Tagboard…",
									"description": "By Tyler Singletary, Head of Product, Tagboard"
								},
								"indices": [
									236,
									259
								]
							}
						],
						"user_mentions": [
							{
								"screen_name": "adamostrow",
								"name": "Adam Ostrow",
								"id": 5695942,
								"id_str": "5695942",
								"indices": [
									204,
									215
								]
							},
							{
								"screen_name": "TEGNA",
								"name": "TEGNA",
								"id": 34123003,
								"id_str": "34123003",
								"indices": [
									217,
									223
								]
							}
						],
						"symbols": []
					}
				},
				"quote_count": 0,
				"reply_count": 1,
				"retweet_count": 6,
				"favorite_count": 19,
				"entities": {
					"hashtags": [],
					"urls": [
						{
							"url": "https:\/\/t.co\/w46U5TRTzQ",
							"expanded_url": "https:\/\/twitter.com\/i\/web\/status\/1057384253116289025",
							"display_url": "twitter.com\/i\/web\/status\/1…",
							"indices": [
								117,
								140
							]
						}
					],
					"user_mentions": [],
					"symbols": []
				},
				"favorited": false,
				"retweeted": false,
				"possibly_sensitive": false,
				"filter_level": "low",
				"lang": "en"
			},
			"is_quote_status": false,
			"quote_count": 0,
			"reply_count": 0,
			"retweet_count": 0,
			"favorite_count": 0,
			"entities": {
				"hashtags": [],
				"urls": [],
				"user_mentions": [
					{
						"screen_name": "harmophone",
						"name": "Tyler Singletary",
						"id": 175187944,
						"id_str": "175187944",
						"indices": [
							3,
							14
						]
					}
				],
				"symbols": []
			},
			"favorited": false,
			"retweeted": false,
			"filter_level": "low",
			"lang": "en",
			"matching_rules": [
				{
					"tag": null
				}
			]
		}
	],
	"requestParameters": {
		"maxResults": 100,
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

<div id="accessing-the-counts-endpoint">
  #### counts エンドポイントへのアクセス
</div>

counts エンドポイントを使用して、@XDevelopers アカウントから英語で投稿されたポストの件数を、`day` ごとに集計して取得します。

<Tabs>
  <Tab title="cURL">
    *cURL は、URL 構文を使用してファイルを取得または送信するためのコマンドラインツールです。*

    次の cURL リクエストを、以下の項目を変更したうえでコマンドラインにコピーしてください。

    * **Username** `<USERNAME>` 例: `email@domain.com`

    * **Account name** `<ACCOUNT-NAME>` 例: `john-doe`

    * **Label** `<LABEL>` 例: `prod`

    * **fromDate と toDate** 例: `"fromDate":"201811010000", "toDate":"201811122359"`

    *リクエストを送信すると、パスワードの入力を求められます。*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/30day/accounts/<ACCOUNT-NAME>/<LABEL>/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>","bucket":"day"}'
    ```
  </Tab>

  <Tab title="cURL example">
    *これは cURL リクエストの例です。そのまま実行しても動作しません。*

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/30day/accounts/john-doe/prod/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"201811100000","toDate":"201812012359","bucket":"day"}'
    ```
  </Tab>
</Tabs>

<div id="counts-endpoint-response-payload">
  #### Counts エンドポイントのレスポンスペイロード
</div>

API リクエストに対するレスポンスは、以下のような JSON 形式のペイロードになります。

```json
{
	"results": [
		{
			"timePeriod": "201811010000",
			"count": 0
		},
		{
			"timePeriod": "201811020000",
			"count": 1
		},
		{
			"timePeriod": "201811030000",
			"count": 0
		},
		{
			"timePeriod": "201811040000",
			"count": 0
		},
		{
			"timePeriod": "201811050000",
			"count": 0
		}
	],
	"totalCount": 1,
	"requestParameters": {
		"bucket": "day",
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

素晴らしいですね！これで Enterprise Search Posts: 30-Day API へ正常にアクセスできました。

<div id="referenced-articles">
  ##### **関連ドキュメント**
</div>

* [Post オブジェクトの概要](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary)
* [検索オペレーター](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)
* [Post オブジェクトとペイロード](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#post-object)

<div id="getting-started-with-enterprise-search-posts-full-archive-api">
  ### enterprise Search Posts: Full-Archive API の利用を開始する
</div>

enterprise Search Posts: Full-Archive API を使用すると、2006 年に最初のポストが投稿されて以降のすべてのポストを取得できます。ポストは、リクエストで指定したクエリに基づいてマッチングされ、返されます。クエリとは、取得するポストにどのような内容が含まれているべきかを定義するルールです。このチュートリアルでは、X アカウント @XDevelopers から英語で投稿されたポストを検索します。

レスポンスのペイロードで返されるポストは、ポストの完全なペイロードを含む `data` 形式か、マッチしたポストの数値的な件数データのみを返す `counts` 形式のいずれかになります。ここでは、cURL を使って `data` エンドポイントおよび `counts` エンドポイントへのリクエストを行います。

以下が必要になります。

* [Enterprise アカウント](https://developer.x.com/en/products/x-api/enterprise)
* ユーザー名、パスワード、アカウント名
* console.gnip.com に表示されている、検索エンドポイントに関連付けられたラベル

<div id="accessing-the-data-endpoint">
  #### データエンドポイントへのアクセス
</div>

データエンドポイントでは、一致したポストのフルペイロードを取得できます。ここでは `from:` と `lang:` 演算子を使用して、@XDevelopers から英語で投稿されたポストを検索します。 *他の演算子については[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)を参照してください。*

* [cURL](#tab1)
* [cURL example](#tab2)

<Tabs>
  <Tab title="cURL">
    *cURL は、URL 構文を使用してファイルを取得または送信するためのコマンドラインツールです。*

    次の項目を変更したうえで、以下の cURL リクエストをコマンドラインにコピーしてください。

    * **Username** `<USERNAME>` 例: `email@domain.com`

    * **Account name** `<ACCOUNT-NAME>` 例: `john-doe`

    * **Label** `<LABEL>` 例: `prod`

    * **fromDate と toDate** 例: `"fromDate":"201802010000", "toDate":"201802282359"`

    *リクエスト送信後、パスワードの入力を求められます。*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/fullarchive/accounts/<ACCOUNT-NAME>/<LABEL>.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>"}'
    ```
  </Tab>

  <Tab title="cURL example">
    *これは cURL リクエストのサンプルです。そのまま実行しても動作しません。*

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/fullarchive/accounts/john-doe/prod.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"201802010000","toDate":"201802282359"}'
    ```
  </Tab>
</Tabs>

<div id="data-endpoint-response-payload">
  ##### データエンドポイントのレスポンスペイロード
</div>

API リクエストに対するレスポンスは、以下のような JSON 形式のペイロードとして返されます。

```json
{
	"results": [
		{
			"created_at": "Fri Nov 02 17:18:31 +0000 2018",
			"id": 1058408022936977409,
			"id_str": "1058408022936977409",
			"text": "RT @harmophone: \"The innovative crowdsourcing that the Tagboard, Twitter and TEGNA collaboration enables is surfacing locally relevant conv…",
			"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter Web Client<\/a>",
			"truncated": false,
			"in_reply_to_status_id": null,
			"in_reply_to_status_id_str": null,
			"in_reply_to_user_id": null,
			"in_reply_to_user_id_str": null,
			"in_reply_to_screen_name": null,
			"user": {
				"id": 2244994945,
				"id_str": "2244994945",
				"name": "Twitter Dev",
				"screen_name": "TwitterDev",
				"location": "Internet",
				"url": "https:\/\/developer.x.com\/",
				"description": "Your official source for Twitter Platform news, updates & events. Need technical help? Visit https:\/\/devcommunity.com\/ ⌨️ #TapIntoTwitter",
				"translator_type": "null",
				"protected": false,
				"verified": true,
				"followers_count": 503828,
				"friends_count": 1477,
				"listed_count": 1437,
				"favourites_count": 2199,
				"statuses_count": 3380,
				"created_at": "Sat Dec 14 04:35:55 +0000 2013",
				"utc_offset": null,
				"time_zone": null,
				"geo_enabled": true,
				"lang": "en",
				"contributors_enabled": false,
				"is_translator": false,
				"profile_background_color": "null",
				"profile_background_image_url": "null",
				"profile_background_image_url_https": "null",
				"profile_background_tile": null,
				"profile_link_color": "null",
				"profile_sidebar_border_color": "null",
				"profile_sidebar_fill_color": "null",
				"profile_text_color": "null",
				"profile_use_background_image": null,
				"profile_image_url": "null",
				"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/880136122604507136\/xHrnqf1T_normal.jpg",
				"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/2244994945\/1498675817",
				"default_profile": false,
				"default_profile_image": false,
				"following": null,
				"follow_request_sent": null,
				"notifications": null
			},
			"geo": null,
			"coordinates": null,
			"place": null,
			"contributors": null,
			"retweeted_status": {
				"created_at": "Tue Oct 30 21:30:25 +0000 2018",
				"id": 1057384253116289025,
				"id_str": "1057384253116289025",
				"text": "\"The innovative crowdsourcing that the Tagboard, Twitter and TEGNA collaboration enables is surfacing locally relev… https:\/\/t.co\/w46U5TRTzQ",
				"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter Web Client<\/a>",
				"truncated": true,
				"in_reply_to_status_id": null,
				"in_reply_to_status_id_str": null,
				"in_reply_to_user_id": null,
				"in_reply_to_user_id_str": null,
				"in_reply_to_screen_name": null,
				"user": {
					"id": 175187944,
					"id_str": "175187944",
					"name": "Tyler Singletary",
					"screen_name": "harmophone",
					"location": "San Francisco, CA",
					"url": "http:\/\/medium.com\/@harmophone",
					"description": "SVP Product at @Tagboard. Did some Data, biz, and product @Klout & for @LithiumTech; @BBI board member; @Insightpool advisor. World's worst whiteboarder.",
					"translator_type": "null",
					"protected": false,
					"verified": false,
					"followers_count": 1982,
					"friends_count": 1877,
					"listed_count": 245,
					"favourites_count": 23743,
					"statuses_count": 12708,
					"created_at": "Thu Aug 05 22:59:29 +0000 2010",
					"utc_offset": null,
					"time_zone": null,
					"geo_enabled": false,
					"lang": "en",
					"contributors_enabled": false,
					"is_translator": false,
					"profile_background_color": "null",
					"profile_background_image_url": "null",
					"profile_background_image_url_https": "null",
					"profile_background_tile": null,
					"profile_link_color": "null",
					"profile_sidebar_border_color": "null",
					"profile_sidebar_fill_color": "null",
					"profile_text_color": "null",
					"profile_use_background_image": null,
					"profile_image_url": "null",
					"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/719985428632240128\/WYFHcK-m_normal.jpg",
					"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/175187944\/1398653841",
					"default_profile": false,
					"default_profile_image": false,
					"following": null,
					"follow_request_sent": null,
					"notifications": null
				},
				"geo": null,
				"coordinates": null,
				"place": null,
				"contributors": null,
				"is_quote_status": false,
				"extended_tweet": {
					"full_text": "\"The innovative crowdsourcing that the Tagboard, Twitter and TEGNA collaboration enables is surfacing locally relevant conversations in real-time and enabling voters to ask questions during debates,”  -- @adamostrow, @TEGNA\nLearn More: https:\/\/t.co\/ivAFtanfje",
					"display_text_range": [
						0,
						259
					],
					"entities": {
						"hashtags": [],
						"urls": [
							{
								"url": "https:\/\/t.co\/ivAFtanfje",
								"expanded_url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
								"display_url": "blog.tagboard.com\/twitter-and-ta…",
								"unwound": {
									"url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
									"status": 200,
									"title": "Twitter and Tagboard Collaborate to Bring Best Election Content to News Outlets With Tagboard…",
									"description": "By Tyler Singletary, Head of Product, Tagboard"
								},
								"indices": [
									236,
									259
								]
							}
						],
						"user_mentions": [
							{
								"screen_name": "adamostrow",
								"name": "Adam Ostrow",
								"id": 5695942,
								"id_str": "5695942",
								"indices": [
									204,
									215
								]
							},
							{
								"screen_name": "TEGNA",
								"name": "TEGNA",
								"id": 34123003,
								"id_str": "34123003",
								"indices": [
									217,
									223
								]
							}
						],
						"symbols": []
					}
				},
				"quote_count": 0,
				"reply_count": 1,
				"retweet_count": 6,
				"favorite_count": 19,
				"entities": {
					"hashtags": [],
					"urls": [
						{
							"url": "https:\/\/t.co\/w46U5TRTzQ",
							"expanded_url": "https:\/\/twitter.com\/i\/web\/status\/1057384253116289025",
							"display_url": "twitter.com\/i\/web\/status\/1…",
							"indices": [
								117,
								140
							]
						}
					],
					"user_mentions": [],
					"symbols": []
				},
				"favorited": false,
				"retweeted": false,
				"possibly_sensitive": false,
				"filter_level": "low",
				"lang": "en"
			},
			"is_quote_status": false,
			"quote_count": 0,
			"reply_count": 0,
			"retweet_count": 0,
			"favorite_count": 0,
			"entities": {
				"hashtags": [],
				"urls": [],
				"user_mentions": [
					{
						"screen_name": "harmophone",
						"name": "Tyler Singletary",
						"id": 175187944,
						"id_str": "175187944",
						"indices": [
							3,
							14
						]
					}
				],
				"symbols": []
			},
			"favorited": false,
			"retweeted": false,
			"filter_level": "low",
			"lang": "en",
			"matching_rules": [
				{
					"tag": null
				}
			]
		}
	],
	"requestParameters": {
		"maxResults": 100,
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

<div id="accessing-the-counts-endpoint">
  #### counts エンドポイントへのアクセス
</div>

counts エンドポイントを使用して、@XDevelopers アカウントから英語で投稿されたポスト数を、`day` ごとに集計して取得します。

<Tabs>
  <Tab title="cURL">
    *cURL は、URL 構文を使ってファイルを取得または送信するためのコマンドラインツールです。*

    次の項目を変更したうえで、以下の cURL リクエストをコマンドラインにコピーしてください。

    * **Username** `<USERNAME>`（例: `email@domain.com`）

    * **Account name** `<ACCOUNT-NAME>`（例: `john-doe`）

    * **Label** `<LABEL>`（例: `prod`）

    * **fromDate と toDate**（例: `"fromDate":"201802010000", "toDate":"201802282359"`）

    *リクエストを送信すると、パスワードの入力が求められます。*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/fullarchive/accounts/<ACCOUNT-NAME>/<LABEL>/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>","bucket":"day"}'
    ```
  </Tab>

  <Tab title="cURL の例">
    ```bash
    _これは cURL リクエストの例です。実行しても動作しません。_

    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/fullarchive/accounts/john-doe/prod/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"201802010000","toDate":"201802282359","bucket":"day"}'
    ```
  </Tab>
</Tabs>

<div id="counts-endpoint-response-payload">
  #### Counts エンドポイントのレスポンスペイロード
</div>

API リクエストで返されるペイロードは、以下の例のような JSON 形式になります。

```json
{
	"results": [
		{
			"timePeriod": "201811010000",
			"count": 0
		},
		{
			"timePeriod": "201811020000",
			"count": 1
		},
		{
			"timePeriod": "201811030000",
			"count": 0
		},
		{
			"timePeriod": "201811040000",
			"count": 0
		},
		{
			"timePeriod": "201811050000",
			"count": 0
		}
	],
	"totalCount": 1,
	"requestParameters": {
		"bucket": "day",
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

よくできました。これで Enterprise Search Posts: Full-Archive API へ正常にアクセスできました。

##### 参考記事

* [ポストオブジェクト入門](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary)
* [検索演算子](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)
* [ポストオブジェクトとペイロード](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#post-object)

<div id="guides">
  ## ガイド
</div>

<div id="building-search-queries">
  ### 検索クエリの作成
</div>

<div id="enterprise-operators">
  ### Enterprise オペレーター
</div>

以下は、X の Enterprise 検索 API でサポートされているすべてのオペレーターの一覧です。

* **Enterprise** 30 日間検索 API
* **Enterprise** 全アーカイブ検索 API

プロダクトごとの利用可能なオペレーターを一覧で比較するには、[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#operators-by-product)を参照してください。

| オペレーター                          | 説明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| :------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| keyword                         | ポストの本文または URL 内のトークン化されたキーワードに一致します。これはトークンベースのマッチであり、キーワード文字列はポスト本文のトークン化されたテキストと照合されます。トークン化は、句読点、記号、およびセパレーターの Unicode 基本多言語面（BMP）文字に基づいて行われます。たとえば、本文が “I like coca-cola” のポストは、次のトークンに分割されます: I, like, coca, cola。これらのトークンが、ルールで使用したキーワード文字列と比較されます。句読点（たとえば coca-cola）、記号、またはセパレーター文字を含む文字列にマッチさせるには、以下で説明する引用符で囲んだ完全一致（quoted exact match）を使用する必要があります。<br /><br />**Note:** Search API では、アクセント付き文字や特殊文字は標準的なラテン文字に正規化されます。その結果、外国語では意味が変わったり、想定外の結果が返されたりする可能性があります。<br />たとえば、&quot;músic&quot; は “music” にマッチし、その逆も同様です。<br />また、スペイン語の一般的なフレーズである &quot;Feliz Año Nuevo!&quot; は、インデックス作成時には &quot;Feliz Ano Nuevo&quot; として処理され、フレーズの意味が変わってしまいます。<br /><br />**Note:** このオペレーターは、ポスト内の URL と展開された URL（unwound URL）の両方にマッチします。 |
| emoji                           | ポスト本文内の絵文字にマッチします。絵文字でのマッチはトークン単位で行われ、指定した絵文字はトークン化されたポスト本文テキストと照合されます。トークン化は、句読点、記号/絵文字、および区切り記号となる Unicode 基本多言語面の文字に基づいて行われます。たとえば、「I like <Icon icon="pizza-slice" iconType="solid" />」というテキストのポストは、次のトークンに分割されます: I, like, <Icon icon="pizza-slice" iconType="solid" />。これらのトークンが、ルールで使用した絵文字と比較されます。絵文字にバリアントがある場合は、その絵文字をルールに追加する際に引用符（&quot;…&quot;）で囲む必要がある点に注意してください。                                                                                                                                                                                                                                                                                                                                                             |
| &quot;exact phrase match&quot;  | ポストの本文または URL 内で、トークン化され、順序どおりに並んだフレーズに一致します。これはトークン化によるマッチであり、キーワード文字列がポスト本文のトークン化されたテキストと照合されることを意味します。トークン化は、句読点、記号、および区切りの Unicode 基本多言語面文字に基づいて行われます。 <br /><br />**注記:** 句読点はトークン化されず、空白として扱われます。<br />例えば、引用符付きの “#hashtag” は “hashtag” には一致しますが、#hashtag には一致しません (実際のハッシュタグに一致させるには、引用符なしの hashtag # 演算子を使用します。<br />例えば、引用符付きの “$cashtag” は “cashtag” には一致しますが、$cashtag には一致しません (実際のキャッシュタグに一致させるには、引用符なしの cashtag $ 演算子を使用します。<br />例えば、&quot;Love Snow&quot; は &quot;#love #snow&quot; に一致します。<br />例えば、&quot;#Love #Snow&quot; は &quot;love snow&quot; に一致します。<br /><br />**注記:** この演算子は、ポスト内の URL と展開済み URL の両方に対してマッチします。                                                                                                   |
| &quot;keyword1 keyword2&quot;~N | 一般的に「近接演算子」と呼ばれ、この演算子はキーワード同士の距離が互いに N トークン以内であるポストにマッチします。<br /><br />キーワードの順序が逆の場合、キーワード同士の距離は N-2 トークンを超えてはなりません。引用符内には任意の数のキーワードを含めることができます。N は 6 を超えることはできません。<br /><br />この演算子は `enterprise` 検索 API でのみ利用可能であることに注意してください。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| from:                           | 特定のユーザーによるポストすべてにマッチします。<br />値は、そのユーザーの X の数値アカウント ID、またはユーザー名（@ を除く）である必要があります。数値の X アカウント ID を取得する方法については、[こちら](/ja/x-api/users/lookup/introduction) または [こちら](http://gettwitterid.com/) を参照してください。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| to:                             | 特定のユーザー宛ての返信ポストすべてにマッチします。<br /><br />値には、そのユーザーの X アカウントの数値 ID またはユーザー名（@ 文字を除く）を指定する必要があります。数値の X アカウント ID の検索方法については [HERE](/ja/x-api/users/lookup/introduction) を参照してください。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| url:                            | ポストの展開された URL に対してトークン化（キーワード／フレーズ）によるマッチを行います（url&#95;contains と同様）。句読点や特殊文字を含むトークンおよびフレーズは二重引用符で囲む必要があります。例: url:&quot;/developer&quot;。一般的には推奨されませんが、特定のプロトコルに対してマッチさせたい場合は、二重引用符で囲んでください: url:&quot;[https://developer.x.com](https://developer.x.com)&quot;。<br />**注意:** PowerTrack または Historical PowerTrack を使用する場合、このオペレーターは引用ポスト元のオリジナルのポストに含まれる URL に対してマッチします。たとえば、ルールに url:&quot;developer.x.com&quot; が含まれており、あるポストがその URL を含んでいる場合、そのポストの引用ポストはすべて結果に含まれます。Search API を使用する場合は、このようなマッチングにはなりません。                                                                                                                                                                                                                            |
| #                               | 指定したハッシュタグを含む任意のポストにマッチします。<br /><br />このオペレーターはトークン化された一致ではなく、完全一致を行います。つまり、ルール「2016」はハッシュタグ「2016」を正確に含むポストにはマッチしますが、ハッシュタグ「2016election」を含むポストにはマッチしません。<br /><br />注: ハッシュタグ演算子は、本文から直接ハッシュタグを抽出するのではなく、ハッシュタグのマッチに X のエンティティ抽出機能を利用します。X Entities JSON 属性の詳細については[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#hashtags)を参照してください。                                                                                                                                                                                                                                                                                                                                                                                      |
| @                               | 指定したユーザー名をメンションしている任意のポストにマッチします。<br />to: 演算子でマッチする結果は、@mention 演算子の結果の部分集合になります。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| $                               | 指定した「キャッシュタグ」（トークンの先頭文字が「$」であるもの）を含む任意のポストにマッチします。<br /><br />キャッシュタグ演算子は、ポスト本文からキャッシュタグを抽出しようとするのではなく、X の「symbols」エンティティ抽出機能を利用してキャッシュタグにマッチする点に注意してください。X Entities の JSON 属性の詳細については [HERE](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#symbols) を参照してください。<br /><br />なお、この演算子は `enterprise` 検索 API でのみ利用可能です。<br /><br />                                                                                                                                                                                                                                                                                                                                                                                                   |
| retweets&#95;of:                | *利用可能な別名*: retweets&#95;of&#95;user:<br />指定したユーザーのポストのリツイートであるポストにマッチします。ユーザー名と数値の X アカウント ID の両方を受け付けます（ポストのステータス ID ではありません）。数値の X アカウント ID を取得する方法については、[こちら](/ja/x-api/users/lookup/introduction) を参照してください。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| lang:                           | 特定の言語であるとXによって分類されたポスト（ポストが分類されている場合に限る）に一致します。現在、各ポストは1つの言語にのみ分類されるため、複数の言語をAND条件で組み合わせて指定しても結果は返されないことに注意してください。<br /><br />**注:** 言語分類を行えない場合、返される値は「und」（未定義）となります。<br /><br />以下の一覧は、現在サポートされている言語と、それに対応する BCP 47 言語識別子を示しています。<br />                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| アムハラ語: am | ドイツ語: de | マラヤーラム語: ml | スロバキア語: sk |
| アラビア語: ar | ギリシャ語: el | ディベヒ語（モルディブ語）: dv | スロベニア語: sl |
| アルメニア語: hy | グジャラート語: gu | マラーティー語: mr | ソラニー・クルド語: ckb |
| バスク語: eu | ハイチ・クレオル語: ht | ネパール語: ne | スペイン語: es |
| ベンガル語: bn | ヘブライ語: iw | ノルウェー語: no | スウェーデン語: sv |
| ボスニア語: bs | ヒンディー語: hi | オリヤ語: or | タガログ語: tl |
| ブルガリア語: bg | ローマ字表記ヒンディー語: hi-Latn | パンジャーブ語: pa | タミル語: ta |
| ビルマ語: my | ハンガリー語: hu | パシュト語: ps | テルグ語: te |
| クロアチア語: hr | アイスランド語: is | ペルシア語: fa | タイ語: th |
| カタルーニャ語: ca | インドネシア語: in | ポーランド語: pl | チベット語: bo |
| チェコ語: cs | イタリア語: it | ポルトガル語: pt | 繁体字中国語: zh-TW |
| デンマーク語: da | 日本語: ja | ルーマニア語: ro | トルコ語: tr |
| オランダ語: nl | カンナダ語: kn | ロシア語: ru | ウクライナ語: uk |
| 英語: en | クメール語: km | セルビア語: sr | ウルドゥー語: ur |
| エストニア語: et | 韓国語: ko | 簡体字中国語: zh-CN | ウイグル語: ug |
| フィンランド語: fi | ラオス語: lo | シンド語: sd | ベトナム語: vi |
| フランス語: fr | ラトビア語: lv | シンハラ語: si | ウェールズ語: cy |
| ジョージア語: ka | リトアニア語: lt |     |

|||
|:----|:---|
|place:|指定した場所名 または X place ID がタグ付けされたポストにマッチします（例を参照）。複数語からなる場所名（「New York City」「Palo Alto」など）は引用符で囲む必要があります。<br /><br />**Note:** X place ID の取得方法については、パブリック API エンドポイント [GET geo/search](https://developer.x.com/en/docs/x-api/v1/geo/place-information/overview) を参照してください。<br /><br />**Note:** このオペレーターはリツイートにはマッチしません。リツイートの場所情報は元のポストに紐づいているためです。また、引用ツイートの元ポストに紐づいた場所情報にもマッチしません。|
|place&#95;country:|タグ付けされた [place](https://developer.x.com/en/docs/x-api/v1/geo/place-information/overview) に関連付けられている国コードが、指定した ISO アルファベット2文字コードと一致するポストにマッチします。<br /><br />有効な ISO コードはこちらで確認できます: [http://en.wikipedia.org/wiki/ISO&#95;3166-1&#95;alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)<br /><br />**Note:** このオペレーターはリツイートにはマッチしません。リツイートの場所情報は元のポストに紐づいているためです。また、引用ツイートの元ポストに紐づいた場所情報にもマッチしません。|
|point&#95;radius:[lon lat radius]|存在する場合、ポストの正確な位置（x, y）に対してマッチし、X においては「Place」ジオポリゴンに対してもマッチします。この場合、その Place が定義された領域内に完全に含まれている必要があります。<br /><br />* 対応している半径の単位はマイル（mi）とキロメートル（km）です。<br />* 半径は 25mi 未満でなければなりません。<br />* 経度は ±180 の範囲です。<br />* 緯度は ±90 の範囲です。<br />* すべての座標は 10 進度で指定します。<br />* ルール引数は角括弧内に含め、スペース区切りで指定します。<br /><br />**Note:** このオペレーターはリツイートにはマッチしません。リツイートの場所情報は元のポストに紐づいているためです。また、引用ツイートの元ポストに紐づいた場所情報にもマッチしません。|
|bounding&#95;box:[west&#95;long south&#95;lat east&#95;long north&#95;lat]|*利用可能なエイリアス*: geo&#95;bounding&#95;box:<br /><br />存在する場合、ポストの正確な位置（long, lat）に対してマッチし、X においては「Place」ジオポリゴンに対してもマッチします。この場合、その Place が定義された領域内に完全に含まれている必要があります。<br /><br />* west&#95;long と south&#95;lat はバウンディングボックスの南西端を表し、west&#95;long がその地点の経度、south&#95;lat が緯度です。<br />* east&#95;long と north&#95;lat はバウンディングボックスの北東端を表し、east&#95;long がその地点の経度、north&#95;lat が緯度です。<br />* バウンディングボックスの幅と高さは 25mi 未満でなければなりません。<br />* 経度は ±180 の範囲です。<br />* 緯度は ±90 の範囲です。<br />* すべての座標は 10 進度で指定します。<br />* ルール引数は角括弧内に含め、スペース区切りで指定します。<br />**Note:** このオペレーターはリツイートにはマッチしません。リツイートの場所情報は元のポストに紐づいているためです。また、引用ツイートの元ポストに紐づいた場所情報にもマッチしません。|
|profile&#95;country:|Profile Geo エンリッチメントの “address” オブジェクト内にある “countryCode” フィールドとの完全一致でマッチします。<br />ISO-3166-1-alpha-2 仕様に基づき正規化された 2 文字の国コードセットを使用します。このオペレーターは、簡潔さのため “address” オブジェクトの “country” フィールド用オペレーターの代わりとして提供されています。|
|profile&#95;region:|Profile Geo エンリッチメントの “address” オブジェクト内にある “region” フィールドにマッチします。<br /><br />これは文字列の完全一致マッチです。バックスラッシュで文字をエスケープする必要はありません。たとえば、スラッシュを含むものにマッチさせる場合は “one/two” を使用し、“one\/two” のようにしないでください。空白や句読点を含む部分文字列にマッチさせる場合は、ダブルクォーテーションで囲んでください。|
|profile&#95;locality:|Profile Geo エンリッチメントの “address” オブジェクト内にある “locality” フィールドにマッチします。<br /><br />これは文字列の完全一致マッチです。バックスラッシュで文字をエスケープする必要はありません。たとえば、スラッシュを含むものにマッチさせる場合は “one/two” を使用し、“one\/two” のようにしないでください。空白や句読点を含む部分文字列にマッチさせる場合は、ダブルクォーテーションで囲んでください。|

<Info>
  **注:** すべての `is:` および `has:` 演算子は、Search API を使用する際に単独では使用できず、必ず別の句と組み合わせて使用する必要があります。

  例えば、@XDeevelopers has:links
</Info>

|                     |                                                                                                                                                                                                                                                                                                                           |
| :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| has:geo             | X によって提供される、ポスト固有のジオロケーションデータを持つポストにマッチします。これは、「geo」の緯度・経度座標、または対応する表示名、ジオポリゴン、およびその他のフィールドを含む、X の [「Place」](https://dev.x.com/overview/api/places) オブジェクト形式の「location」のいずれかになります。<br /><br />  <br /><br />**注:** Search API を使用する場合、このオペレーターは、`is:` または `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                         |
| has:profile&#95;geo | *利用可能な別名*: has:derived&#95;user&#95;geo<br /><br />実際の値に関係なく、任意の[Profile Geo](http://support.gnip.com/enrichments/profile_geo.html)メタデータを持つポストにマッチします。  <br />  <br /><br />**注記:** Search API を使用する際には、このオペレーターを `is:` または `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                                                       |
| has:links           | このオペレーターは、メッセージ本文にリンクを含むポストに一致します。  <br />  <br /><br />**注記:** Search API を使用する場合、このオペレーターは `is:` や `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                                                                                                                                                                              |
| is:retweet          | ルールに一致する明示的なリツイートのみを配信します。否定形で使用して、ルールに一致するリツイートを配信対象から除外し、元のコンテンツのみを配信することもできます。<br /><br />このオペレーターは、X のリツイート機能を使用したリツイートのみを対象とします。X のリツイート機能を使用しない引用ポスト（引用リツイート）や、内容を変更したポストは、このオペレーターではマッチしません。<br /><br />  <br /><br />**注:** Search API を使用する場合、このオペレーターは `is:` や `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。          |
| is:reply            | このオペレーターは、ポストが他のポストへの返信であるかどうかに基づいてポストをフィルタリングするためのものです。ルールに一致する明示的な返信のみを配信します。また、ルールに一致する返信を配信対象から除外するために否定形で使用することもできます。<br /><br />なお、このオペレーターは有料の Premium および Enterprise 検索でのみ利用可能であり、Sandbox 開発環境では利用できません。<br /><br />  <br /><br />**注:** Search API を使用する場合、このオペレーターは必ず、`is:` や `has:` を含まない他のオペレーターと併用する必要があります。 |
| is:quote            | ポストのペイロード内の &quot;is&#95;quote&#95;status&quot;:true によって識別される引用ポスト（Quote Tweets）、すなわち別のポストを参照しているポストのみを配信します。否定形にして引用ポストを除外することもできます。  <br /><br />**注:** Search API を使用する場合、このオペレーターは、`is:` または `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                                                                                 |
| is:verified         | X によって「認証済み」とされている投稿者のポストのみを返します。否定形を使用して、投稿者が認証済みのポストを除外することもできます。  <br />  <br /><br />**注:** Search API を使用する場合、このオペレーターは `is:` や `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                                                                                                                                              |
| has:mentions        | 他のXユーザーへのメンションを含むポストにマッチします。  <br />  <br /><br />**注記:** Search API を使用する際は、このオペレーターは `is:` か `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                                                                                                                                                                                    |
| has:hashtags        | ハッシュタグを含むポストにマッチします。  <br />  <br /><br />**注:** Search API を使用する際は、このオペレーターを `is:` または `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                                                                                                                                                                                           |
| has:media           | *利用可能な別名*: has:media&#95;link<br /><br />X によってメディアとして分類された URL を含むポストにマッチします。例: pic.x.com。  <br />  <br /><br />**注:** Search API を使用する場合、この演算子は `is:` または `has:` を含まない別の演算子と組み合わせて使用する必要があります。                                                                                                                          |
| has:images          | X によってメディアとして分類される URL を含むポストにマッチします。例えば、pic.x.com などです。  <br />  <br /><br />**注:** Search API を使用する場合、この演算子は `is:` や `has:` を含まない他の演算子と組み合わせて使用する必要があります。                                                                                                                                                               |
| has:videos          | *利用可能なエイリアス*: has:video&#95;link<br /><br />X に直接アップロードされたネイティブ動画を含むポストにマッチします。Vine、Periscope で作成された動画や、他の動画ホスティングサイトへのリンクを含むポストにはマッチしません。  <br />  <br /><br />**注:** Search API を使用する場合、この演算子は、`is:` または `has:` を含まない他の演算子と組み合わせて使用する必要があります。                                                                           |
| has:symbols         | 先頭に「$」文字が付いたキャッシュタグ（例: $tag）を含むポストに一致します。このオペレーターは `enterprise` 検索 API でのみ利用可能です。  <br />  <br /><br />**注:** Search API を使用する場合、このオペレーターは、`is:` や `has:` を含まない他のオペレーターと組み合わせて使用する必要があります。                                                                                                                                |

<div id="product-overview">
  ### プロダクト概要
</div>

Enterprise ティアの Full-archive Search は 2015 年 8 月に、プレミアム ティア版は 2018 年 2 月にリリースされました。これらの検索プロダクトにより、お客様は公開されている任意のポストに即座にアクセスできます。Full-archive Search では、1 つのクエリを送信し、従来型の RESTful な方式でレスポンスを受け取ります。Full-archive Search はレスポンスあたり最大 500 ポストのページネーションを実装しており、プレミアムで 1 分あたり最大 60 リクエスト (rpm)、Enterprise で 120 rpm のレート制限をサポートします。これらの特性により、Full-archive Search を使用すると、複数のリクエストを並行して発行することで、ポストを高速かつ大規模に取得できます。

ディスク上のポストのフラットファイル集合に基づく Historical PowerTrack とは異なり、Full-archive Search のポストアーカイブはオンラインデータベースに近い構造になっています。すべてのデータベースと同様に、その内容に対するクエリをサポートします。また、高速なデータ取得を可能にするために *index* を利用しています。Full-archive Search エンドポイントでは、クエリ言語は PowerTrack Operators から構成されており、各 Operator はインデックスされたポストの JSON 属性に対応しています。

また、Historical PowerTrack と同様に、クエリを実行した時点の最新状態を表すポスト属性も存在します。たとえば、Search API を使って今日、2010 年に投稿されたポストにアクセスする場合、ユーザーのプロフィール説明、アカウントの「ホーム」ロケーション、表示名、およびお気に入り数やリツイート件数といったポストのメトリクスは、2010 年当時ではなく、今日時点の値に更新されています。 

<div id="metadata-timelines">
  ### メタデータのタイムライン
</div>

以下は、Full-archive search エンドポイントの Operator がマッチングを開始した時期のタイムラインです。場合によっては、Operator のマッチング開始は、X 上で「コミュニケーション上の慣習」が一般的になってからかなり *後* のこともあります。たとえば、@Replies は 2006 年にユーザーの慣習として登場しましたが、「サポート用」の JSON を伴った *第一級オブジェクト* や *イベント* になったのは 2007 年初頭でした。そのため、2006 年の @Replies にマッチさせるには、`to:` や `in_reply_to_status_id:` PowerTrack Operator に依存するのではなく、ポスト本文を精査する必要があります。

ここで示す詳細は、Full-Archive Search（数百件におよぶ検索を実行して得られた結果）を用いて生成したものです。このタイムラインは 100% 完全でも厳密でもありません。ご利用のユースケースにとって重要な、別のフィルタリングやメタデータの「誕生日」に気付かれた場合は、ぜひお知らせください。

なお、基盤となる Search インデックスは再構築される場合があります。したがって、ここで示すタイムラインの詳細は今後変更される可能性があります。

<div id="2006">
  #### 2006
</div>

* 3月26日 - `lang:`。検索インデックスを生成する際に、ポストのメタデータが遡って補完された例。
* 7月13日 - `has:mentions` がマッチし始める。
* 10月6日 - `has:symbols`。株式シンボルについて議論するための $cashtag（または symbol）の一般的な利用が広まるのは2009年初頭になってから。それまでは、ほとんどの使用例はおそらくスラング（例: $slang）だった。
* 10月26日 - `has:links` がマッチし始める。
* 11月23日 - `has:hashtags` がマッチし始める。

<div id="2007">
  #### 2007
</div>

* 1月30日 - 初の正式な @reply（in&#95;reply&#95;to&#95;user&#95;id）、`reply_to_status_id:` のマッチングが開始される。
* 8月23日 - ハッシュタグがトピックや会話を整理する一般的な慣習として登場。1週間後に初めて本格的に利用される。

<div id="2009">
  #### 2009
</div>

* 5月15日 - `is:retweet`。このオペレーターは、公式リツイートの「ベータ」リリースに伴い、“Via @” パターンに対してマッチし始めます。このベータ期間中、ポストの動詞は「post」のままであり、元のポストはペイロードに含まれません。
* 8月13日 - 公式リツイートの最終版が、“RT @” パターン、動詞が「share」に設定され、元のポストを含む `retweet_status` 属性とともにリリースされます（これにより JSON ペイロードサイズがおおよそ2倍になります）。

<div id="2010">
  #### 2010
</div>

* 3月6日 - `has:geo`、`bounding_box:` および `point_radius:` のジオオペレーターでマッチングが行われるようになる。
* 8月28日 - `has:videos`（2015年2月まで、このオペレーターは youtube.com、vimeo.com、vivo.com など特定の動画ホスティングサイトへのリンクを含むポストにマッチする）。

<div id="2011">
  #### 2011
</div>

* 7月20日 - `has:media` と `has:images` のマッチングが開始されました。ネイティブ写真機能は2010年8月9日に正式に発表されました。

<div id="2014">
  #### 2014
</div>

* 12月3日 - （おおよそ）HTML のタイトルと説明を含む *一部の* [拡張 URL メタデータ](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments) がペイロードに含まれるようになりました。拡張メタデータが本格的に利用可能になったのは2016年5月です。

<div id="2015">
  #### 2015
</div>

* February 10 - `has:videos` は X の「ネイティブ」動画にマッチするようになります。
* February 17 - `has:profile_geo`, `profile_country:`, `profile_region:`, `profile_locality:` [Profile Geo](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments#profile-geo) オペレーターでのマッチングが有効になります。
* February 17 - `place_country:` と `place:` ポストのジオ（位置情報）オペレーターでのマッチングが有効になります。

<div id="2016">
  #### 2016
</div>

* 5月1日 - [Enhanced URL metadata](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments) がより広範に利用可能となり、[2016年8月の Gnip 2.0 のローンチ](https://blog.x.com/2016/gnip-2-is-here) の一部として正式に発表されました。Search API では、これらのメタデータに対応するオペレーターは提供されていません。

<div id="2017">
  #### 2017
</div>

* 2月22日 - Poll メタデータが拡張ネイティブ形式で利用可能になりました。これらのメタデータに対応する Operators は定義されていません。

<div id="2022">
  #### 2022
</div>

* 9 月 27 日 - この日付以降に作成されたすべてのポストオブジェクトには、ポストの編集メタデータが利用可能です。ポストオブジェクトを提供するすべての Enterprise エンドポイントは、この日付からこのメタデータを提供するように更新されました。提供される編集メタデータには、`edit_history` と `edit_controls` オブジェクトが含まれます。これらのメタデータは、2022 年 9 月 27 日より前に作成されたポストには返されません。現在、これらのメタデータに対応する Enterprise オペレーターは存在しません。ポストの編集メタデータの詳細については、[Edit Posts fundamentals](/ja/x-api/fundamentals/edit-posts) ページを参照してください。

<div id="2022">
  #### 2022
</div>

* 9月29日 - この日以降に作成されたすべてのポストオブジェクトには、編集済みポストのメタデータが利用可能です。ポストオブジェクトを提供するすべての Enterprise エンドポイントは、この日からこのメタデータを提供するように更新されました。提供される編集メタデータには、edit&#95;history オブジェクトと edit&#95;controls オブジェクトが含まれます。これらのメタデータは、2022年9月27日より前に作成されたポストには返されません。現在、これらのメタデータに対応する Enterprise Operator は利用できません。編集済みポストのメタデータについて詳しくは、[Edit Posts fundamentals](/ja/x-api/fundamentals/edit-posts) ページを参照してください。

<div id="filtering-tips">
  ### フィルタリングのヒント
</div>

ここまで説明してきたタイムライン情報から分かるように、Search API のフィルターを作成する際には考慮すべき詳細が多くあります。特に重要なポイントは次の 2 つです。

* 一部のメタデータには「導入日（born-on）」があるため、フィルターの結果として *偽陰性* が発生する可能性があります。これは、検索期間の一部またはすべてにおいて存在していなかったメタデータに依存する Operator を含む検索です。たとえば、`has:images` Operator を使ってポストを検索する場合、2011 年 7 月より前の期間についてはヒットがありません。これは、その Operator が *ネイティブ* 写真（X のユーザーインターフェースを使ってポストに添付された写真）に対して一致を取るためです。写真共有ポストのより網羅的なデータセットを取得するには、2011 年 7 月以前を対象とするフィルターに、写真ホスティングでよく使われる URL に一致するルール句を含める必要があります。
* 一部のメタデータには、ポストが投稿された時点より *後* の時期のメタデータが後付けで補完（バックフィル）されています。

PowerTrack クエリを作成する際に、よく重視される属性タイプがいくつかあります。

* X プロフィール
* オリジナルポストか共有ポストか
* ポストの言語分類
* 位置情報つきポスト
* 共有リンクのメディア

これらの中には製品固有の動作をするものもあれば、同じ動作をするものもあります。詳しくは以下を参照してください。

<div id="x-profiles">
  #### X プロフィール
</div>

Search API は、*取得時点* のユーザープロフィール情報を含む過去のポストを返します。たとえば 2014 年のポストをリクエストした場合でも、ユーザーのプロフィールメタデータはクエリ実行時点の状態を反映します。

<div id="original-posts-and-retweets">
  #### オリジナルポストとリツイート
</div>

PowerTrack `_is:retweet_` オペレーターを使用すると、リツイートを含めるか除外するかを指定できます。このオペレーターの利用者は、2009 年 8 月以前のデータについて、リツイートをマッチさせる（またはマッチさせない）ための 2 通りの戦略を用意しておく必要があります。2009 年 8 月以前は、ポスト本文自体を完全一致のフレーズマッチでチェックし、「@RT 」パターンに一致するかどうかを確認する必要があります（実際には、2009 年 5〜8 月のリツイートをフィルタリングする場合、「Via @」パターンも含めるべきです）。2009 年 8 月以降については、`_is:retweet_` オペレーターが利用可能です。

<div id="post-language-classifications">
  #### ポストの言語分類
</div>

ポストの言語分類でフィルタリングする場合、X の従来プロダクト間では仕様が大きく異なります。Search archive が構築された際、すべてのポストに対して X の言語分類がさかのぼって付与されました。そのため、`lang:` オペレーターは全ポストのアーカイブを対象に利用できます。

<div id="geo-referencing-posts">
  #### ポストのジオリファレンス
</div>

ポストをジオリファレンスする主な方法は 3 つあります。

* **ポスト本文内の地理的な参照。** ポスト本文内の地理的参照に基づいてマッチングする方法です。ローカルな知識に依存するため、しばしば最も難易度の高い方法となりますが、ポスト全アーカイブに対して利用できるオプションです。[こちら](https://x.com/biz/statuses/28311)は、サンフランシスコ地域を対象に「golden gate」フィルターを用いて 2006 年にジオリファレンスされたマッチの例です。

* **ユーザーがジオタグを付与したポスト。** 検索 API では、2010 年 3 月から一部の Geo Operator を使ってポストのマッチングを開始できるようになり、2015 年 2 月からはその他の Operator も利用可能になりました。

  * 2010 年 3 月 6 日: `has:geo`、`bounding_box:`、`point_radius:`
  * 2015 年 2 月 17 日: `place_country:`、`place:`

* **ユーザーが設定したアカウントプロフィールの「ホーム」ロケーション。** Profile Geo Operator は Historical PowerTrack と Search API の両方で利用可能です。Search API では、これらの Profile Geo メタデータは 2015 年 2 月から利用可能になりました。Profile Geo メタデータが利用できるようになる前に投稿されたポストについては、正規化されていないユーザー入力に基づいてマッチングするために利用できる `bio_location:` Operator が用意されています。

<div id="shared-links-and-media">
  #### 共有リンクとメディア
</div>

2012年3月に、拡張 URL エンリッチメントが導入されました。この時点以前は、ポストのペイロードにはユーザーが指定した URL のみが含まれていました。そのため、ユーザーが短縮 URL を含めていた場合、関心のある（展開後の）URL と照合するのが難しいことがありました。Search API では、これらのメタデータは 2012年3月以降に利用可能になります。

2016年7月には、機能強化された URL エンリッチメントが導入されました。この強化版では、ポストのペイロード内に Web サイトの HTML タイトルと説明が含まれ、それらにマッチさせるためのオペレーターも提供されます。これらのメタデータは 2014年12月頃から現れ始めました。

2016年9月、Xは「ネイティブ添付ファイル」を導入し、末尾の共有リンクがポストの 140 文字制限にカウントされないようになりました。これらの共有リンクには、両方の URL エンリッチメントが引き続き適用されます。

関連する検索オペレーターがマッチし始める時期は次のとおりです。

* 2006年10月26日 - `has:links`
* 2011年7月20日 - `has:images` および `has:media`
* 2011年8月 - `url:`（[Expanded URLs enrichment](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments) を使用）。早ければ 2006年9月には、`(url:"spotify.com" OR url:gnip OR url:microsoft OR url:google OR url:youtube)` が http://x.com/Adam/statuses/16602 にマッチします。twitter&#95;entities や gnip オブジェクトには urls[] メタデータが存在しないにもかかわらずです。「youtube.com」は、urls[] メタデータが一切なくても url:youtube にマッチするメッセージ本文の一例です。
* 2015年2月10日 - ネイティブ動画向けの `has:videos`。2010/08/28 から 2015/02/10 の間、このオペレーターは youtube.com、vimeo.com、vivo.com など一部の動画ホスティングサイトへのリンクを含むポストにマッチします。
* 2016年5月1日 - `url_title:` および `url_description:`。 [Enhanced URLs enrichment](/ja/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments) に基づき一般提供が開始されました。最初の Enhanced URL メタデータは 2014年12月に現れ始めました。

<div id="frequently-asked-questionsfaq">
  ## よくある質問（FAQ）
</div>

<div id="general-search-post-api-questions">
  ### Search Post API 全般に関する質問
</div>

<AccordionGroup>
  <Accordion title="data エンドポイントから取得するポスト数が、counts エンドポイントでカウントされるポスト数と一致しません。これはなぜ一致しないのですか？">
    `counts` エンドポイントと `data` エンドポイントが返す結果には、既知の違いがあります。`counts` エンドポイントはコンプライアンス適用前（削除されたポストや scrub geo などを考慮しない状態）である一方、`data` エンドポイントは配信時点でコンプライアンスが適用され、すべてのコンプライアンス関連イベントを反映しているため、結果に差異が生じる場合があります。
  </Accordion>

  <Accordion title="クエリに一致するはずのポストが取得できませんでした。なぜですか？">
    これが発生した理由としては、次のようなものが考えられます。

    1. 表示されるはずのポストが非公開アカウントによるものである
    2. data エンドポイントではすべてのコンプライアンスイベントが考慮されるため、削除されたポストや位置情報が削除されたポストなどはレスポンスに含まれない
  </Accordion>

  <Accordion title="クエリがあるポストにマッチしましたが、そのポストには自分が除外（NOT）指定したキーワードが含まれていました。これはなぜですか？">
    これは、プレミアムルールやフィルタリング機能の誤った利用によるものと考えられます。ドキュメントを[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering)で確認し、ルール作成に関する制限事項を十分に理解してください。
  </Accordion>

  <Accordion title="Search ポスト API の利用を始めるにあたって使えるライブラリはありますか？">
    はい、あります。例えば次のようなものです。

    * [Tweepy](http://www.tweepy.org/) - 標準の search/ポスト プロダクトを利用するのに適したライブラリです（Python）
    * [X API](https://github.com/geduldig/TwitterAPI) - 標準の Search Post API を利用するのに適したライブラリです（Python）
    * [Search Posts Python](https://github.com/xdevplatform/search-tweets-python) および [Search Posts Ruby](https://github.com/xdevplatform/search-tweets-ruby) - Enterprise（および v2！）Search Post API で利用できる有用な 2 つのツールです

    当社が直接サポートしているライブラリはすべて、xdevplatform の GitHub ページ [https://github.com/xdevplatform](https://github.com/xdevplatform) に掲載されています。

    そのほかにも[サードパーティ製ライブラリ](/ja/resources/fundamentals/authentication#oauth-1-0a-2)が役立つ場合があります。ただし、これらの一部は当社のプレミアムおよび Enterprise プロダクトでは動作しない可能性がある点にご注意ください。
  </Accordion>

  <Accordion title="データエンドポイントへのリクエストで指定した `maxResults` の値よりも少ない数のポストが返ってくることはありますか？">
    はい。データエンドポイントでは、指定した `maxResults` に達した時点、または 30 日が経過した時点のいずれか早い方でページネーションが行われます。

    たとえば、ある 30 日間に 800 件のポストがある場合、完全な結果を取得するには 2 回リクエストを行う必要があります。1 回のリクエストで返せるポストの最大数は 500 件（`maxResults`）であるためです。また、1 か月目に 400 件のポストがあり、2 か月目に 100 件のポストがある場合も、完全な結果を取得するには 2 回リクエストを行う必要があります。これは、最初のリクエストで指定した `maxResults` 未満のポストしか返されない場合でも、ページネーションが 30 日ごとの期間で行われるためです。
  </Accordion>

  <Accordion title="一致したポストはどの順序で返されますか？">
    ポストは新しいものから古いものへと時系列の逆順で返されます。たとえば、最初の結果ページにはクエリに一致する最新のポストが表示され、最初に指定した `fromDate` に到達するまでページネーションによって結果を取得し続けます。
  </Accordion>

  <Accordion title="ポストの編集は、利用状況や課金にどのような影響がありますか？">
    請求対象となるのは元のポストのみです。以降の編集は無視され、アクティビティ全体の件数には含まれません。

    `Enterprise`
  </Accordion>

  <Accordion title="Enterprise Search Post API の料金について詳しく知りたいのですが、このプランに申し込むにはどうすればよいですか？">
    当社の Enterprise ソリューションは、お客様のビジネスニーズに合わせてカスタマイズされ、分かりやすい料金体系でご提供しています。詳細およびお申し込みは[こちら](/ja/x-api/enterprise-gnip-2.0/enterprise-gnip)をご確認ください。
  </Accordion>

  <Accordion title="自分のユースケースに合致するルールセットはどのように設計すればよいですか？">
    * Enterprise Search Post API に関するドキュメントは[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-search-apis)を参照してください
    * ルールおよびフィルタリングに関する情報は[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#enterprise-operators)を参照してください
    * data エンドポイントの利用方法に関する情報は[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#data-endpoint)を参照してください
    * counts エンドポイントの利用方法に関する情報は[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#counts-endpoint)を参照してください
    * 利用可能なオペレーターの一覧は[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)を参照してください
  </Accordion>

  <Accordion title="今月分のリクエスト上限を超えてしまいましたが、さらに多くのデータにアクセスするにはどうすればよいですか？">
    この件については、Xの担当アカウントマネージャーまでご連絡ください。対応いたします。
  </Accordion>
</AccordionGroup>

<div id="error-troubleshooting-guide">
  ### エラーのトラブルシューティングガイド
</div>

**コード 404 - Not Found**

1. 各エンドポイントで正しいパラメータを使用していることを確認してください（例：`buckets` フィールドは `counts` エンドポイントでのみ使用でき、`data` エンドポイントでは使用できません）。
2. `:product`、`:account_name`、`:label` フィールドが正しいことを再度確認してください。`:label` フィールドは GNIP Console（Enterprise のお客様のみ）で確認できます。

<div id="api-reference">
  ## APIリファレンス
</div>

<div id="enterprise-search-apis">
  ### Enterprise search APIs
</div>

Enterprise 検索 API には 2 種類あります。

* 30-Day Search API - 直近 30 日間にポストされたポストを提供します。
* Full-Archive Search API - 2006 年 3 月にポストされた最初のポストからのポストを提供します。

これらの検索 API は共通の設計となっており、以下のドキュメントは両方に適用されます。なお、2022 年 9 月 29 日以降に作成されたポストについては、その編集履歴を示すポスト編集メタデータがポストオブジェクトに含まれます。詳細は、「[&quot;Edit Tweets&quot;](/ja/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets)」の基本事項ページを参照してください。

以下では、Enterprise 検索 API と統合する際に必要となる重要なポイントを示します。

* ポストデータおよび件数をリクエストするためのメソッド
* 認証
* ページネーション
* API リクエストパラメータとリクエスト例
* API レスポンスの JSON ペイロードとレスポンス例
* HTTP レスポンスコード

Enterprise API は、ポストアーカイブへの低レイテンシかつ高い忠実度を備えたクエリベースのアクセスを提供します。2 つの API の違いは検索できる期間のみで、直近 30 日間か、2006 年までさかのぼるかの違いです。時間範囲は分単位の粒度で指定できます。ポストデータは、クエリにマッチする最新のポストから始まり、新しい順（逆時系列）で返されます。ポストは公開後、約 30 秒で検索 API から利用可能になります。

<div id="methods">
  #### メソッド
</div>

Enterprise search のベース URI は `https://gnip-api.x.com/search/` です。

| Method | Description |
| :--- | :--- |
| [POST /search/:product/accounts/:account&#95;name/:label](#SearchRequests) | 指定した PowerTrack ルールにマッチする直近30日間のポストを取得します。 |
| [POST /search/:product/accounts/:account&#95;name/:label/counts](#CountRequests) | 指定した PowerTrack ルールにマッチする直近30日間のポスト件数を取得します。 |

ここで：

* `:product` は、リクエスト先の検索エンドポイントを示し、`30day` または `fullarchive` のいずれかです。
* `:account_name` は、console.gnip.com に表示される、アカウントに紐づいた（大文字と小文字が区別される）名前です。
* `:label` は、console.gnip.com に表示される、検索エンドポイントに紐づいた（大文字と小文字が区別される）ラベルです。

たとえば、TwitterDev アカウントがラベル「prod」（production の省略形）付きの 30-Day search プロダクトを持っている場合、検索エンドポイントは次のようになります。

* データエンドポイント: [https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod.json](https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod.json)
* カウントエンドポイント: [https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod/counts.json](https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod/counts.json)

利用している Enterprise search API の完全なエンドポイントは [https://console.gnip.com](https://console.gnip.com) に表示されます。

以下に、curl というシンプルな HTTP ユーティリティを使ったリクエスト例をいくつか示します。これらの例では、URL に `:product`、`:account_name`、`:label` を使用しています。これらの例を利用する際は、URL を自身の情報に更新してください。

<div id="authentication">
  #### 認証
</div>

Enterprise search API へのすべてのリクエストは、[https://console.gnip.com](https://console.gnip.com) のアカウントにログインする際に使用する有効なメールアドレスとパスワードの組み合わせから構成される HTTP の *Basic Authentication* を使用する必要があります。認証情報は、各リクエストの *Authorization* ヘッダーに含める必要があります。

<div id="requestresponse-behavior">
  #### リクエスト／レスポンスの動作
</div>

`fromDate` と `toDate` パラメータを使用すると、API がサポートする任意の期間をリクエストできます。30-Day search API は、直近31日分のポストを提供します（「30-Day」API と呼ばれていますが、ユーザーが1か月分を完全に取得できるように31日分を利用可能にしています）。Full-Archive search API は、最初のポスト（2006年3月21日）までさかのぼって取得できます。ただし、1回のレスポンスで返されるのは、指定した `maxResults` または 31 日分のうち小さい方に制限されます。検索結果の件数または指定した時間範囲が、指定した `maxResults` もしくは 31 日分を超える場合、指定した期間の残りをページネーションするために使用する `next` トークンが返されます。

例えば、Full-Archive search を使用して、2017年1月1日から2017年6月30日までの間でクエリにマッチするすべてのポストを取得したいとします。この場合、リクエストで `fromDate` と `toDate` パラメータを使用して、その6か月間全体を指定します。search API は、`maxResults` パラメータ（デフォルトは 100）に一致する件数のポストを含む、最初の「ページ」にあたるポストで応答します。さらにポストが存在する（おそらく存在します）と仮定すると、API は次の「ページ」のデータをリクエストできるようにする `next` トークンも返します。この処理は、API が `next` トークンを返さなくなるまで繰り返されます。詳細については次のセクションを参照してください。

<div id="pagination">
  #### ページネーション
</div>

data リクエストと count リクエストの両方を行う場合、1 回のレスポンスで返せる量を超えるデータが存在する可能性があります。そのような場合、レスポンスには「next」トークンが含まれます。「next」トークンは、ルートレベルの JSON 属性として提供されます。「next」トークンが含まれている場合は、取得すべき追加データが存在することを意味するため、API リクエストを引き続き送信する必要があります。

**注意:** 「next」トークンの動作は、data リクエストと count リクエストで若干異なります。両方の動作については、API Reference セクションでレスポンス例とともに説明しています。

<div id="data-pagination">
  ##### データのページネーション
</div>

データのリクエストでは、1 回のレスポンスで返せる量を超えるデータが生成される可能性があります。各データリクエストには、1 回のリクエストで返すポストの最大数を設定するパラメータが含まれています。この `maxResults` パラメータのデフォルト値は 100 で、10〜500 の範囲で設定できます。クエリでマッチするポストの数が、リクエストで使用した `maxResults` パラメータの値を超える場合、レスポンスには「next」トークン（ルートレベルの JSON 属性として）が含まれます。この「next」トークンは後続のリクエストで使用され、そのクエリにマッチするポストの次の部分（つまり次の「ページ」）を取得します。「next」トークンは、そのクエリの結果の最後の「ページ」に到達し、「next」トークンが返されなくなるまで提供され続けます。

次の「ページ」のデータをリクエストするには、元のクエリとまったく同じ内容のクエリを実行する必要があります。使用している場合は `query`、`toDate`、`fromDate` パラメータを含め、さらに前回のレスポンスに含まれていた値を設定した「next」リクエストパラメータも含めます。これは GET リクエストと POST リクエストのどちらでも利用できます。ただし、GET リクエストの場合、「next」パラメータは URL エンコードされている必要があります。

クエリで対象としている期間に含まれるすべてのポストを取得するまで、前回のクエリから受け取った「next」要素を渡し続けることができます。「next」要素を含まないレスポンスを受け取った場合、それは最後のページに到達しており、指定したクエリと時間範囲に対して追加のデータが存在しないことを意味します。

<div id="counts-pagination">
  ##### counts ページネーション
</div>

`counts` エンドポイントは、クエリに関連付けられたポスト数を、日次、時間単位、または分単位のいずれかの粒度で提供します。`counts` API エンドポイントは、最大 31 日分の件数ペイロードに対して、タイムスタンプ付きの件数配列を返します。31 日分を超える件数をリクエストした場合、`next` トークンが返されます。データ用の `next` トークンと同様に、元のリクエストとまったく同じクエリを行い、さらに前回のレスポンスから取得した値を `next` リクエストパラメータとして指定する必要があります。

31 日分を超える件数をリクエストした場合に加えて、`next` トークンが提供される別のシナリオがあります。ボリュームの多いクエリでは、件数の生成に時間がかかりすぎてレスポンスがタイムアウトする可能性があります。この状況が発生すると、31 日分未満の件数しか受け取れませんが、全件数ペイロードを取り切るために `next` トークンが提供されます。***重要:*** タイムアウト時には常に完全な「バケット」単位のみが返されます。そのため、2.5 日分に相当する場合は、1 日分の完全な「バケット」が 2 つ返されます。

<div id="additional-notes">
  ##### 追加の注意事項
</div>

* 検索リクエストで fromDate や toDate を使用する場合、指定した時間範囲内の結果のみが返されます。指定した時間範囲内の最後の結果グループに到達すると、`next` トークンは返されません。
* `next` 要素は、10〜500 の任意の maxResults 値（デフォルト値は 100）で使用できます。maxResults は各レスポンスで返されるポストの件数を決定しますが、最終的にすべての結果を取得することを妨げるものではありません。
* `next` 要素の有効期限はありません。同じ `next` パラメータ値を含むクエリを使って複数回リクエストした場合、リクエストのタイミングに関係なく同じ結果が返されます。
* `next` パラメータを使用して結果をページングする際、クエリの境界付近で重複が発生する場合があります。アプリケーションはこれらの重複を許容するように設計してください。

<div id="data-endpoint">
  #### データエンドポイント
</div>

<div id="post-searchproductlabel">
  ##### POST /search/:product/:label
</div>

<div id="endpoint-pattern">
  ###### エンドポイントパターン:
</div>

このエンドポイントは、指定されたクエリと期間に対応するデータを返します。期間が指定されていない場合、時間パラメータは直近30日間に設定されます。注記: 下記で説明するパラメータをURLにエンコードすることで、POSTではなくGETリクエストを使用して同じ機能を実現することもできます。

<div id="data-request-parameters">
  ##### データリクエストパラメータ
</div>

| パラメータ | 説明 | 必須 | サンプル値 |
| :--- | :--- | :--- | :--- |
| query | 最大 2,048 文字まで指定できる、1 つの PowerTrack ルールに相当します（肯定・否定両方の句の数に制限はありません）。  <br />  <br />このパラメータには、PowerTrack ルールのすべての要素（すべてのオペレーターを含む）を含める必要があり、ルールの一部をクエリの他のパラメータに分割してはいけません。  <br />  <br />**注:** すべての PowerTrack オペレーターがサポートされているわけではありません。サポートされているオペレーターは[こちら](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)に一覧があります。 | はい | (snow OR cold OR blizzard) weather |
| tag | タグは、ルールとそれに一致するデータを、異なる論理グループに分けるために使用できます。ルールタグが指定されると、そのルールタグは &#39;matching&#95;rules&#39; 属性に含まれます。  <br />  <br />ルールタグにはルール固有の UUID を割り当て、必要なマッピングはクライアント側で管理することを推奨します。 | いいえ  | 8HYG54ZGTU |
| fromDate | ポストが提供される最も古い UTC タイムスタンプ（Full-Archive search では 2006/3/21 まで遡及可能）を指定します。タイムスタンプは分単位の粒度で、指定値を含みます（例: 12:00 は 00 分を含みます）。  <br />  <br />*指定した場合:* fromDate のみを使用し、toDate パラメータを指定しない場合、結果は現在時刻（now( )）から fromDate まで時間を遡って返されます。  <br />  <br />*未指定の場合:* fromDate が指定されていない場合、API は現在時刻（now( )）または toDate（指定されている場合）の 30 日前までのすべての結果を返します。  <br />  <br />fromDate と toDate のどちらのパラメータも使用しない場合、API はリクエスト時点から遡った直近 30 日分のすべての結果を返します。 | いいえ  | 201207220000 |
| toDate | ポストが提供される最新（最も新しい）UTC タイムスタンプを指定します。タイムスタンプは分単位の粒度で、指定値は含みません（例: 11:59 はその時間の 59 分を含みません）。  <br />  <br />*指定した場合:* toDate のみを使用し、fromDate パラメータを指定しない場合、toDate より前の直近 30 日分のデータが返されます。  <br />  <br />*未指定の場合:* toDate が指定されていない場合、API は現在時刻（now( )）からクエリの fromDate まで時間を遡ったすべての結果を返します。  <br />  <br />fromDate と toDate のどちらのパラメータも使用しない場合、API は 30 日インデックス全体について、リクエスト時点から遡ったすべての結果を返します。 | いいえ  | 201208220000 |
| maxResults | 1 回のリクエストで返される検索結果の最大数です。10 からシステム上限（現在は 500）までの数値を指定できます。デフォルトでは、1 回のリクエストのレスポンスでは 100 件の結果が返されます。 | いいえ  | 500 |
| next | このパラメータは、[こちら](#Pagination)で説明されているとおり、次の「ページ」の結果を取得するために使用されます。このパラメータで使用する値は、API が返すレスポンスから直接取得するものであり、変更してはいけません。 | いいえ  | NTcxODIyMDMyODMwMjU1MTA0 |

<div id="additional-details">
  ###### 追加の詳細
</div>

|     |     |
| :--- | :--- |
| **利用可能な期間** | 30-Day: 直近31日間  <br />Full-Archive: 2006年3月21日～現在 |
| **クエリ形式** | 1つの PowerTrack ルールと同等で、最大2,048文字まで指定できます（肯定および否定の句の数には制限はありません）。  <br />  <br />**注:** すべての PowerTrack 演算子がサポートされているわけではありません。サポートされている演算子の一覧については、[Available operators](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators) を参照してください。 |
| **レート制限** | パートナーには、分単位および秒単位の両方の粒度でレート制限が適用されます。1分あたりのレート制限は、契約で規定されているとおりパートナーごとに異なります。ただし、これらの1分あたりのレート制限は、単発のバーストで使い切ることを想定したものではありません。1分あたりのレート制限の値にかかわらず、すべてのパートナーは、データおよび/または件数に対するすべてのリクエストを合算して、1秒あたり最大20リクエストに制限されます。 |
| **コンプライアンス** | Full-Archive Search API を通じて配信されるすべてのデータは、配信時点においてコンプライアンス要件に準拠しています。 |
| **リアルタイムでの利用可能性** | データは Twitter プラットフォーム上で生成されてから30秒以内に、インデックス内で利用可能になります |

<div id="example-data-requests-and-responses">
  ##### データリクエストおよびレスポンスの例
</div>

<div id="example-post-request">
  ###### POST リクエストの例
</div>

* POST リクエストでは、リクエストパラメータは以下のように JSON 形式のボディとして送信されます。
* 検索対象とする PowerTrack ルールのすべての構成要素（キーワードや、bounding&#95;box: のような他のオペレーターなど）は、&#39;query&#39; パラメータに含めてください。
* クエリ URL で、ルールの一部を別々のパラメータとして分割しないでください。

以下は、初回のデータリクエストを行うための POST（cURL 使用）コマンドの例です。

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label.json" -d '{"query":"from:twitterDev","maxResults":500,"fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm"}'
```

API のデータレスポンスに「next」トークンが含まれている場合、以下は、元のリクエストに提供されたトークンを「next」パラメータとして設定した後続リクエストの例です。

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label.json" -d '{"query":"from:twitterDev","maxResults":500,"fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm",
    "next":"NTcxODIyMDMyODMwMjU1MTA0"}'
```

<div id="example-get-request">
  ###### GET リクエストの例
</div>

* GET リクエストのリクエストパラメータは、標準的な URL エンコード方式を使用して URL にエンコードされます。
* 取得対象の PowerTrack ルールのすべての要素（例: キーワードや、bounding&#95;box: のような他のオペレーター）は、&#39;query&#39; パラメータに含める必要があります。
* ルールの一部をクエリ URL 内で別個のパラメータとして分割しないでください。

以下は、初回のデータリクエストを行うための GET（cURL 使用）コマンドの例です。

```bash
    curl -u<username> "http://gnip-api.x.com/search/:product/accounts/:account_name/:label.json?query=from%3Atwitterdev&maxResults=500&fromDate=yyyymmddhhmm&toDate=yyyymmddhhmm"
```

<div id="example-data-responses">
  ###### データレスポンスの例
</div>

2022年9月29日以降に作成されたポストについては、その編集履歴を表すポスト編集メタデータがポストオブジェクトに含まれる点に注意してください。詳細については、[「Edit Tweets」](/ja/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets) の基本解説ページを参照してください。

以下はデータクエリに対するレスポンスの例です。この例では、利用可能なポストが「maxResults」を超えていたため、後続のリクエスト用に「next」トークンが提供されていることを前提としています。「maxResults」以下のポストしかクエリに関連付けられていない場合、レスポンスには「next」トークンは含まれません。
「next」要素の値はクエリごとに変更され、不透明な文字列として扱う必要があります。「next」要素はレスポンスボディ内で次のような形式になります。

```json
{
    "results":
      [
            {--Tweet 1--},
            {--Tweet 2--},
            ...
            {--Tweet 500--}
      ],
    "next":"NTcxODIyMDMyODMwMjU1MTA0",
    "requestParameters":
      {
        "maxResults":500,
        "fromDate":"201101010000",
        "toDate":"201201010000"
      }
  }
```

後続のリクエストに対するレスポンスは、次のようになります（新しいポストが追加され、&#39;next&#39; の値も異なっている点に注目してください）。

```json
{
      "results":
      [
            {--Tweet 501--},
            {--Tweet 502--},
            ...
            {--Tweet 1000--}
      ],
      "next":"R2hCDbpBFR6eLXGwiRF1cQ",
      "requestParameters":
      {
        "maxResults":500,
        "fromDate":"201101010000",
        "toDate":"201201010000"
      }
  }
```

クエリで指定した期間内のすべてのポストを取得するまで、前回のクエリのレスポンスで返された &#39;next&#39; 要素を引き続き渡すことができます。&#39;next&#39; 要素を含まないレスポンスを受け取った場合は、最後のページに到達しており、指定した期間内で利用可能な追加のデータはありません。

<div id="counts-endpoint">
  #### カウントエンドポイント
</div>

<div id="searchstreamcounts">
  ##### /search/:stream/counts
</div>

<div id="endpoint-pattern">
  ###### エンドポイントパターン:
</div>

`/search/fullarchive/accounts/:account_name/:label/counts.json`

このエンドポイントは、指定したクエリに対する件数（データボリューム）のデータを返します。期間が指定されていない場合、時間パラメータのデフォルトは直近30日間になります。データボリュームは、日次、時間単位（デフォルト）、または分単位のいずれかのタイムスタンプ付き配列として返されます。

**注:** この機能は、以下で説明するパラメータを URL にエンコードすることで、POST ではなく GET リクエストで実行することもできます。

<div id="counts-request-parameters">
  ##### 件数エンドポイントのリクエストパラメータ
</div>

| Parameters | Description | Required | Sample Value |
| :--- | :--- | :--- | :--- |
| query | 最大 2,048 文字まで指定できる 1 つの PowerTrack ルールに相当します（肯定句および否定句の数に制限はありません）。  <br />  <br />このパラメータには、すべてのオペレーターを含む PowerTrack ルールのすべての部分を含める必要があり、ルールの一部をクエリの他のパラメータに分割して指定してはいけません。  <br />  <br />**注:** すべての PowerTrack オペレーターがサポートされているわけではありません。サポートされているオペレーターの一覧については、[Available operators](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators) を参照してください。 | Yes | (snow OR cold OR blizzard) weather |
| fromDate | ポストが提供される最も古い UTC タイムスタンプ（2006/3/21 まで遡ります）を指定します。タイムスタンプは分単位の粒度で、指定した値を含みます（例: 12:00 は 00 分を含みます）。  <br />  <br />*指定した場合:* `fromDate` のみを指定し `toDate` パラメータを指定しない場合、API は現在から `fromDate` まで遡る期間について、クエリの件数（データボリューム）を返します。`fromDate` が現在より 31 日以上前の場合、リクエストをページングするための next トークンが返されます。  <br />  <br />*未指定の場合:* `fromDate` が指定されていない場合、API は現在（または `toDate` が指定されている場合はその `toDate`）から 30 日前までの件数（データボリューム）を返します。  <br />  <br />`fromDate` と `toDate` のいずれのパラメータも使用しない場合、API はリクエスト時点を起点として、直近 30 日間を過去に遡った期間の件数（データボリューム）を返します。 | No  | 201207220000 |
| toDate | ポストが提供される最新の UTC タイムスタンプを指定します。タイムスタンプは分単位の粒度ですが、指定した値は含みません（例: 11:59 はその時間の 59 分目を含みません）。  <br />  <br />*指定した場合:* `toDate` のみを指定し `fromDate` パラメータを指定しない場合、`toDate` から 30 日前までの最新の件数（データボリューム）を返します。  <br />  <br />*未指定の場合:* `toDate` が指定されていない場合、API はクエリについて、時間を遡って `fromDate` までの件数（データボリューム）を返します。`fromDate` が現在より 31 日以上前の場合、リクエストをページングするための next トークンが返されます。  <br />  <br />`fromDate` と `toDate` のいずれのパラメータも使用しない場合、API はリクエスト時点を起点として、直近 30 日間を過去に遡った期間の件数（データボリューム）を返します。 | No  | 201208220000 |
| bucket | 件数データが提供される時間の単位を指定します。指定した時間範囲内で、件数データは日単位、時間単位、分単位のいずれかで返されます。デフォルトでは時間単位の件数が返されます。オプション: &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39; | No  | minute |
| next | このパラメータは、[こちら](#Pagination) で説明しているように、結果の次の「ページ」を取得するために使用します。このパラメータに指定する値は、API が返すレスポンスから直接取得する必要があり、変更してはいけません。 | No  | NTcxODIyMDMyODMwMjU1MTA0 |

<div id="additional-details">
  ###### 追加の詳細
</div>

|     |     |
| :--- | :--- |
| **Available Timeframe** | 30-Day: 直近31日間  <br />Full-Archive: 2006年3月21日〜現在 |
| **Query Format** | 最大2,048文字の1つの PowerTrack ルールに相当します。  <br />  <br />**Note:** すべての PowerTrack 演算子がサポートされているわけではありません。サポートされている演算子の一覧については、[Available operators](/ja/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators) を参照してください。 |
| **Rate Limit** | パートナーには、分単位および秒単位の両方でレート制限が適用されます。1分あたりのレート制限は、契約書に記載されているとおりパートナーごとに異なります。ただし、これらの1分あたりのレート制限は、一度に使い切ることを想定したものではありません。1分あたりのレート制限にかかわらず、すべてのパートナーは、データおよび／または件数に対するすべてのリクエストを合計して、最大毎秒20リクエストに制限されます。 |
| **Count Precision** | このエンドポイントで返される件数は、実際に発生したポスト数を反映しており、その後に発生するコンプライアンスイベント（削除、scrub&#95;geo など）は反映されません。カウントされたポストの一部は、ユーザーによるコンプライアンスアクションにより、データエンドポイントからは取得できない場合があります。 |

<div id="example-counts-requests-and-responses">
  ##### Counts エンドポイントのリクエストおよびレスポンス例
</div>

<div id="example-post-request">
  ###### POST リクエストの例
</div>

* POST リクエストのリクエストパラメータは、以下に示すように JSON 形式のボディで送信されます。
* クエリ対象となる PowerTrack ルールのすべての構成要素（例: キーワード、bounding&#95;box: のような他のオペレーター）は、&#39;query&#39; パラメータに含めてください。
* クエリ URL 内で、ルールの要素を個別のパラメータとして分割しないでください。

以下は、初回の件数リクエストを行うための POST（cURL 使用）コマンドの例です。

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label/counts.json" -d '{"query":"TwitterDev","fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm","bucket":"day"}'
```

API の counts レスポンスに「next」トークンが含まれている場合、以下は後続リクエストの例です。元のリクエストの「next」パラメーターに、提供されたトークンを設定したものになります。

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label/counts.json" -d '{"query":"TwitterDev","fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm","bucket":"day",
    "next":"YUcxO87yMDMyODMwMjU1MTA0"}'
```

<div id="example-get-request">
  ###### GET リクエストの例
</div>

* GET リクエストのリクエストパラメータは、標準的な URL エンコード方式を用いて URL にエンコードされます
* 検索対象となる PowerTrack ルールのすべての要素（例: キーワード、`bounding_box:` などの他のオペレーター）は、`query` パラメータに含めてください
* ルールの一部を、クエリ URL 内で個別のパラメータとして分割しないでください

以下は、初回の件数取得リクエストを行うための GET（cURL 使用）コマンドの例です。

```bash
    curl -u<username> "http://gnip-api.x.com/search/fullarchive/accounts/:account_name/:label/counts.json?query=TwitterDev&bucket=day&fromDate=yyyymmddhhmm&toDate=yyyymmddhhmm"
```

<div id="example-counts-responses">
  #### 件数レスポンスの例
</div>

以下は、件数（データ量）のクエリに対するレスポンス例です。このレスポンス例には「next」トークンが含まれており、これは件数リクエストの対象期間が31日を超えているか、送信されたクエリに関連付けられたボリュームが大きく、部分的なレスポンスが返される条件を満たしていることを意味します。

「next」要素の値はクエリごとに変化し、不透明な文字列として扱う必要があります。「next」要素は、レスポンスボディ内では次のような形になります。

```json
    {
      "results": [
        { "timePeriod": "201101010000", "count": 32 },
        { "timePeriod": "201101020000", "count": 45 },
        { "timePeriod": "201101030000", "count": 57 },
        { "timePeriod": "201101040000", "count": 123 },
        { "timePeriod": "201101050000", "count": 134 },
        { "timePeriod": "201101060000", "count": 120 },
        { "timePeriod": "201101070000", "count": 43 },
        { "timePeriod": "201101080000", "count": 65 },
        { "timePeriod": "201101090000", "count": 85 },
        { "timePeriod": "201101100000", "count": 32 },
        { "timePeriod": "201101110000", "count": 23 },
        { "timePeriod": "201101120000", "count": 85 },
        { "timePeriod": "201101130000", "count": 32 },
        { "timePeriod": "201101140000", "count": 95 },
        { "timePeriod": "201101150000", "count": 109 },
        { "timePeriod": "201101160000", "count": 34 },
        { "timePeriod": "201101170000", "count": 74 },
        { "timePeriod": "201101180000", "count": 24 },
        { "timePeriod": "201101190000", "count": 90 },
        { "timePeriod": "201101200000", "count": 85 },
        { "timePeriod": "201101210000", "count": 93 },
        { "timePeriod": "201101220000", "count": 48 },
        { "timePeriod": "201101230000", "count": 37 },
        { "timePeriod": "201101240000", "count": 54 },
        { "timePeriod": "201101250000", "count": 52 },
        { "timePeriod": "201101260000", "count": 84 },
        { "timePeriod": "201101270000", "count": 120 },
        { "timePeriod": "201101280000", "count": 34 },
        { "timePeriod": "201101290000", "count": 83 },
        { "timePeriod": "201101300000", "count": 23 },
        { "timePeriod": "201101310000", "count": 12 }
       ],
      "totalCount":2027,
      "next":"NTcxODIyMDMyODMwMjU1MTA0",
      "requestParameters":
        {
          "bucket":"day",
          "fromDate":"201101010000",
          "toDate":"201201010000"
        }
    }
```

後続のリクエストに対するレスポンスは、次のようになります（新しい件数タイムラインと、異なる「next」の値に注目してください）:

```json
    {
      "results": [
        { "timePeriod": "201102010000", "count": 45 },
        { "timePeriod": "201102020000", "count": 76 },
         ....
        { "timePeriod": "201103030000", "count": 13 }
     ],
     "totalCount":3288,
     "next":"WE79fnakFanyMDMyODMwMjU1MTA0",
     "requestParameters":
        {
          "bucket":"day",
          "fromDate":"201101010000",
          "toDate":"201201010000"
        }
    }
```

前回のクエリで返された &#39;next&#39; 要素を指定し続けることで、クエリで指定した期間に含まれるすべての件数を取得できます。&#39;next&#39; 要素を含まないレスポンスを受信した場合は、最後のページに到達しており、その時間範囲内で利用可能な追加の件数がないことを意味します。

<div id="http-response-codes">
  #### HTTP response codes
</div>

| Status | Text | Description |
| :--- | :--- | :--- |
| 200 | OK  | リクエストは成功しました。JSON レスポンスは次の例と同様の形式になります。 |
| 400 | Bad Request | 一般的に、このレスポンスはリクエスト内に不正な JSON が含まれている場合、または JSON ペイロードがまったく送信されなかった場合に返されます。 |
| 401 | Unauthorized | 無効な認証情報のため、HTTP 認証に失敗しました。console.gnip.com にその認証情報でログインし、リクエストで正しく使用していることを確認してください。 |
| 404 | Not Found | リクエストが送信された URL 上にリソースが存在しません。多くの場合、誤った URL を使用していることが原因です。 |
| 422 | Unprocessable Entity | クエリ内のパラメータが無効である場合に返されます（例: 無効な PowerTrack ルール）。 |
| 429 | Unknown Code | アプリが接続リクエスト数の上限を超えました。対応する JSON メッセージは次の例と同様の形式になります。 |
| 500 | Internal Server Error | サーバー側でエラーが発生しました。指数バックオフ方式を用いてリクエストを再試行してください。 |
| 502 | Proxy Error | サーバー側でエラーが発生しました。指数バックオフ方式を用いてリクエストを再試行してください。 |
| 503 | Service Unavailable | サーバー側でエラーが発生しました。指数バックオフ方式を用いてリクエストを再試行してください。 |