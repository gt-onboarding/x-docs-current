---
title: はじめに
sidebarTitle: はじめに
keywords: ["powerstream", "powerstream API", "real-time streaming", "streaming rules", "filtered stream", "enterprise streaming", "GNIP powerstream"]
---

Powerstream は、公開されている X のデータにアクセスするための、最も高速なリアルタイムストリーミング API です。従来の GNIP Powetrack API と同様に、キーワード、オペレーター、メタデータに基づいてポストをフィルターするルールを使用します。Powerstream エンドポイントへの永続的な HTTP 接続が確立されると、条件に一致するポストをほぼリアルタイムで受信し始めることができます。

現在、Powerstream は最大 1,000 個のルールをサポートしており、各ルールは最大 2048 文字まで定義できます。

<div id="key-features">
  ## 主要機能:
</div>

* **リアルタイムなデータ配信**: ルールに一致するデータをほぼリアルタイムで取得できます。
* **高精度なフィルタリング**: 演算子付きのブール式クエリを使用して、必要なデータだけを正確にフィルタリングできます。
* **配信方式**: HTTP/1.1 のチャンク転送エンコーディングによる JSON レスポンス。
* **ローカルデータセンター対応**: レプリケーションラグを回避してレイテンシーを低減するため、ローカルデータセンターからのポストのみを取得できます。

<Note>
  Powerstream API は、特定の Enterprise プランで利用可能なプレミアムオファリングです。

  Powerstream へのアクセスや Enterprise オファリングの詳細に関心がある場合は、[Enterprise Request Form](/ja/forms/enterprise-api-interest) を送信して Sales チームまでお問い合わせください。
  Powerstream がどのようにお客様のニーズに対応できるか、喜んでご相談させていただきます。
</Note>

<div id="authentication">
  ## 認証
</div>

Powerstream API エンドポイントは OAuth 2.0 Bearer Token を使用します。`Authorization: Bearer <token>` ヘッダーに設定すると、これらのエンドポイントをすぐに利用できます。

<div id="quick-start">
  ## クイックスタート
</div>

このセクションでは、Python と `requests` ライブラリを使用して PowerStream エンドポイントをすぐに使い始める方法を紹介します。`pip install requests` でインストールしてください。すべてのサンプルでは OAuth 2.0 Bearer Token 認証を使用します。`YOUR_BEARER_TOKEN` を実際のトークンに置き換えてください（たとえば `os.getenv('BEARER_TOKEN')` のように、安全な方法で管理してください）。

各エンドポイントについてコードスニペットを用いて説明します。スクリプトの先頭で次の import が行われているものとします。

```python
import requests
import json
import time
import sys
import os  # 環境変数用
```

<div id="setup">
  ### セットアップ
</div>

```python
bearer_token = os.getenv('BEARER_TOKEN') or "YOUR_BEARER_TOKEN"  # セキュリティのため環境変数を使用
base_url = "https://api.x.com/2/powerstream"
rules_url = f"{base_url}/rules"  # ルール管理用
headers = {
   "Authorization": f"Bearer {bearer_token}",
   "Content-Type": "application/json"
}
```

<div id="1-create-rules-post-rules">
  ### 1. ルールを作成する (POST /rules)
</div>

ストリームをフィルタリングするためのルールを追加します。

```python
data = {
   "rules": [
       {
           "value": "(cat OR dog) lang:en -is:retweet",
           "tag": "pet-monitor"
       },
       # 必要に応じてルールを追加してください(最大100件)
   ]
}

response = requests.post(rules_url, headers=headers, json=data)
if response.status_code == 201:
   rules_added = response.json().get("data", {}).get("rules", [])
   print("ルールが追加されました:")
   for rule in rules_added:
       print(f"ID: {rule['id']}, Value: {rule['value']}, Tag: {rule.get('tag', 'N/A')}")
else:
   print(f"エラー {response.status_code}: {response.text}")
```

<div id="2-delete-rules-post-rules">
  ### 2. ルールの削除 (POST /rules)
</div>

id（推奨）または value を指定してルールを削除します。

```python
data = {
   "rules": [
       {
           "value": "(cat OR dog) lang:en -is:retweet",
           "tag": "pet-monitor"
       },
       # 必要に応じてルールを追加（最大100件まで）
   ]
}

response = requests.delete(rules_url, headers=headers, json=data)
if response.status_code == 200:
   deleted = response.json().get("data", {})
   print(f"Deleted count: {deleted.get('deleted', 'N/A')}")
   if 'not_deleted' in deleted:
       print("Not deleted:", deleted['not_deleted'])
else:
   print(f"Error {response.status_code}: {response.text}")
```

**ヒント**: すべてのルールを削除するには、まず GET リクエストで取得し、各ルールの `id` を抽出してから一括削除します。

<div id="3-get-rules-get-rules">
  ### 3. ルールの取得 (GET /rules)
</div>

現在有効なすべてのルールを取得します。

```python
response = requests.get(rules_url, headers=headers)
if response.status_code == 200:
   rules = response.json().get("data", {}).get("rules", [])
   if rules:
       print("Active rules:")
       for rule in rules:
           print(f"ID: {rule['id']}, Value: {rule['value']}, Tag: {rule.get('tag', 'N/A')}")
   else:
       print("No active rules.")
else:
   print(f"Error {response.status_code}: {response.text}")
```

<div id="4-powerstream-get-stream">
  ### 4. PowerStream (GET /stream)
</div>

リアルタイムのポストを受信するためにストリームに接続します。行単位で読み取るには `stream=True` を使用します。堅牢性のために再接続処理を実装してください。

```python
stream_url = base_url

def main():
   while True:
       response = requests.request("GET", stream_url, headers=headers, stream=True)
       print(response.status_code)
       for response_line in response.iter_lines():
           if response_line:
               json_response = json.loads(response_line)
               print(json.dumps(json_response, indent=4, sort_keys=True))
               if response.status_code != 200:
                   print(response.headers)
                   raise Exception(
                       "Request returned an error: {} {}".format(
                           response.status_code, response.text
                       )
                   )
```

<div id="local-datacenter-support">
  #### ローカルデータセンター対応
</div>

レイテンシを最適化するために、Powerstream では、接続が確立されたローカルデータセンターで生成されたポストのみを取得するオプションを提供しています。これによりレプリケーション遅延を回避し、他のデータセンターからのポストと比べて、より高速に配信できます。これを有効にするには、クエリパラメータ `?localDcOnly=true` をストリームエンドポイントに追加します（例: `/2/powerstream?localDcOnly=true`）。接続しているデータセンターは、ストリームの最初のデータペイロード内と、レスポンスの HTTP ヘッダーの両方で示されます。

コード内で使用するには:

```python
# ローカルデータセンターのみの場合:
stream_url = "https://api.x.com/2/powerstream?localDcOnly=true"
```

`localDcOnly` パラメーターが有効な場合、ストリームが最初に接続されるとき、使用されているローカルデータセンターを示す次のレスポンスヘッダーが含まれます。

```bash
'x-powerstream-datacenter': 'atla',
'x-powerstream-localdconly': 'true'
```

これに加えて、データセンターを指定する初期ペイロードも送信されます。

```bash
{
    "type": "connection_metadata",
    "datacenter": "atla",
    "timestamp": 1762557264155
}
```

<Note>
  **Tip:** レイテンシーを最適化するには、複数の地理的ロケーションから接続を設定し（例: 米国東海岸のアトランタ近郊と米国西海岸のポートランド近郊）、それぞれの接続で `localDcOnly=true` を有効にします。これにより、それぞれのデータセンターからのポストに高速にアクセスできます。自分側でこれらのストリームを集約し、データセンター間のデータを統合してください。
</Note>

<div id="operators">
  ## オペレーター
</div>

フィルタリングのルールを設定するには、キーワードとオペレーターを使用できます。利用可能なオペレーターの一覧を以下でご覧ください。

<div id="field-based-operators">
  ### フィールドベースの演算子
</div>

<div id="user-operators">
  #### ユーザー演算子
</div>

| Operator | Summary | Example |
|----------|---------|---------|
| `from:` | 特定のユーザーからのポストに一致します | `from:xdevelopers` または `from:123456` |
| `to:` | 特定のユーザー宛てのポストに一致します | `to:jvaleski` |
| `retweets_of:` | 特定のユーザーのリポストに一致します | `retweets_of:xdevelopers` |

<div id="content-operators">
  #### コンテンツ演算子
</div>

| Operator | Summary | Example |
|----------|---------|---------|
| `contains:` | 特定のテキスト／キーワードを含むポストに一致します | `contains:hello` または `contains:-2345.432` |
| `url_contains:` | URL が特定のテキストを含むポストに一致します | `url_contains:"com/willplayforfood"` |
| `lang:` | 特定の言語のポストに一致します | `lang:en` |

<div id="entity-operators">
  #### エンティティ演算子
</div>

| Operator | Summary | Example |
|----------|---------|---------|
| `has:` | 特定のエンティティを含むポストと一致します（指定可能な値: mentions, geo, links, media, lang, symbols, images, videos） | `has:images`, `has:geo`, `has:mentions` |
| `is:` | 特定の種類や特性を持つポストと一致します（指定可能な値: retweet, reply） | `is:retweet`, `is:reply` |

<div id="location-operators">
  #### ロケーション演算子
</div>

| Operator | Summary | Example |
|----------|---------|---------|
| `place:` | 特定の場所／ロケーションからのポストに一致するポストを検索します | `place:"Belmont Central"`, `place:02763fa2a7611cf3` |
| `bounding_box:` | 地理的なバウンディングボックス（矩形領域）内のポストに一致するポストを検索します | `bounding_box:[-112.424083 42.355283 -112.409111 42.792311]` |
| `point_radius:` | 指定した地点を中心とした半径内のポストに一致するポストを検索します | `point_radius:[-111.464973 46.371179 25mi]`, `point_radius:[-111.464973 46.371179 15km]` |

<div id="advancedcontent-operators">
  #### 高度な／コンテンツオペレーター
</div>

| Operator | Summary | Example |
|----------|---------|---------|
| `bio:` | 特定の自己紹介文（bio）を持つユーザーが投稿したポストにマッチします（フレーズ一致を使用） | N/A |
| `bio_name:` | 自己紹介文（bio）内に特定の名前を持つユーザーが投稿したポストにマッチします（フレーズ一致を使用） | N/A |

<div id="additional-operators">
  #### 追加の演算子
</div>

| Operator | Summary | Example |
|----------|---------|---------|
| `retweets_of_status_id:` | 特定のポストのリポストにマッチします | `retweets_of_status_id:1234567890123456789` |
| `in_reply_to_status_id:` | 特定のポストへの返信にマッチします | `in_reply_to_status_id:1234567890123456789` |

<div id="non-field-operators">
  ### フィールド非依存演算子
</div>

<div id="special-syntax-operators">
  #### 特殊構文の演算子
</div>

| 演算子 | 概要 | 例 |
|----------|---------|---------|
| `@` | メンション演算子 | `@username` |
| フレーズマッチング | フレーズの完全一致検索 | `"exact phrase"` |

<div id="logical-operators">
  #### 論理演算子
</div>

| Operator | Summary | Example |
|----------|---------|---------|
| `OR` | 式同士の論理 OR | `x OR facebook` |
| Space/AND | 式同士の論理 AND | `x facebook` (両方の検索語が含まれている必要があります) |
| `()` | 複雑な式のグループ化 | `(x OR facebook) iphone` |
| `-` | 否定／除外 | `x -facebook` (facebook を含まない x) |

<div id="responses">
  ## レスポンス
</div>

Powerstream API のペイロードは、レガシー GNIP Powertrack API と同じフォーマットです。JSON レスポンスの例を次に示します。

```json
[
   {
       "created_at": "Tue Mar 21 20:50:14 +0000 2006",
       "id": 20,
       "id_str": "20",
       "text": "twttrを設定中",
       "truncated": false,
       "entities": {
           "hashtags": [],
           "symbols": [],
           "user_mentions": [],
           "urls": []
       },
       "source": "<a href=\"http://x.com\" rel=\"nofollow\">X Web Client</a>",
       "in_reply_to_status_id": null,
       "in_reply_to_status_id_str": null,
       "in_reply_to_user_id": null,
       "in_reply_to_user_id_str": null,
       "in_reply_to_screen_name": null,
       "user": {
           "id": 12,
           "id_str": "12",
           "name": "jack",
           "screen_name": "jack",
           "location": "",
           "description": "no state is the best state",
           "url": "https://t.co/ZEpOg6rn5L",
           "entities": {
               "url": {
                   "urls": [
                       {
                           "url": "https://t.co/ZEpOg6rn5L",
                           "expanded_url": "http://primal.net/jack",
                           "display_url": "primal.net/jack",
                           "indices": [
                               0,
                               23
                           ]
                       }
                   ]
               },
               "description": {
                   "urls": []
               }
           },
           "protected": false,
           "followers_count": 6427829,
           "friends_count": 3,
           "listed_count": 32968,
           "created_at": "Tue Mar 21 20:50:14 +0000 2006",
           "favourites_count": 36306,
           "utc_offset": null,
           "time_zone": null,
           "geo_enabled": true,
           "verified": false,
           "statuses_count": 30134,
           "lang": null,
           "contributors_enabled": false,
           "is_translator": false,
           "is_translation_enabled": false,
           "profile_background_color": "EBEBEB",
           "profile_background_image_url": "http://abs.twimg.com/images/themes/theme7/bg.gif",
           "profile_background_image_url_https": "https://abs.twimg.com/images/themes/theme7/bg.gif",
           "profile_background_tile": false,
           "profile_image_url": "http://pbs.twimg.com/profile_images/1661201415899951105/azNjKOSH_normal.jpg",
           "profile_image_url_https": "https://pbs.twimg.com/profile_images/1661201415899951105/azNjKOSH_normal.jpg",
           "profile_banner_url": "https://pbs.twimg.com/profile_banners/12/1742427520",
           "profile_link_color": "990000",
           "profile_sidebar_border_color": "DFDFDF",
           "profile_sidebar_fill_color": "F3F3F3",
           "profile_text_color": "333333",
           "profile_use_background_image": true,
           "has_extended_profile": true,
           "default_profile": false,
           "default_profile_image": false,
           "following": null,
           "follow_request_sent": null,
           "notifications": null,
           "translator_type": "regular",
           "withheld_in_countries": []
       },
       "geo": null,
       "coordinates": null,
       "place": null,
       "contributors": null,
       "is_quote_status": false,
       "retweet_count": 122086,
       "favorite_count": 263321,
       "favorited": false,
       "retweeted": false,
       "lang": "en"
   }
]
```

<div id="limits-best-practices">
  ## 制限とベストプラクティス
</div>

* レート制限: ルール管理は 24時間あたり50リクエスト、ストリームには制限なし（ただし接続数の上限が適用されます）。
* 再接続: 切断時には指数バックオフ方式で再接続します。
* 監視: `Connection: keep-alive` ヘッダーを使用します。