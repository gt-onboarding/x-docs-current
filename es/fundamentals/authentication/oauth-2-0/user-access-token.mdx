---
title: Cómo conectarse a endpoints mediante el flujo de código de autorización de OAuth 2.0 con PKCE
sidebarTitle: OAuth 2.0 Realizar solicitudes en nombre de usuarios
keywords: ["token de acceso de usuario de OAuth 2.0", "token de acceso de usuario", "contexto de usuario de OAuth 2.0", "autenticación de usuario", "usuario de OAuth 2.0", "token de acceso"]
---

<div id="how-to-connect-to-endpoints-using-oauth-20-authorization-code-flow-with-pkce">
  ### Cómo conectarse a endpoints mediante el flujo de código de autorización de OAuth 2.0 con PKCE
</div>

<div id="how-to-connect-to-the-endpoints">
  #### Cómo conectarse a los endpoints
</div>

Para autenticar a tus usuarios, tu Aplicación deberá implementar un flujo de autorización. Este flujo de autorización te permite dirigir a tus usuarios a una pantalla de autorización en X. Desde allí, la experiencia principal de X mostrará la pantalla de autorización y gestionará la autorización en nombre de tu Aplicación. Tus usuarios podrán autorizar tu Aplicación o denegar el permiso. Una vez que el usuario tome su decisión, X redirigirá al usuario a tu Aplicación, donde podrás intercambiar el código de autorización por un token de acceso (si el usuario autorizó tu Aplicación) o gestionar un rechazo (si el usuario no autorizó tu Aplicación).

<div id="working-with-confidential-clients">
  #### Trabajo con clientes confidenciales
</div>

Si trabajas con clientes confidenciales, deberás usar un esquema de [autenticación básica](https://datatracker.ietf.org/doc/html/rfc2617#section-2) para generar un encabezado de autorización con codificación base64 al realizar solicitudes a los endpoints de token.

El `userid` y la `password` se separan mediante un solo carácter de dos puntos (&quot;:&quot;) dentro de una cadena codificada en base64 en las credenciales.

Un ejemplo sería:

`-header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='`

Si el agente de usuario desea enviar el Client ID &quot;Aladdin&quot; y la contraseña &quot;open sesame&quot;, usaría el siguiente campo de encabezado:

`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`

Para crear el encabezado de autorización básica, tendrás que aplicar codificación base64 a tu Client ID y Client Secret, que puedes obtener en la página &quot;Keys and Tokens&quot; de tu aplicación dentro del [portal para desarrolladores.](https://developer.x.com/en/portal/dashboard)

<div id="steps-to-connect-using-oauth-20">
  #### Pasos para conectarse usando OAuth 2.0
</div>

**Paso 1: Construir una URL de autorización**

Tu Aplicación deberá generar una URL de autorización a X, indicando los permisos (scopes) que tu Aplicación necesita autorizar. Por ejemplo, si tu Aplicación necesita consultar Publicaciones, usuarios y administrar seguimientos, debería solicitar los siguientes permisos:

`tweet.read%20users.read%20follows.read%20follows.write`

La URL también contendrá los parámetros `code_challenge` y state, además de los otros parámetros requeridos. En producción deberías usar una cadena aleatoria para el `code_challenge`.

**Paso 2: GET oauth2/authorize**

Haz que el usuario se autentique y envíe a la aplicación un código de autorización. Si has habilitado OAuth 2.0 para tu Aplicación, puedes encontrar tu Client ID dentro de la página “Keys and Tokens” de tu Aplicación.

Un ejemplo de URL a la que redirigir al usuario sería:

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20follows.read%20follows.write&state=state&code_challenge=challenge&code_challenge_method=plain
```

Un ejemplo de URL con offline&#95;access tendría este aspecto:

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20follows.read%20offline.access&state=state&code_challenge=challenge&code_challenge_method=plain
```

Tras una autenticación correcta, en el redirect&#95;uri recibirías una solicitud que contiene el parámetro auth&#95;code. Tu aplicación debe verificar el parámetro state.

Un ejemplo de solicitud procedente de la redirección del cliente sería:

```
https://www.example.com/?state=state&code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE
```

**Paso 3: POST oauth2/token - Token de acceso**

En este punto, puedes usar el código de autorización para crear un Token de acceso y un token de actualización (solo si se solicita el scope `offline.access`). Puedes realizar una solicitud POST al siguiente endpoint:

```
https://api.x.com/2/oauth2/token
```

Deberás pasar el `Content-Type` de `application/x-www-form-urlencoded` en un encabezado. Además, tu solicitud debe incluir: `code`, `grant_type`, `client_id` y `redirect_uri`, y el `code_verifier`.

Aquí tienes un ejemplo de solicitud de token para un cliente público:

```json
curl --location --request POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE' \
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ' \
--data-urlencode 'redirect_uri=https://www.example.com' \
--data-urlencode 'code_verifier=challenge'
```

A continuación se muestra un ejemplo con un cliente confidencial:

```json
curl --location --request POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE' \
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'redirect_uri=https://www.example.com' \
--data-urlencode 'code_verifier=challenge'
```

**Paso 4: Conectar con las API**

Ahora puedes conectarte a los endpoints usando OAuth 2.0. Para hacerlo, realizarás la solicitud a la API de la misma manera que lo harías usando la [autenticación con Bearer Token](/es/resources/fundamentals/authentication/oauth-2-0/application-only). En lugar de enviar tu Bearer Token, deberás usar el Token de acceso que generaste en el paso anterior. Como respuesta, deberías ver el payload correspondiente al endpoint que estás solicitando. Esta solicitud es la misma tanto para clientes públicos como para confidenciales. 

Un ejemplo de la solicitud que realizarías sería el siguiente:

```json
curl --location --request GET 'https://api.x.com/2/tweets?ids=1261326399320715264,1278347468690915330' \
--header 'Authorization: Bearer Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE'
```

**Paso 5: POST oauth2/token - refresh token**

Un refresh token permite que una Aplicación obtenga un nuevo Token de acceso sin solicitar la intervención del usuario. Puedes crear un refresh token realizando una solicitud POST al siguiente endpoint: [https://api.x.com/2/oauth2/token](https://api.x.com/2/oauth2/token). Deberás agregar el `Content-Type` `application/x-www-form-urlencoded` en un encabezado. Además, también deberás enviar tu `refresh_token`, establecer tu `grant_type` como `refresh_token` y definir tu `client_id`.

Esta solicitud funcionará para clientes públicos:

```json
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE' \
--data-urlencode 'grant_type=refresh_token' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ'
```

Este es un ejemplo para clientes confidenciales:

```json
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE'\
--data-urlencode 'grant_type=refresh_token'
```

**Paso 6: POST oauth2/revoke - Revocar el token**

Un token de revocación invalida un Token de acceso o un token de actualización. Se utiliza para habilitar una función de &quot;cierre de sesión&quot; en los clientes, lo que te permite eliminar cualquier credencial de seguridad asociada con el flujo de autorización que ya no sea necesaria. El token de revocación está pensado para que una Aplicación revoque un token y no un usuario. Puedes crear una solicitud de revocación de token realizando una solicitud POST a la siguiente URL si la Aplicación desea revocar de forma programática el acceso que se le ha otorgado:

```
https://api.x.com/2/oauth2/revoke
```

Deberás incluir el `Content-Type` de `application/x-www-form-urlencoded` en un encabezado, junto con tu token y tu client&#95;id.

En algunos casos, es posible que un usuario desee revocar el acceso otorgado a una Aplicación; puede hacerlo visitando la [página de Aplicaciones conectadas](https://x.com/settings/connected_apps).

```bash
curl --location --request POST 'https://api.x.com/2/oauth2/revoke' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'token=Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ'
```

Esta solicitud funcionará para clientes confidenciales:

```bash
curl --location --request POST 'https://api.x.com/2/oauth2/revoke' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'token=Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE'
```
