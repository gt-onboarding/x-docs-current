---
title: Mejores pr치cticas
keywords: ["mejores pr치cticas de autenticaci칩n", "mejores pr치cticas de OAuth", "mejores pr치cticas de seguridad", "seguridad de claves de API", "seguridad de tokens", "seguridad de autenticaci칩n"]
---

import { Button } from "/snippets/es/button.mdx";

Tus claves y tokens de API deben protegerse con mucho cuidado.

Estas credenciales est치n directamente vinculadas a tu [developer App](/es/resources/fundamentals/developer-apps) y a aquellas cuentas de X que te han autorizado a realizar solicitudes en su nombre. Si tus claves se ven comprometidas, actores malintencionados podr칤an usarlas para realizar solicitudes a los endpoints de X en nombre de tu aplicaci칩n de desarrollador o de sus usuarios autorizados, lo que podr칤a hacer que alcances l칤mites de frecuencia inesperados, agotes tu asignaci칩n de acceso de pago o incluso provoque que tu aplicaci칩n de desarrollador sea suspendida.

Las siguientes secciones incluyen pr치cticas recomendadas que deber칤an tenerse en cuenta al administrar tus claves y tokens de API.

<div id="regenerate-api-keys-and-tokens">
  ## Regenerar claves y tokens de API
</div>

Si consideras que tus claves de API se han expuesto, debes regenerarlas siguiendo estos pasos:

1. Accede a la [p치gina &quot;Projects and Apps&quot; del portal para desarrolladores](https://developer.x.com/en/portal/projects-and-apps.html).
2. Haz clic en el icono &quot;Keys and tokens&quot; (游딓 ) junto a la Aplicaci칩n correspondiente.
3. Haz clic en el bot칩n &quot;Regenerate&quot; junto al conjunto de claves y tokens que deseas regenerar.

Si prefieres regenerar tus Tokens de acceso o Bearer Tokens de forma program치tica, puedes hacerlo usando nuestros endpoints de autenticaci칩n.

* Si deseas regenerar tus Tokens de acceso, debes invalidar tus tokens usando el endpoint [POST oauth/invalidate&#95;token](/es/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) y luego regenerar tus tokens usando el [flujo OAuth de tres patas](/es/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens).
* Si deseas regenerar tu Bearer Token, debes invalidar tu token usando el endpoint [POST oauth2/invalidate&#95;token](/es/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) y luego regenerar tu token usando el endpoint [POST oauth2/token](/es/resources/fundamentals/authentication/api-reference#post-oauth2-token).

<div id="having-a-central-file-for-your-secrets">
  ## Tener un archivo central para tus secretos
</div>

Tener un archivo como un archivo .env u otro tipo de archivo .yaml para almacenar tus secretos puede ser 칰til, pero aseg칰rate de contar con un archivo .gitignore s칩lido que impida que los incluyas accidentalmente en un repositorio de Git.

<div id="environment-variables">
  ## Variables de entorno
</div>

Escribir c칩digo que utilice variables de entorno puede ser 칰til.

A continuaci칩n, se muestra un ejemplo en Python:

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

En tu terminal, escribe algo como lo siguiente:

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## C칩digo fuente y control de versiones
</div>

Los errores de seguridad m치s comunes que cometen los desarrolladores consisten en tener claves y tokens de API incluidos en el c칩digo fuente y confirmados en sistemas de control de versiones accesibles como GitHub y BitBucket. Muchos de estos repositorios de c칩digo son de acceso p칰blico. Este error se comete con tanta frecuencia en repositorios de c칩digo p칰blicos que existen bots muy rentables que rastrean en busca de claves de API.

* Usa variables de entorno del servidor. Al almacenar las claves de API en variables de entorno, las mantienes fuera de tu c칩digo y del control de versiones. Esto tambi칠n te permite usar f치cilmente diferentes claves para distintos entornos.
* Usa un archivo de configuraci칩n excluido del control de versiones. Agrega el nombre del archivo a tu archivo [.gitignore](https://git-scm.com/docs/gitignore) para excluirlo del seguimiento por parte del sistema de control de versiones.
* Si eliminas las claves de API de tu c칩digo despu칠s de haber usado el control de versiones, es probable que las claves de API sigan siendo accesibles mediante el acceso a versiones anteriores de tu base de c칩digo. Regenera tus claves de API, como se describe en la siguiente secci칩n.

<div id="databases">
  ## Bases de datos
</div>

Si necesitas almacenar tokens de acceso en una base de datos, ten en cuenta lo siguiente:

* Restringe el acceso a la base de datos de forma que los tokens de acceso solo sean legibles por el propietario del token.
* Restringe los privilegios de edici칩n/escritura en la tabla de la base de datos para los tokens de acceso; esto debe automatizarse con el sistema de gesti칩n de claves.
* Cifra los tokens de acceso antes de almacenarlos en cualquier almac칠n de datos.

<div id="password-management-tools">
  ## Herramientas de gesti칩n de contrase침as
</div>

Las herramientas de gesti칩n de contrase침as como 1Password o LastPass pueden ayudarte a mantener seguras tus claves y tokens. Es posible que quieras evitar compartir estas en el gestor de contrase침as compartido del equipo.

<div id="web-storage-cookies">
  ## Almacenamiento web y cookies
</div>

Hay dos tipos de almacenamiento web: LocalStorage y SessionStorage. Estos se crearon como mejoras con respecto al uso de cookies, ya que la capacidad de almacenamiento para el almacenamiento web es mucho mayor que la del almacenamiento mediante cookies. Sin embargo, cada una de estas opciones de almacenamiento tiene diferentes ventajas y desventajas.


**Almacenamiento web: LocalStorage**

Todo lo que se almacena en el almacenamiento web local es persistente. Esto significa que los datos persistir치n hasta que se eliminen expl칤citamente. Dependiendo de las necesidades de tu proyecto, puedes considerar esto como algo positivo. Sin embargo, debes tener cuidado al usar LocalStorage, ya que cualquier cambio o adici칩n a los datos estar치 disponible en todas las visitas futuras a la p치gina web en cuesti칩n. Por lo general, no recomendamos usar LocalStorage, aunque puede haber algunas excepciones. Si decides usar LocalStorage, es 칰til saber que admite la pol칤tica de mismo origen (same-origin policy), por lo que todos los datos almacenados aqu칤 solo estar치n disponibles a trav칠s del mismo origen. Una ventaja adicional de rendimiento al usar LocalStorage ser칤a una disminuci칩n del tr치fico cliente-servidor, dado que los datos no tienen que enviarse de vuelta al servidor para cada solicitud HTTP.


**Almacenamiento web: SessionStorage**

SessionStorage es similar a LocalStorage, pero la diferencia clave es que SessionStorage no es persistente. Una vez que se cierra la ventana (o pesta침a, seg칰n el navegador que est칠s usando) que se utiliz칩 para escribir en SessionStorage, los datos se perder치n. Esto es 칰til para restringir el acceso de lectura a tu token dentro de una sesi칩n de usuario. Usar SessionStorage suele ser m치s recomendable que LocalStorage cuando se piensa en t칠rminos de seguridad. Al igual que con LocalStorage, las ventajas de compatibilidad con la pol칤tica de mismo origen y la disminuci칩n del tr치fico cliente-servidor tambi칠n se aplican a SessionStorage.


**Cookies**

Las cookies son la forma m치s tradicional de almacenar datos de sesi칩n. Puedes establecer una fecha de expiraci칩n para cada cookie, lo que permite una revocaci칩n m치s sencilla y una restricci칩n del acceso. Sin embargo, el tr치fico cliente-servidor definitivamente aumentar치 al usar cookies, ya que los datos se env칤an de vuelta al servidor en cada solicitud HTTP. Si decides usar cookies, debes protegerte contra el secuestro de sesi칩n. De forma predeterminada, las cookies se env칤an en texto plano a trav칠s de HTTP, lo que hace que su contenido sea vulnerable al an치lisis de paquetes y/o a ataques de intermediario (man-in-the-middle), donde los atacantes pueden modificar tu tr치fico. Siempre debes aplicar HTTPS para proteger tus datos en tr치nsito. Esto proporcionar치 confidencialidad, integridad (de los datos) y autenticaci칩n. Sin embargo, si tu aplicaci칩n o sitio web est치 disponible tanto a trav칠s de HTTP como de HTTPS, tambi칠n querr치s usar el atributo &#39;Secure&#39; en la cookie. Esto evitar치 que los atacantes puedan enviar enlaces a la versi칩n HTTP de tu sitio a un usuario y capturar la solicitud HTTP resultante generada.

Otra defensa secundaria contra el secuestro de sesi칩n cuando se usan cookies ser칤a volver a validar la identidad del usuario antes de que se lleve a cabo cualquier acci칩n de alto impacto. Otro atributo a considerar para mejorar la seguridad de tus cookies ser칤a el atributo &#39;HttpOnly&#39;. Este atributo le indica al navegador que la cookie en cuesti칩n solo ser치 accesible desde el servidor especificado. Cualesquiera intentos realizados por scripts del lado del cliente ser치n prohibidos por este atributo, lo que ayuda a proteger contra la mayor칤a de los ataques de cross-site scripting (XSS).