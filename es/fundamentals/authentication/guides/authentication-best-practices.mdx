---
title: Mejores pr치cticas
keywords: ["mejores pr치cticas de autenticaci칩n", "mejores pr치cticas de OAuth", "mejores pr치cticas de seguridad", "seguridad de claves de API", "seguridad de tokens", "seguridad de la autenticaci칩n"]
---

import { Button } from "/snippets/es/button.mdx";

Tus claves y tokens de la API deben protegerse muy cuidadosamente.

Estas credenciales est치n directamente vinculadas a tu [aplicaci칩n de desarrollador](/es/resources/fundamentals/developer-apps) y a aquellas cuentas de X que te han autorizado a realizar solicitudes en su nombre. Si tus claves se ven comprometidas, actores maliciosos podr칤an usarlas para realizar solicitudes a los endpoints de X en nombre de tu aplicaci칩n de desarrollador o de sus usuarios autorizados, lo que podr칤a provocar que alcances l칤mites de frecuencia inesperados, agotes tu asignaci칩n de acceso de pago o incluso que tu aplicaci칩n de desarrollador sea suspendida.

Las siguientes secciones incluyen pr치cticas recomendadas que deben tenerse en cuenta al administrar tus claves y tokens de la API.

<div id="regenerate-api-keys-and-tokens">
  ## Regenerar claves y tokens de la API
</div>

En caso de que creas que tus claves de la API se han visto expuestas, debes regenerarlas siguiendo estos pasos:

1. Navega a la [p치gina &quot;Projects and Apps&quot; del portal para desarrolladores](https://developer.x.com/en/portal/projects-and-apps.html).
2. Haz clic en el icono &quot;Keys and tokens&quot; (游딓 ) junto a la Aplicaci칩n correspondiente.
3. Haz clic en el bot칩n &quot;Regenerate&quot; junto al conjunto de claves y tokens que quieres regenerar.

Si prefieres regenerar tus Tokens de acceso o tu Bearer Token de forma program치tica, puedes hacerlo usando nuestros endpoints de autenticaci칩n.

* Si quieres regenerar tus Tokens de acceso, primero debes invalidar tus tokens usando el endpoint [POST oauth/invalidate&#95;token](/es/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) y luego regenerar tus tokens usando el [flujo OAuth de tres patas](/es/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens).
* Si quieres regenerar tu Bearer Token, primero debes invalidar tu token usando el endpoint [POST oauth2/invalidate&#95;token](/es/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) y luego regenerar tu token usando el endpoint [POST oauth2/token](/es/resources/fundamentals/authentication/api-reference#post-oauth2-token).

<div id="having-a-central-file-for-your-secrets">
  ## Tener un archivo central para tus secretos
</div>

Tener un archivo como un archivo .env o cualquier otro tipo de archivo .yaml para guardar tus secretos es una opci칩n que puede ser 칰til, pero aseg칰rate de tener un archivo .gitignore s칩lido que evite que los incluyas accidentalmente en un commit a un repositorio de Git.

<div id="environment-variables">
  ## Variables de entorno
</div>

Escribir c칩digo que use variables de entorno puede ser 칰til.

A continuaci칩n se muestra un ejemplo en Python:

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

En tu terminal, deber칤as escribir algo como lo siguiente:

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## C칩digo fuente y control de versiones
</div>

Los errores de seguridad m치s comunes que cometen los desarrolladores consisten en dejar claves y tokens de API incluidos en el c칩digo fuente dentro de sistemas de control de versiones accesibles como GitHub y BitBucket. Muchos de estos repositorios de c칩digo son de acceso p칰blico. Este error se comete con tanta frecuencia en repositorios de c칩digo p칰blicos que existen bots que rastrean en busca de claves de API.

* Usa variables de entorno en el servidor. Al almacenar las claves de API en variables de entorno, las mantienes fuera de tu c칩digo y del control de versiones. Esto tambi칠n te permite usar f치cilmente distintas claves para diferentes entornos.
* Usa un archivo de configuraci칩n excluido del control de versiones. Agrega el nombre del archivo a tu archivo [.gitignore](https://git-scm.com/docs/gitignore) para excluirlo del seguimiento por parte del control de versiones.
* Si eliminas las claves de API de tu c칩digo despu칠s de haber usado el control de versiones, es probable que las claves de API sigan siendo accesibles al consultar versiones anteriores de tu c칩digo base. Regenera tus claves de API, como se describe en la siguiente secci칩n.

<div id="databases">
  ## Bases de datos
</div>

Si necesitas almacenar tus tokens de acceso en una base de datos, ten en cuenta lo siguiente:

* Restringe el acceso a la base de datos de forma que los tokens de acceso solo puedan ser le칤dos por el propietario del token.
* Restringe los privilegios de edici칩n/escritura en la tabla de la base de datos para los tokens de acceso; esto debe automatizarse con el sistema de gesti칩n de claves.
* Cifra los tokens de acceso antes de almacenarlos en cualquier sistema de almacenamiento de datos.

<div id="password-management-tools">
  ## Herramientas de gesti칩n de contrase침as
</div>

Las herramientas de gesti칩n de contrase침as como 1Password o LastPass pueden ser 칰tiles para mantener tus claves y tokens en un lugar seguro. Puede que prefieras no compartirlas dentro de una herramienta de gesti칩n de contrase침as compartida por el equipo.

<div id="web-storage-cookies">
  ## Almacenamiento web y cookies
</div>

Hay dos tipos de almacenamiento web: LocalStorage y SessionStorage. Estos se crearon como mejoras respecto al uso de cookies, ya que la capacidad de almacenamiento del almacenamiento web es mucho mayor que la del almacenamiento con cookies. Sin embargo, cada una de estas opciones de almacenamiento tiene diferentes ventajas y desventajas.


**Web Storage: LocalStorage**

Todo lo que se almacena en el almacenamiento web local es persistente. Esto significa que los datos permanecer치n hasta que se borren expl칤citamente. Dependiendo de las necesidades de tu proyecto, puedes considerar esto como algo positivo. Sin embargo, debes ser cuidadoso al usar LocalStorage, ya que cualquier cambio o adici칩n a los datos estar치 disponible en todas las visitas futuras a la p치gina web en cuesti칩n. Por lo general, no recomendamos usar LocalStorage, aunque puede haber algunas excepciones. Si decides usar LocalStorage, es 칰til saber que admite la pol칤tica de mismo origen (same-origin policy), por lo que todos los datos almacenados aqu칤 solo estar치n disponibles desde el mismo origen. Una ventaja de rendimiento adicional al usar LocalStorage ser칤a una disminuci칩n del tr치fico cliente-servidor, ya que los datos no tienen que enviarse de vuelta al servidor para cada solicitud HTTP.


**Web Storage: SessionStorage**

SessionStorage es similar a LocalStorage, pero la diferencia clave es que SessionStorage no es persistente. Una vez que se cierra la ventana (o pesta침a, seg칰n el navegador que est칠s usando) que se utiliz칩 para escribir en SessionStorage, los datos se perder치n. Esto es 칰til para restringir el acceso de lectura a tu token dentro de una sesi칩n de usuario. Usar SessionStorage suele ser m치s recomendable que LocalStorage cuando se piensa en t칠rminos de seguridad. Al igual que LocalStorage, las ventajas del soporte de la pol칤tica de mismo origen y la disminuci칩n del tr치fico cliente-servidor tambi칠n se aplican a SessionStorage.


**Cookies**

Las cookies son la forma m치s tradicional de almacenar datos de sesi칩n. Puedes establecer un tiempo de expiraci칩n para cada cookie, lo que facilita la revocaci칩n y la restricci칩n de acceso. Sin embargo, el tr치fico cliente-servidor definitivamente aumentar치 al usar cookies, ya que los datos se env칤an de vuelta al servidor para cada solicitud HTTP. Si decides usar cookies, debes protegerte contra el secuestro de sesi칩n. De forma predeterminada, las cookies se env칤an en texto plano sobre HTTP, lo que hace que su contenido sea vulnerable a la captura de paquetes (packet sniffing) y/o a ataques de intermediario (man-in-the-middle) en los que los atacantes pueden modificar tu tr치fico. Siempre debes exigir el uso de HTTPS para proteger tus datos en tr치nsito. Esto proporcionar치 confidencialidad, integridad (de los datos) y autenticaci칩n. Sin embargo, si tu aplicaci칩n o sitio web est치 disponible tanto mediante HTTP como HTTPS, tambi칠n querr치s usar la marca &quot;Secure&quot; en la cookie. Esto evitar치 que los atacantes puedan enviar enlaces a la versi칩n HTTP de tu sitio a un usuario y espiar la solicitud HTTP resultante que se genere.

Otra defensa secundaria contra el secuestro de sesi칩n cuando se usan cookies ser칤a volver a validar la identidad del usuario antes de llevar a cabo cualquier acci칩n de alto impacto. Otra marca a considerar para mejorar la seguridad de tus cookies ser칤a la marca &quot;HttpOnly&quot;. Esta marca le indica al navegador que la cookie en cuesti칩n solo ser치 accesible desde el servidor especificado. Cualquier intento realizado por scripts del lado del cliente quedar치 prohibido por esta marca, lo que ayuda a proteger contra la mayor칤a de los ataques de cross-site scripting (XSS).