---
title: Manejo de desconexiones
sidebarTitle: Manejo de desconexiones
keywords: ["desconexiones de streaming", "manejar desconexiones", "reconectar el stream", "reconexión del stream", "manejo de desconexiones", "errores de streaming"]
---

<div id="what-is-a-disconnection">
  ### ¿Qué es una desconexión?
</div>

Establecer una conexión con las APIs de streaming implica realizar una solicitud HTTPS de muy larga duración y procesar la respuesta de forma incremental. Al conectarte al endpoint de `filtered stream`, debes realizar una solicitud HTTPS y consumir el flujo resultante durante tanto tiempo como sea práctico. Nuestros servidores mantendrán la conexión abierta indefinidamente, salvo error del lado del servidor, latencia excesiva del lado del cliente, problemas de red, mantenimiento rutinario del servidor o inicios de sesión duplicados. Con las conexiones a endpoints de streaming es probable, y debe esperarse, que se produzcan desconexiones, por lo que se debe implementar lógica de reconexión.
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### Por qué una conexión de streaming podría desconectarse
</div>

Tu stream puede desconectarse por varias razones. Revisa el mensaje de error devuelto por el stream para entender el motivo de la falla. Los posibles motivos de desconexión son los siguientes:

* Un error de autenticación (como un token incorrecto o un método de autenticación equivocado).
* Se reinicia un servidor de streaming en el lado de X. Esto suele estar relacionado con un despliegue de código y, en general, deberías anticiparlo y tenerlo en cuenta en tu diseño.
* Tu cliente no se mantiene al día con el volumen de Publicaciones que el stream está entregando o está leyendo los datos demasiado lentamente. Cada conexión de streaming está respaldada por una cola de mensajes que se enviarán al cliente. Si esta cola crece demasiado con el tiempo, la conexión se cerrará.
* Tu cuenta excedió tu cuota diaria/mensual de Publicaciones.
* Tienes demasiadas conexiones redundantes activas.
* Un cliente deja de leer datos de repente. Si el ritmo de Publicaciones leídas desde el stream cae repentinamente, la conexión se cerrará.
* Posibles problemas de red entre el servidor y el cliente.
* Un problema temporal del lado del servidor, mantenimiento programado o actualizaciones. (Consulta la [página de estado](https://api.twitterstat.us/))
   

<div id="common-disconnection-errors-include">
  #### Entre los errores de desconexión más comunes se incluyen:
</div>

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "Esta transmisión ha sido desconectada upstream por razones operativas.",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "Este stream se encuentra actualmente en el límite máximo de conexiones permitidas.",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### Anticipar desconexiones y reconectar
</div>

Al transmitir Publicaciones en streaming, el objetivo es permanecer conectado el mayor tiempo posible, reconociendo que pueden producirse desconexiones. El endpoint proporciona una señal de keep-alive cada 20 segundos (aparecerá como un carácter de nueva línea). Usa esta señal para detectar si te estás desconectando.

1. Tu código debe detectar cuándo dejan de llegar tanto contenido nuevo como la señal de keep-alive.
2. Si eso ocurre, tu código debe activar una lógica de reconexión. Algunos clientes y lenguajes te permiten especificar un tiempo de espera de lectura (read timeout), que puedes configurar en 20 segundos.
3. Tu servicio debe detectar estas desconexiones y reconectarse lo antes posible.

Una vez que una conexión establecida se interrumpe, intenta reconectar inmediatamente. Si la reconexión falla, reduce la frecuencia de tus intentos de reconexión según el tipo de error experimentado:

* Aplica un backoff lineal para errores de red a nivel TCP/IP. Estos problemas suelen ser temporales y tienden a resolverse rápidamente. Aumenta el retraso entre reconexiones en 250 ms en cada intento, hasta 16 segundos.
* Aplica un backoff exponencial para errores HTTP en los que sea apropiado reconectar. Comienza con una espera de 5 segundos, duplicándola en cada intento, hasta 320 segundos.
* Aplica un backoff exponencial para errores HTTP 429 (Rate limit exceeded). Comienza con una espera de 1 minuto y duplícala en cada intento. Ten en cuenta que cada HTTP 429 recibido aumenta el tiempo que debes esperar hasta que el límite de frecuencia (rate limit) deje de estar en vigor para tu cuenta.
   

<div id="recovering-lost-data">
  #### Recuperar datos perdidos
</div>

Si experimentas una desconexión, hay distintas estrategias que puedes usar para asegurarte de recibir todos los datos que podrías haberte perdido. Hemos documentado algunos pasos clave que puedes seguir para recuperar los datos que se hayan omitido en nuestra guía de integración sobre [recuperación de datos](/es/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features). 
 

<div id="rate-limits-and-usage">
  #### Límites de frecuencia y uso
</div>

Para consultar los límites de conexión, la respuesta incluirá tres encabezados. Esto es útil para entender cuántas veces puedes usar el endpoint de reglas y cuántos intentos de reconexión se permiten para el endpoint de streaming.

* x-rate-limit-limit indica el número de solicitudes asignadas que tu cliente puede realizar durante la ventana de 15 minutos.

* x-rate-limit-remaining indica el número de solicitudes realizadas hasta el momento en la ventana de 15 minutos.

* x-rate-limit-reset es una marca de tiempo UNIX que indica cuándo se reiniciará la ventana de 15 minutos, restableciendo x-rate-limit-remaining a 0.

El endpoint de stream filtrado actualmente no informa sobre el uso. Para comprobar cuántas Publicaciones se han entregado, tu código puede implementar una lógica de medición, de modo que el consumo se pueda medir y pausar si es necesario. 

El código que hospeda el lado del cliente del stream simplemente inserta las Publicaciones entrantes en una cola de primero en entrar, primero en salir (FIFO), o una estructura de memoria similar; un proceso/hilo independiente debería consumir Publicaciones de esa cola para analizarlas y preparar el contenido para su almacenamiento. Con este diseño, puedes implementar un servicio que pueda escalar de forma eficiente en caso de que los volúmenes de Publicaciones entrantes cambien drásticamente. Conceptualmente, puedes pensar en ello como descargar un archivo infinitamente largo a través de HTTP.

<div id="reconnection-best-practices">
  #### Mejores prácticas de reconexión
</div>

**Probar estrategias de backoff**

Una buena manera de probar una implementación de backoff es usar credenciales de autorización no válidas y examinar los intentos de reconexión. Una buena implementación no debería recibir ninguna respuesta 429.

**Emitir alertas para múltiples reconexiones**

Si un cliente alcanza su umbral máximo de tiempo entre reconexiones, debe enviarte notificaciones para que puedas identificar y priorizar los problemas que afectan a tu conexión.

**Gestionar cambios de DNS**

Verifica que tu proceso cliente respete el tiempo de vida (TTL) de DNS. Algunas pilas almacenan en caché una dirección resuelta durante toda la ejecución del proceso y no aplican los cambios de DNS dentro del TTL establecido. Este almacenamiento en caché tan agresivo generará interrupciones del servicio en tu cliente cuando X redistribuya la carga entre direcciones IP.

**User Agent**

Asegúrate de que tu encabezado HTTP user-agent incluya la versión del cliente. Esto será fundamental para diagnosticar problemas en el lado de X. Si tu entorno impide configurar el campo user-agent, entonces establece un encabezado x-user-agent.