---
title: Manejo de desconexiones
sidebarTitle: Manejo de desconexiones
keywords: ["desconexiones de streaming", "manejar desconexiones", "reconectar el stream", "reconexión del stream", "manejo de desconexiones", "errores del stream"]
---

<div id="what-is-a-disconnection">
  ### ¿Qué es una desconexión?
</div>

Establecer una conexión con las APIs de streaming implica realizar una solicitud HTTPS de larga duración y procesar la respuesta de forma incremental. Al conectarte al endpoint filtered stream, debes realizar una solicitud HTTPS y consumir el flujo resultante durante todo el tiempo que sea práctico. Nuestros servidores mantendrán la conexión abierta indefinidamente, salvo que se produzca un error del lado del servidor, retraso excesivo del lado del cliente, problemas de red, mantenimiento rutinario del servidor o inicios de sesión duplicados. Con las conexiones a endpoints de streaming, es probable, y debe asumirse, que se produzcan desconexiones, por lo que debes implementar lógica de reconexión.
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### Por qué una conexión de streaming puede desconectarse
</div>

Tu stream puede desconectarse por varias razones. Revisa el mensaje de error devuelto por el stream para entender el motivo de la falla. Los posibles motivos de desconexión son los siguientes:

* Un error de autenticación (como un token incorrecto o un método de autenticación incorrecto en uso).
* Se reinicia un servidor de streaming del lado de X. Esto normalmente está relacionado con un despliegue de código y, en general, debe esperarse y contemplarse en el diseño.
* Tu cliente no está manteniendo el ritmo con el volumen de Publicaciones que el stream está entregando o está leyendo los datos demasiado lentamente. Cada conexión de streaming está respaldada por una cola de mensajes que se enviarán al cliente. Si esta cola crece demasiado con el tiempo, la conexión se cerrará.
* Tu cuenta superó tu cuota diaria/mensual de Publicaciones.
* Tienes demasiadas conexiones redundantes activas.
* Un cliente deja de leer datos de repente. Si la tasa de Publicaciones que se leen del stream cae repentinamente, la conexión se cerrará.
* Posibles problemas de red entre el servidor y el cliente.
* Un problema temporal del lado del servidor, como mantenimiento programado y actualizaciones. (Consulta la [página de estado](https://api.twitterstat.us/))
   

<div id="common-disconnection-errors-include">
  #### Entre los errores de desconexión más comunes se incluyen:
</div>

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "Esta transmisión ha sido desconectada upstream por razones operativas.",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "Este stream se encuentra actualmente en el límite máximo de conexiones permitidas.",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### Anticipar desconexiones y reconectar
</div>

Al hacer streaming de Publicaciones, el objetivo es permanecer conectado el mayor tiempo posible, reconociendo que pueden ocurrir desconexiones. El endpoint proporciona una señal de keep-alive cada 20 segundos (aparece como un carácter de nueva línea). Usa esta señal para detectar si te estás desconectando.

1. Tu código debe detectar cuándo dejan de llegar el contenido nuevo y la señal de keep-alive.
2. Si eso sucede, tu código debe activar una lógica de reconexión. Algunos clientes y lenguajes de programación te permiten especificar un tiempo de espera de lectura, que puedes configurar en 20 segundos.
3. Tu servicio debe detectar estas desconexiones y reconectar tan pronto como sea posible.

Una vez que una conexión establecida se interrumpe, intenta reconectar de inmediato. Si la reconexión falla, reduce la frecuencia de tus intentos de reconexión según el tipo de error experimentado:

* Aplica un backoff lineal ante errores de red a nivel TCP/IP. Estos problemas suelen ser temporales y tienden a resolverse rápidamente. Aumenta el retraso entre reconexiones en 250 ms en cada intento, hasta 16 segundos.
* Aplica un backoff exponencial ante errores HTTP para los que sea apropiado reconectar. Comienza con una espera de 5 segundos, duplicándola en cada intento, hasta 320 segundos.
* Aplica un backoff exponencial ante errores HTTP 429 Rate limit exceeded. Comienza con una espera de 1 minuto y duplícala en cada intento. Ten en cuenta que cada HTTP 429 recibido aumenta el tiempo que debes esperar hasta que el límite de frecuencia deje de estar en efecto para tu cuenta.
   

<div id="recovering-lost-data">
  #### Recuperar datos perdidos
</div>

Si experimentas una desconexión, puedes utilizar distintas estrategias para asegurarte de recibir todos los datos que se te hayan podido pasar por alto. Hemos documentado una serie de pasos clave que puedes seguir para recuperar los datos omitidos en nuestra guía de integración sobre [recuperación de datos](/es/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features). 
 

<div id="rate-limits-and-usage">
  #### Límites de frecuencia y uso
</div>

Para comprobar los límites de conexión, la respuesta incluirá tres encabezados. Esto es útil para entender cuántas veces puedes usar el endpoint de reglas y cuántos intentos de reconexión se permiten para el endpoint de streaming.

* x-rate-limit-limit indica el número de solicitudes asignadas que tu cliente puede realizar durante la ventana de 15 minutos.

* x-rate-limit-remaining indica el número de solicitudes realizadas hasta ahora en la ventana de 15 minutos.

* x-rate-limit-reset es una marca de tiempo UNIX que indica cuándo se reiniciará la ventana de 15 minutos, restableciendo x-rate-limit-remaining a 0.

El endpoint de flujo filtrado actualmente no informa datos de uso. Para comprobar cuántas Publicaciones se han entregado, tu código puede implementar una lógica de medición, de modo que el consumo pueda medirse y pausarse si es necesario. 

El código que aloja el lado cliente del flujo simplemente inserta las Publicaciones entrantes en una cola de primero en entrar, primero en salir (FIFO) o una estructura de memoria similar; un proceso/hilo separado debería consumir las Publicaciones de esa cola para analizarlas y preparar el contenido para su almacenamiento. Con este diseño, puedes implementar un servicio que pueda escalar de forma eficiente en caso de que los volúmenes de Publicaciones entrantes cambien drásticamente. Conceptualmente, puedes pensar en ello como descargar un archivo infinitamente largo a través de HTTP.

<div id="reconnection-best-practices">
  #### Mejores prácticas de reconexión
</div>

**Probar estrategias de backoff**

Una buena forma de probar una implementación de backoff es usar credenciales de autorización no válidas y examinar los intentos de reconexión. Una buena implementación no recibirá ninguna respuesta 429.

**Generar alertas para múltiples reconexiones**

Si un cliente alcanza su umbral máximo de tiempo entre reconexiones, debe enviarte notificaciones para que puedas priorizar y diagnosticar los problemas que están afectando tu conexión.

**Gestionar cambios de DNS**

Prueba que el proceso de tu cliente respete el valor de tiempo de vida (TTL) de DNS. Algunos stacks almacenan en caché una dirección resuelta durante toda la ejecución del proceso y no detectan cambios de DNS dentro del TTL establecido. Un almacenamiento en caché tan agresivo provocará interrupciones del servicio en tu cliente cuando X cambie la carga entre direcciones IP.

**User Agent**

Asegúrate de que tu encabezado HTTP User-Agent incluya la versión del cliente. Esto será fundamental para diagnosticar problemas en X. Si tu entorno no permite configurar el campo User-Agent, entonces configura un encabezado X-User-Agent.