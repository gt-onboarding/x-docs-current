---
title: 安全性
icon: lock
keywords: ["安全性", "API 安全性", "开发者安全", "安全编码", "OAuth 安全性", "API 密钥安全", "令牌安全", "XSS", "CSRF", "SQL 注入", "加密", "TLS", "漏洞报告", "安全最佳实践"]
---

我们坚信隐私是一项权利，而非特权，并已深深融入我们公司的基础。通过使用 X 开发者平台并遵守我们的开发者政策，你在确保平台服务于 X 上的公共对话以及维护我们对隐私的承诺方面发挥着至关重要的作用。

我们希望提醒你，以安全方式进行构建对于保护你自身以及你的应用用户的数据十分重要。你有责任防范安全漏洞的威胁，而我们共同承担着保护使用 X 的人的责任。本页面说明了在构建安全应用以及尽可能保障数据和访问安全方面的相关期望。

<Note>请了解 X 开发者平台可用的安全技术，包括[身份验证](/zh/resources/fundamentals/authentication)、TLS 和[应用权限](/zh/resources/fundamentals/developer-apps#app-permissions)，以及面向 X 用户、关于[使用第三方应用和会话](https://help.x.com/en/managing-your-account/connect-or-revoke-access-to-third-party-apps)的相关内容。</Note>

<div id="reporting-security-issues">
  ## 报告安全问题
</div>

X Developer Platform 用户在初步怀疑发生安全事件后的 48 小时内，必须通过 [X 的漏洞报告计划](https://hackerone.com/twitter) 通知 X。

<div id="security-best-practices">
  ## 安全最佳实践
</div>

在你使用 X 开发者平台进行构建时，以及在互联网上的其他环境中，请始终牢牢记住这些安全最佳实践。

<div id="security-by-design">
  ### 安全设计理念
</div>

考虑聘请安全专业人员开展威胁建模审计和/或渗透测试。优秀的安全服务公司会深入挖掘并发现潜在问题。要了解 X 如何践行这一理念，请参阅[我们的博文](https://blog.x.com/en_us/topics/company/2019/privacy_data_protection.html)。

此外，X 要求所有合作伙伴对以下事项负责：

* 在安全的代码仓库中维护代码。
* 在整个系统开发生命周期（SDLC）过程中开展风险分析。
* 确保在整个 SDLC 过程中识别并缓解安全问题。
* 确保在 SDLC 过程中对各环境进行隔离。
* 确保所有测试缺陷都已修复、重新测试并最终关闭。

<div id="monitor-and-get-alerted">
  ### 监控与告警
</div>

如果你觉得自己的 Web 应用可能出了问题，该如何确认呢？务必做好日志记录，并确保在发生关键异常和错误时能够收到通知。你可能还希望搭建一个展示关键统计数据的仪表盘，这样就可以一目了然地判断是否有问题发生。

<div id="create-a-reporting-channel">
  ### 创建报告渠道
</div>

让你的用户可以方便地联系你，反馈他们在你的应用中遇到的潜在安全问题。如果发现了影响 X 用户和数据的问题，你同样有责任[向 X 报告此问题](#report)。如果发生安全事件，应事先制定好通知受影响用户的行动计划或流程。

<div id="adequate-testing">
  ### 充分测试
</div>

确保你的端到端测试足够全面，并已更新以覆盖安全场景中的预期失败情况，例如未授权访问。将自己置于攻击者的思维模式，设计系统测试，以按预期阻止攻击者对 X 数据或获授权功能进行未授权访问。

<div id="securing-api-keys-and-tokens">
  ### 保护 API 密钥和令牌
</div>

作为 X 平台上的开发者，在你的开发者应用已获授权的前提下，你可以通过编程方式访问由 X 存储的你自己的数据以及用户的数据。所有 API 请求都必须使用开发者应用的密钥和密钥秘钥（key 和 secret），并在某些情况下使用授权用户的[访问令牌](/zh/resources/fundamentals/authentication)，通过 OAuth 进行[认证](/zh/resources/fundamentals/authentication)。你有责任确保自己的凭证安全。

一些推荐的最佳实践包括：

* 制定密码/令牌的定期刷新轮换策略。
* 按需对敏感数据进行加密，并避免在过早的上游环节解密数据。
* 将用户的访问令牌存储在加密存储中。
* 如果你认为密钥和令牌已遭泄露，请[重新生成](/zh/resources/fundamentals/authentication#regenerate-api-keys-and-tokens)或[使其失效](/zh/resources/fundamentals/authentication#post-oauth2-invalidate-token)。

如需查看更多关于在 X 上使用 OAuth 进行调试和构建的讨论，请访问社区论坛中的[安全板块](https://devcommunity.x.com/c/oauth/12)。

<div id="input-validation">
  ### 输入验证
</div>

不要假设你的用户提供的数据都是有效且可信的。对所有来自用户、且可能最终用于 X API 请求的数据进行清洗和校验。使用允许列表明确你的应用可以接受的输入类型，并丢弃所有不在允许列表中的内容。

<div id="encrypted-communication">
  ### 加密通信
</div>

X 要求所有 API 请求都必须通过 TLS 进行传输。与您自有服务器之间的通信也应在条件允许的情况下尽量使用加密传输。

<div id="exposed-debugging-information">
  ### 暴露的调试信息
</div>

务必确保你不会通过调试界面或日志泄露敏感的 X 数据或凭证。如果你的应用未正确配置，一些 Web 框架会让访问调试信息变得非常容易。对于桌面端和移动端开发者来说，也很容易在启用调试标志或符号的情况下不小心打包并发布构建版本。请在部署/构建流程中加入对这些配置的检查。此外，如果你需要共享堆栈跟踪或崩溃转储用于问题上报，请确保对 X 私有用户的数据进行脱敏处理。

<div id="unfiltered-input-unescaped-output">
  ### 未过滤的输入，未转义的输出
</div>

一种易于记忆的输入验证方法是 FIEO：Filter Input（过滤输入）、Escape Output（转义输出）。

过滤所有来自你的应用程序外部的内容，包括 X API 数据、cookie 数据、用户提供的表单输入、URL 参数、来自数据库的数据等。对你的应用程序发送的所有输出进行转义，包括发送到数据库服务器的 SQL、你发送到用户浏览器的 HTML、发送到其他系统的 JSON 输出，以及发送给 shell 程序的命令。

<div id="cross-site-scripting-xss">
  ### 跨站脚本（XSS）
</div>

按照大多数统计，[XSS](https://owasp.org/) 攻击是 Web 上最常见的安全问题之一。如果攻击者能够将其自己的 JavaScript 代码注入到你的应用中，他们就可以做出许多恶意操作。任何存储并展示不受信任用户输入数据的地方，都需要进行检查、清理，并做 HTML 转义处理。要做到万无一失非常困难，因为黑客有[许多不同的方式实施 XSS 攻击](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting)。你的编程语言或 Web 开发框架很可能已经提供了流行且经过充分验证的跨站脚本防御机制；请务必使用它。

<div id="sql-injection">
  ### SQL 注入
</div>

如果你的应用使用了数据库，你需要了解[SQL 注入](http://en.wikipedia.org/wiki/SQL_injection)。只要存在接受输入的地方，就有可能成为攻击者的目标：攻击者可能会试图从输入字段「逃逸」，进而侵入你的数据库。请使用能够系统性防范 SQL 注入的数据库访问库。如果你偏离这种方式并编写自定义 SQL，一定要编写严格的测试，确保自己没有暴露在这种攻击形式之下。防御 SQL 注入的两种主要方法是：在构造 SQL 语句前对输入进行转义，以及使用参数化输入来创建语句。推荐使用后者，因为它更不容易出现程序员失误。

<div id="cross-site-request-forgery-csrf">
  ### 跨站请求伪造（CSRF）
</div>

你是否确信所有发往你的应用的请求，确实都来自你的应用本身？[CSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) 攻击会利用这种不确定性，强迫你网站中已登录的用户在不知情的情况下打开执行某些操作的 URL。在开发者应用的场景下，这可能意味着攻击者利用你的应用强迫用户发布不想要的帖子或关注垃圾账号。

应对 CSRF 最彻底的方式，是在每个表单中包含一个随机 token，并将其保存在某个可信位置；如果表单没有正确的 token，就抛出错误。现代 Web 框架有系统化的处理方式，如果足够幸运，框架甚至可能默认已经在帮你做这件事。一个简单的预防措施（但绝不是你应该采取的唯一步骤）是：要求所有创建、修改或删除数据的操作，都必须通过 POST 请求来完成。

<div id="lack-of-rate-limiting">
  ### 缺乏速率限制
</div>

在适当的情况下使用 CAPTCHA 来减缓潜在垃圾信息发送者和攻击者的操作速度。

***

<Info>
  如果你发现了直接影响 X 本身的安全问题，我们提供了一个[漏洞赏金计划](https://hackerone.com/twitter)。
</Info>