---
title: 创建签名
sidebarTitle: 创建签名
keywords: ["OAuth 签名", "创建签名", "OAuth 1.0a 签名", "HMAC 签名", "签名生成", "OAuth 签名"]
---

import { Button } from "/snippets/zh/button.mdx";

<div id="creating-a-signature">
  ### 创建签名
</div>

本文说明如何为一个 HTTP 请求生成 OAuth 1.0a HMAC-SHA1 签名。该签名可作为已授权请求的一部分传递给 X API，具体如[授权请求](/zh/resources/fundamentals/authentication/oauth-1-0a/authorizing-a-request)中所述。

用于演示签名的请求是一个发往 [https://api.x.com/1.1/statuses/update.json](https://api.x.com/1.1/statuses/update.json) 的 POST 请求。原始请求如下所示：

```
POST /1.1/statuses/update.json?include_entities=true HTTP/1.1
Accept: */*
Connection: close
User-Agent: OAuth gem v0.4.4
Content-Type: application/x-www-form-urlencoded
Content-Length: 76
Host: api.x.com

status=Hello%20Ladies%20%2b%20Gentlemen%2c%20a%20signed%20OAuth%20request%21
```

**收集请求方法和 URL**

要生成签名，首先要确定请求的 HTTP 方法和 URL。这两项在创建请求时都是已知的，因此很容易确定。

对于 X API 请求，请求方法几乎总是 GET 或 POST。

|             |      |
| :---------- | :--- |
| HTTP Method | POST |

基本 URL 是请求所发送到的 URL，去除任何查询字符串或哈希（#）参数。这里使用正确的协议非常重要，因此请确保 URL 中的“https://”部分与实际发送到 API 的请求相匹配。

|          |                                                                                          |
| :------- | :--------------------------------------------------------------------------------------- |
| Base URL | [https://api.x.com/1.1/statuses/update.json](https://api.x.com/1.1/statuses/update.json) |

<div id="collecting-parameters">
  #### 收集参数
</div>

接下来，收集请求中包含的所有参数。这些附加参数会出现在两个位置：URL（作为查询字符串的一部分）和请求体。示例请求在这两个位置各包含一个参数：

```
POST /1.1/statuses/update.json?include_entities=true HTTP/1.1
Accept: */*
Connection: close
User-Agent: OAuth gem v0.4.4
Content-Type: application/x-www-form-urlencoded
Content-Length: 76
Host: api.x.com

status=Hello%20Ladies%20%2b%20Gentlemen%2c%20a%20signed%20OAuth%20request%21
```

一个 HTTP 请求包含经过 URL 编码的参数，但你应当收集其原始值。除了请求参数之外，每个 oauth&#95;* 参数也需要包含在签名中，因此也要将它们收集起来。以下是来自[授权请求](/zh/resources/fundamentals/authentication/oauth-1-0a/authorizing-a-request)中的参数：

|                                |                                                    |
| :----------------------------- | :------------------------------------------------- |
| status                         | Hello Ladies + Gentlemen, a signed OAuth request!  |
| include&#95;entities           | true                                               |
| oauth&#95;consumer&#95;key     | xvz1evFS4wEEPTGEFPHBog                             |
| oauth&#95;nonce                | kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg         |
| oauth&#95;signature&#95;method | HMAC-SHA1                                          |
| oauth&#95;timestamp            | 1318622958                                         |
| oauth&#95;token                | 370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb |
| oauth&#95;version              | 1.0                                                |

这些值需要被编码成一个单个字符串，稍后会用到。构建该字符串的过程有严格的步骤：

1. 对每一个将被签名的键和值进行[百分号编码（percent encode）](/zh/resources/fundamentals/authentication/oauth-1-0a/percent-encoding-parameters)。
2. 按照编码后的键的字母顺序 [[1]](/zh/resources/fundamentals/authentication/oauth-1-0a/creating-a-signature) 对参数列表进行排序 [[2]](/zh/resources/fundamentals/authentication/oauth-1-0a/creating-a-signature)。
3. 对每个键/值对：
4. 将编码后的键追加到输出字符串中。
5. 将字符 ‘=’ 追加到输出字符串中。
6. 将编码后的值追加到输出字符串中。
7. 如果还有剩余的键/值对，则在输出字符串末尾追加一个 ‘&amp;’ 字符。
    

[1] OAuth 规范要求按字典序（lexicographically）排序，这也是许多库的默认字母排序方式。

[2] 对于两个具有相同编码键的参数，OAuth 规范要求继续根据值进行排序。然而，X 在 API 请求中不接受重复键。
 

**参数字符串（Parameter string）**

对上述收集的参数重复这些步骤将生成以下 *参数字符串*：

| status                   | Hello Ladies + Gentlemen, a signed OAuth request!  |
| :----------------------- | :------------------------------------------------- |
| `include_entities`       | true                                               |
| `oauth_consumer_key`     | xvz1evFS4wEEPTGEFPHBog                             |
| `oauth_nonce`            | kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg         |
| `oauth_signature_method` | HMAC-SHA1                                          |
| `oauth_timestamp`        | 1318622958                                         |
| `oauth_token`            | 370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb |
| `oauth_version`          | 1.0                                                |

<div id="creating-the-signature-base-string">
  #### 创建签名基础字符串
</div>

目前收集到的三个值必须连接成一个字符串，签名将从该字符串生成。根据 OAuth 规范，这被称为 **signature base string（签名基础字符串）**。

要将 HTTP 方法、基础 URL 和参数字符串编码为一个字符串：

1. 将 HTTP 方法转换为大写，并将输出字符串的初始值设为该值。
2. 在输出字符串后追加字符 ‘&amp;’。
3. 对 URL 进行[百分号编码](/zh/resources/fundamentals/authentication/oauth-1-0a/percent-encoding-parameters)，并将其追加到输出字符串。
4. 在输出字符串后追加字符 ‘&amp;’。
5. 对参数字符串进行[百分号编码](/zh/resources/fundamentals/authentication/oauth-1-0a/percent-encoding-parameters)，并将其追加到输出字符串。
    

这会生成如下的 *signature base string（签名基础字符串）*：

```
POST&https%3A%2F%2Fapi.x.com%2F1.1%2Fstatuses%2Fupdate.json&include_entities%3Dtrue%26oauth_consumer_key%3Dxvz1evFS4wEEPTGEFPHBog%26oauth_nonce%3DkYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1318622958%26oauth_token%3D370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb%26oauth_version%3D1.0%26status%3DHello%2520Ladies%2520%252B%2520Gentlemen%252C%2520a%2520signed%2520OAuth%2520request%2521
```

请确保对参数字符串进行百分号编码（percent-encode）。签名基字符串必须恰好包含 2 个与号 ‘&amp;’ 字符。参数字符串中的百分号 ‘%’ 在签名基字符串中应编码为 %25。

<div id="getting-a-signing-key">
  #### 获取签名密钥
</div>

最后需要收集的几项数据是用于标识发出请求的 [X app](/zh/resources/fundamentals/developer-apps) 以及该请求所代表用户的机密信息。务必注意，这些值极为敏感，绝不应与任何人共享。

用于在 X 端标识你的应用的值称为 **consumer secret**，可以在 [developer portal](/zh/resources/fundamentals/developer-portal) 中打开 [app details page](/zh/resources/fundamentals/developer-apps) 查看。对于你的 X 应用发出的每个请求，这个值都是相同的。

|     |     |
| :--- | :--- |
| Consumer secret（消费者密钥） | kAcSOqF21Fu85e7zjz7ZN2U4ZRhfV3WpwPAoE3Z7kBw |

用于标识你的应用代表其执行操作的账号的值称为 **OAuth token secret**。该值可以通过多种方式获取，所有方式都在 [obtaining access tokens](/zh/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens) 中进行了说明。

|     |     |
| :--- | :--- |
| OAuth token secret（OAuth 令牌密钥） | LswwdoUaIvS8ltyTt5jkRh4J50vUPVVHtR2YPi5kE |

再次强调，务必对这些值严格保密，仅在你的应用内部使用。如果你认为这些值已遭泄露，请重新生成你的令牌（本页展示的令牌已被标记为对真实请求无效）。

需要将这两个值组合起来，形成一个用于生成签名的 **signing key**。签名密钥就是 [percent encoded](/zh/resources/fundamentals/authentication/oauth-1-0a/percent-encoding-parameters) 的令牌密钥：

请注意，在某些流程中（例如获取 [request token](/zh/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens) 时），令牌密钥尚未确定。在这种情况下，签名密钥应由 [percent encoded](/zh/resources/fundamentals/authentication/oauth-1-0a/percent-encoding-parameters) 的 **consumer secret**，后跟一个与号字符 “&amp;” 组成。

|     |     |
| :--- | :--- |
| Signing key（签名密钥） | kAcSOqF21Fu85e7zjz7ZN2U4ZRhfV3WpwPAoE3Z7kBw&amp;LswwdoUaIvS8ltyTt5jkRh4J50vUPVVHtR2YPi5kE |

<div id="calculating-the-signature">
  #### 计算签名
</div>

最后，通过将签名基础字符串和签名密钥传递给 HMAC-SHA1 哈希算法来计算签名。该算法的详细说明可参考 hash&#95;hmac 函数。

HMAC 签名函数的输出是一个二进制字符串。需要对其进行 Base64 编码以生成签名字符串。例如，在本页给定的基础字符串和签名密钥下，输出为 2E CF 77 84 98 99 6D 0D DA 90 5D C7 17 7C 75 07 3F 3F CD 4E。该值在转换为 Base64 后，就是此请求的 OAuth 签名：

|     |     |
| :--- | :--- |
| OAuth signature | Ls93hJiZbQ3akF3HF3x1Bz8/zU4= |