---
title: 最佳实践
keywords: ["身份验证最佳实践", "OAuth 最佳实践", "安全最佳实践", "API 密钥安全", "令牌安全", "身份验证安全"]
---

import { Button } from "/snippets/zh/button.mdx";

你应当非常谨慎地保护你的 API 密钥和令牌。 

这些凭证与你的 [developer App](/zh/resources/fundamentals/developer-apps) 以及那些已授权你代表其发起请求的 X 账号直接关联。如果你的密钥被泄露，恶意方可能会使用它们代表你的 developer App 或其授权用户向 X 端点发起请求，这可能会导致你意外触发速率限制、耗尽你的付费访问配额，甚至导致你的 developer App 被暂停使用。

以下章节包含在管理你的 API 密钥和令牌时应当考虑的最佳实践。

<div id="regenerate-api-keys-and-tokens">
  ## 重新生成 API 密钥和令牌
</div>

如果你认为自己的 API 密钥已经泄露，你应该按照以下步骤重新生成 API 密钥：

1. 前往 [开发者门户的 “Projects and Apps” 页面](https://developer.x.com/en/portal/projects-and-apps.html)。
2. 点击相关应用旁边的 “Keys and tokens” 图标 (🗝 )。
3. 点击你希望重新生成的那组密钥和令牌旁边的 “Regenerate” 按钮。 

如果你希望以编程方式重新生成访问令牌或 Bearer Token，你可以使用我们的身份验证端点来实现。

* 如果你希望重新生成访问令牌，你必须先使用 [POST oauth/invalidate&#95;token](/zh/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) 端点使现有令牌失效，然后通过 [三方 OAuth 流程](/zh/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens) 重新生成令牌。
* 如果你希望重新生成 Bearer Token，你必须先使用 [POST oauth2/invalidate&#95;token](/zh/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) 端点使现有令牌失效，然后通过 [POST oauth2/token](/zh/resources/fundamentals/authentication/api-reference#post-oauth2-token) 端点重新生成令牌。

<div id="having-a-central-file-for-your-secrets">
  ## 为你的机密信息准备一个集中管理的文件
</div>

使用一个文件（例如 .ENV 文件或其他类型的 .yaml 文件）来存放你的机密信息是一个可能非常有用的做法，但务必确保有配置完善的 .gitignore 文件，以防不小心将这些内容提交到 git 仓库中。 

<div id="environment-variables">
  ## 环境变量
</div>

编写利用环境变量的代码会很有帮助。 

下面是一个使用 Python 的示例：

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

在终端中，你可以输入类似下面的命令：

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## 源代码与版本控制
</div>

开发者最常见的安全错误之一，是将 API 密钥和令牌连同源代码一起提交到诸如 GitHub 和 BitBucket 这类可访问的版本控制系统中。许多此类代码仓库都是公开可访问的。这种错误在公共代码仓库中出现得如此频繁，以至于出现了一些专门抓取 API 密钥并从中牟利的机器人。

* 使用服务器环境变量。通过将 API 密钥存储在环境变量中，你可以将它们从代码和版本控制中剥离出来。这也让你可以轻松为不同环境使用不同的密钥。
* 使用从版本控制中排除的配置文件。将该文件名添加到你的 [.gitignore](https://git-scm.com/docs/gitignore) 文件中，以将该文件排除在版本控制的跟踪之外。
* 如果你在已经使用版本控制之后才从代码中移除 API 密钥，那么仍然可以通过访问代码库的旧版本获取这些 API 密钥。请重新生成你的 API 密钥，如下一节所述。

<div id="databases">
  ## 数据库
</div>

如果你需要在数据库中存储访问令牌，请注意以下事项：

* 限制对数据库的访问，确保访问令牌只能被其拥有者读取。
* 限制对存放访问令牌的数据库表的编辑/写入权限——应通过密钥管理系统自动完成。
* 在写入任何数据存储之前先对访问令牌进行加密。

<div id="password-management-tools">
  ## 密码管理工具
</div>

1Password 或 LastPass 等密码管理工具有助于将你的密钥和令牌安全地保存起来。你可能需要避免在团队共享的密码管理工具中存放或共享这些信息。

<div id="web-storage-cookies">
  ## Web storage &amp; cookies
</div>

有两种类型的 Web 存储：LocalStorage 和 SessionStorage。它们是作为对 Cookies 的改进而被引入的，因为 Web 存储的容量远高于 Cookie 存储。不过，这几种存储选项各自都有不同的优缺点。
 

**Web Storage：LocalStorage**

存储在本地 Web 存储中的任何内容都是持久化的。这意味着数据会一直保留，直到被显式删除。根据你项目的需求，你可能会认为这是一个优点。不过，在使用 LocalStorage 时需要格外留意，因为对数据的任何更改或新增内容，在之后所有访问该网页的过程中都会可用。我们通常不会推荐使用 LocalStorage，尽管在少数情况下可能会有例外。如果你决定使用 LocalStorage，需要了解它支持同源策略，因此这里存储的所有数据只能通过相同的源进行访问。使用 LocalStorage 的一个额外性能优势是可以减少客户端与服务器之间的流量，因为数据不必在每个 HTTP 请求中都发送回服务器。
 

**Web Storage：SessionStorage**

SessionStorage 与 LocalStorage 类似，但关键区别在于 SessionStorage 不是持久化的。一旦用来写入 SessionStorage 的窗口（或标签页，取决于你使用的浏览器）被关闭，数据就会丢失。这对于在单个用户会话内限制对令牌的读取访问非常有用。从安全性的角度考虑，相比 LocalStorage 通常更倾向于使用 SessionStorage。与 LocalStorage 一样，同源策略支持以及减少客户端与服务器流量的优势，同样适用于 SessionStorage。
 

**Cookies**

Cookies 是存储会话数据的更传统方式。你可以为每个 cookie 设置过期时间，这可以方便撤销和限制访问。然而，在使用 cookies 时，客户端与服务器之间的流量无疑会增加，因为数据会在每个 HTTP 请求中被发送回服务器。如果你决定使用 cookies，就需要防范会话劫持。默认情况下，cookies 会通过 HTTP 以明文形式发送，这会使其内容容易受到数据包嗅探和/或中间人攻击的影响，在这些攻击中，攻击者可能会修改你的流量。你应当始终强制使用 HTTPS 来保护传输中的数据。这将为你提供机密性、完整性（数据完整性）以及认证。然而，如果你的 Web 应用或站点既可以通过 HTTP 也可以通过 HTTPS 访问，你还应该在 cookie 上使用“Secure”标记。这将防止攻击者向用户发送指向你站点 HTTP 版本的链接，并监听其产生的 HTTP 请求。

在使用 cookies 时，防止会话劫持的另一种辅助防御手段是，在执行任何高风险或高影响操作之前再次验证用户身份。你还可以考虑使用另一个标记来提升 cookie 的安全性，即“HttpOnly”标记。该标记会告诉浏览器，相关的 cookie 只能从指定的服务器访问。任何由客户端脚本发起的访问尝试都会被该标记禁止，从而帮助抵御大多数跨站脚本（XSS）攻击。