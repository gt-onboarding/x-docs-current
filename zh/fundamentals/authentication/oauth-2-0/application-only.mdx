---
title: 应用仅模式身份验证和 OAuth 2.0 Bearer Token
sidebarTitle: OAuth 2.0 应用仅模式（Bearer Token）
keywords: ["应用仅模式身份验证", "OAuth 2.0 应用仅模式", "Bearer Token 身份验证", "应用仅模式授权", "只读访问", "公共数据访问"]
---

<div id="app-only-authentication-and-oauth-20-bearer-token">
  ### 仅应用身份验证和 OAuth 2.0 Bearer Token
</div>

X 为应用提供以应用自身（而非特定用户）名义发起已认证请求的能力。X 的实现基于 [OAuth 2 规范](http://tools.ietf.org/html/rfc6749) 中的 [Client Credentials Grant](http://tools.ietf.org/html/rfc6749#section-4.4) 流程。

仅应用身份验证不包含任何用户上下文，是一种由应用以自身名义发起 API 请求的认证方式。此方法适用于只需要对公开信息进行只读访问的开发者。 

你可以使用应用的 Consumer API 密钥进行仅应用身份验证，或者使用仅应用 Access Token（Bearer Token）。这意味着你对 X API 发起的请求只能是那些不需要已认证用户的请求。

通过仅应用身份验证，你可以执行如下操作：

* 拉取用户时间线
* 访问任意账号的关注者和关注中
* 访问列表相关资源
* 搜索帖子

请注意，只有 [OAuth 1.0a](/zh/resources/fundamentals/authentication/oauth-1-0a/api-key-and-secret) 或带 PKCE 的 [OAuth 2.0 Authorization Code Flow](/zh/resources/fundamentals/authentication/oauth-2-0/authorization-code) 才用于代表用户发起请求。[API reference](/zh/resources/fundamentals/authentication/api-reference) 页面会说明使用某个 API 所需的认证方式。若要执行以下操作，你将需要用户认证（用户上下文）以及一个 [access token](/zh/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)：

* 发布帖子或其他资源
* 搜索用户
* 使用任意地理位置相关的端点
* 访问私信或账号凭证
* 获取用户的电子邮件地址

<div id="auth-flow">
  #### 认证流程
</div>

要使用此方法，你需要使用[仅应用访问令牌（App only Access Token）](/zh/resources/fundamentals/authentication/oauth-2-0/application-only)（也称为 [Bearer Token](/zh/resources/fundamentals/authentication/oauth-2-0/bearer-tokens)）。你可以通过向 [POST oauth2/token](/zh/resources/fundamentals/authentication/api-reference#post-oauth2-token) 端点传入你的 consumer key 和 secret 来生成仅应用访问令牌（Bearer Token）。

仅应用认证流程包括以下步骤：

* 应用将其 consumer key 和 secret 编码为一组特定格式的凭证。
* 应用向 [POST oauth2/token](/zh/resources/fundamentals/authentication/api-reference#post-oauth2-token) 端点发起请求，用这些凭证换取[仅应用访问令牌（App only Access Token）](/zh/resources/fundamentals/authentication/oauth-2-0/application-only)。
* 在访问 REST API 时，应用使用仅应用访问令牌进行认证。

由于不需要对请求进行签名，这种方式比标准的 OAuth 1.0a 模式要简单得多。

<Frame>
  <img src="/images/auth-5.png.twimg.1920.png" alt="" />
</Frame>

<div id="about-application-only-auth">
  #### 关于仅应用认证
</div>

**令牌就是密码**

请记住，consumer key 和 consumer secret 以及仅应用访问令牌（App only Access Token，Bearer Token）本身，都授予以应用名义发起请求的访问权限。应将这些值视为与密码同等敏感，且绝不能与不受信任的一方共享或分发。

**必须使用 SSL**

所有请求（获取和使用令牌的请求）*必须* 使用 HTTPS 端点。请遵循 [使用 TLS 连接 X API](/zh/resources/fundamentals/authentication/guides/tls) 中详述的最佳实践 —— 必须**始终**验证对端（peer）的身份。

**无用户上下文**

当使用仅应用认证发起请求时，不存在“当前用户”的概念。因此，诸如 [POST statuses/update](/zh/x-api/posts/creation-of-a-post) 之类的端点在仅应用认证下将无法使用。请参阅 [使用 OAuth](/zh/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)，了解代表用户发起请求的更多信息。

**速率限制**

应用具有两类速率限制池。

代表具有访问令牌（access token）的用户（也称为用户上下文）发起的请求，会从与仅应用认证不同的速率限制配额池中扣减。换句话说，代表用户发起的请求不会消耗通过仅应用认证可用的速率限制，而通过仅应用认证发起的请求也不会消耗用户认证所使用的速率限制。

在 [API 速率限制](/zh/x-api/fundamentals/rate-limits) 中了解更多，并[查看限制](https://developer.x.com/en/portal/products)。

<div id="issuing-application-only-requests">
  #### 发起仅应用请求
</div>

**步骤 1：对 consumer key 和 consumer secret 进行编码**

将应用的 consumer key 和 consumer secret 编码为一组用于获取 Bearer Token 的凭证的步骤如下：

1. 根据 [RFC 1738](http://www.ietf.org/rfc/rfc1738.txt) 对 consumer key 和 consumer secret 进行 URL 编码。请注意，在撰写本文时，这实际上不会改变 consumer key 和 consumer secret 的值，但仍应执行此步骤，以防这些值的格式在未来发生变化。
2. 将编码后的 consumer key、一个冒号字符 “:” 以及编码后的 consumer secret 连接为单个字符串。
3. 对上一步得到的字符串进行 [Base64 编码](http://en.wikipedia.org/wiki/Base64)。

下面是示例值，用于展示此算法的结果。请注意，本页中使用的 consumer secret 仅用于测试目的，不能用于真实请求。

|                                                 |                                                                                             |
| :---------------------------------------------- | :------------------------------------------------------------------------------------------ |
| Consumer key                                    | xvz1evFS4wEEPTGEFPHBog                                                                      |
| Consumer secret                                 | L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg                                                   |
| 按 RFC 1738 编码后的 consumer<br /><br />key（无变化）    | xvz1evFS4wEEPTGEFPHBog                                                                      |
| 按 RFC 1738 编码后的 consumer<br /><br />secret（无变化） | L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg                                                   |
| Bearer Token 凭证                                 | xvz1evFS4wEEPTGEFPHBog:L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg                            |
| Base64 编码后的 Bearer Token 凭证                     | :: eHZ6MWV2RlM0d0VFUFRHRUZQSEJvZzpMOHFxOVBaeVJnNmllS0dFS2hab2xHQzB2SldMdzhpRUo4OERSZHlPZw== |

**步骤 2：获取仅应用访问令牌（Bearer Token）**

在步骤 1 中计算得到的值，必须通过向 [POST oauth2/token](/zh/resources/fundamentals/authentication/api-reference#post-oauth2-token) 发起请求来换取仅应用访问令牌：

* 请求必须是 HTTP POST 请求。
* 请求必须包含一个 `Authorization` 头，其值为 `Basic <base64 encoded value from step 1>.`
* 请求必须包含一个 `Content-Type` 头，其值为 `application/x-www-form-urlencoded;charset=UTF-8.`
* 请求体必须为 `grant_type=client_credentials`。

**示例请求（Authorization 头已换行显示）：**

```json
POST /oauth2/token HTTP/1.1
Host: api.x.com
User-Agent: My X App v1.0.23
Authorization: Basic eHZ6MWV2RlM0d0VFUFRHRUZQSEJvZzpMOHFxOVBaeVJn
                     NmllS0dFS2hab2xHQzB2SldMdzhpRUo4OERSZHlPZw==
Content-Type: application/x-www-form-urlencoded;charset=UTF-8
Content-Length: 29
Accept-Encoding: gzip

grant\_type=client\_credentials
```

如果请求格式正确，服务器会返回一个 JSON 编码的有效负载：

**示例响应：**

```json
HTTP/1.1 200 OK
Status: 200 OK
Content-Type: application/json; charset=utf-8
...
Content-Encoding: gzip
Content-Length: 140

{"token\_type":"bearer","access\_token":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAAAAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}
```

应用应验证返回对象中 `token_type` 键对应的值是否为 `bearer`。`access_token` 键对应的值是仅应用访问令牌（Bearer Token）。

请注意，在任意时间点，一个应用只能有一个有效的仅应用访问令牌。使用相同凭据再次向 `/oauth2/token` 发出请求时，将会返回相同的令牌，直到该令牌被作废为止。

**步骤 3：使用仅应用访问令牌（Bearer Token）为 API 请求进行身份验证**

仅应用访问令牌（Bearer Token）可用于向支持仅应用认证的 API 端点发出请求。要使用应用访问令牌，请构造一个常规的 HTTPS 请求，并包含一个 `Authorization` 头，其值为 `Bearer <第 2 步获取的 base64 Bearer Token 值>。无需签名。`

**示例请求（Authorization 头已换行显示）：**

```
GET /1.1/statuses/user\_timeline.json?count=100&screen\_name=twitterapi HTTP/1.1
Host: api.x.com
User-Agent: My X App v1.0.23
Authorization: Bearer AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAA
                      AAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Accept-Encoding: gzip
```

**使仅应用访问令牌（Bearer Token）失效**

如果仅应用访问令牌遭到泄露，或因任何原因需要将其作废，请调用 [POST oauth2/invalidate&#95;token](/zh/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token)。

**示例请求（Authorization 头已换行显示）：**

```bash
POST /oauth2/invalidate_token HTTP/1.1
Authorization: Basic eHZ6MWV2RlM0d0VFUFRHRUZQSEJvZzpMOHFxOVBaeVJn
                     NmllS0dFS2hab2xHQzB2SldMdzhpRUo4OERSZHlPZw==
User-Agent: My X App v1.0.23
Host: api.x.com
Accept: */*
Content-Length: 119
Content-Type: application/x-www-form-urlencoded

access_token=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAAAAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

**示例响应：**

```json
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 127
...

{"access_token":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAAAAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}
```

<div id="common-error-cases">
  #### 常见错误情况
</div>

本节介绍在获取和使用 Bearer Token 过程中常见的一些错误。请注意，这里并未涵盖所有可能的错误响应——对未处理的错误代码和响应要特别留意。

**获取或撤销仅应用访问令牌的无效请求**

以下尝试将会：

* 使用无效请求获取仅应用访问令牌（Bearer Token）（例如，遗漏 `grant_type=client_credentials`）。
* 使用不正确或已过期的应用凭证获取或撤销仅应用访问令牌（Bearer Token）。
* 试图使不正确或已被撤销的仅应用访问令牌（Bearer Token）失效。
* 在较短时间内过于频繁地获取仅应用访问令牌（Bearer Token）。

将导致以下结果：

```json
HTTP/1.1 403 Forbidden
Content-Length: 105
Content-Type: application/json; charset=utf-8
...

{"errors":\[{"code":99,"label":"authenticity\_token\_error","message":"Unable to verify your credentials"}\]}
```

<div id="api-request-contains-invalid-app-only-access-token-bearer-token">
  #### API 请求中包含无效的仅应用访问令牌（Bearer Token）
</div>

使用错误或已被撤销的 Access Token 发起 API 请求将导致：

```json
HTTP/1.1 401 Unauthorized
Content-Type: application/json; charset=utf-8
Content-Length: 61
...

{"errors":\[{"message":"无效或过期的令牌","code":89}\]}
```

<div id="app-only-access-token-bearer-token-used-on-endpoint-which-doesnt-support-application-only-auth">
  #### 在不支持仅应用身份验证的 endpoint 上使用仅应用 Access Token（Bearer Token）
</div>

使用仅应用 Access Token（Bearer Token）请求需要用户上下文的 endpoint（例如 `statuses/home_timeline`）时，将会出现以下情况：

```json
HTTP/1.1 403 Forbidden
Content-Type: application/json; charset=utf-8
Content-Length: 91
...

{"errors":\[{"message":"您的凭据不允许访问此资源","code":220}\]}
```
