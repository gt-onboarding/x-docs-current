---
title: 分页
sidebarTitle: 分页
keywords: ["搜索分页", "分页指南", "分页浏览结果", "分页令牌", "搜索分页", "next token"]
---

<div id="recent-search-pagination">
  ### 最近搜索的分页
</div>

<div id="introduction">
  #### 简介
</div>

搜索查询匹配到的帖子数量通常会多于单个 API 响应中可以返回的数量。发生这种情况时，数据会以一系列“页面”的形式返回。分页指的是通过依次请求所有这些页面来获取整个数据集的方法。

以下是近期搜索分页的基本细节：

* recent search 端点在响应查询时，至少会返回一页结果，如果还有更多页面可用，则会在 JSON 响应中提供一个 next&#95;token。为了接收所有匹配的帖子，可以重复这一流程，直到响应中不再包含 token。

* next&#95;token 不会过期。在多个请求中使用相同的 next&#95;token 值时，无论请求何时发出，都会收到相同的结果。

* 帖子会按照时间倒序并基于 UTC 时区返回。这一点在单个页面内以及跨多个页面都成立：
  * 第一次响应中的第一条帖子是与你的查询匹配的最新帖子。
  * 最后一页响应中的最后一条帖子是与你的查询匹配的最早帖子。

* max&#95;results 请求参数可用于配置每个响应中返回的帖子数量。默认值为 10 条帖子，最大值为 100 条。

* 任何分页实现都需要从响应负载中解析 next&#95;token，并在“下一页”的搜索请求中携带它。关于如何构造这些“下一页”请求的更多细节，见下文。
   

recent search 端点旨在支持两种基本使用模式：

* **获取历史数据（Get historical）** - 从感兴趣的时间区间请求匹配的帖子。这类请求通常是为了支持历史研究的一次性请求。搜索请求可以基于 start&#95;time 和 end&#95;time 请求参数。recent search 端点会按时间倒序返回帖子，从最新的匹配帖子开始。

* **轮询（Polling）** - 请求自上一次收到的帖子以来新发布的匹配帖子。这些用例通常聚焦近实时场景，其特点是频繁发起请求，“监听”新的感兴趣帖子。recent search 端点提供 since&#95;id 请求参数以支持“轮询”模式。为了便于按帖子 ID 导航，还提供了 until&#95;id 请求参数。
   

接下来，我们将讨论历史数据模式。这是 recent search 端点的默认模式，并用来说明分页的基本原理。然后我们将讨论轮询用例的示例。当轮询触发分页时，还需要额外一步来管理搜索请求。
 

<div id="retrieving-historical-data">
  #### 检索历史数据
</div>

本节介绍如何使用 start&#95;time 和 end&#95;time 请求参数，从指定时间范围内（目前仅限最近 7 天）检索帖子。历史数据请求通常是一次性请求，用于支持研究和分析。 

在 recent search 端点中，请求特定时间范围内的数据是默认模式。如果搜索请求未指定 start&#95;time、end&#95;time 或 since&#95;id 请求参数，则 end&#95;time 默认为“现在”（实际上是查询时间之前的 30 秒），start&#95;time 默认为 7 天前。

端点会返回第一页的帖子，按时间倒序排列，从最新的帖子开始。如果还有更多数据页，JSON 响应负载中还会包含一个 next&#95;token。要收集全部匹配的帖子，无论有多少页，都需要持续发起请求，直到响应中不再返回 next&#95;token 为止。 

例如，下面是一个用于检索过去一周内包含关键词 snow 的帖子的初始请求：

[https://api.x.com/2/tweets/search/recent?query=snow](https://api.x.com/2/tweets/search/recent?query=snow)

响应中会返回最新的 10 条帖子，以及 JSON 响应中 meta 对象中的这些属性：

```
"meta": {
        "newest_id": "1204860593741553664",
        "oldest_id": "1204860580630278147",
        "next_token": "b26v89c19zqg8o3fobd8v73egzbdt3qao235oql",
        "result_count": 10
    }
```

要检索后续的 10 条帖子，需要将这个 next&#95;token 添加到原始请求中。该请求如下：

[https://api.x.com/2/tweets/search/recent?query=snow&amp;next&#95;token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql](https://api.x.com/2/tweets/search/recent?query=snow\&next_token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql)

查找 next&#95;token 并将其包含在后续请求中的过程可以重复进行，直到收集到所有（或指定数量的）帖子，或者达到指定的请求次数。如果结果完整性（收集到查询的所有匹配结果）对你的用例至关重要，那么采用「重复直到 request.next&#95;token 为 null」这样简单的设计就足够了。

<div id="polling-and-listening-use-cases">
  #### 轮询与监听用例
</div>

本节说明如何通过使用 `since_id` 请求参数轮询 recent search 端点来获取最新的帖子。 

在轮询用例中，会持续且频繁地发起诸如“有新的感兴趣的帖子吗？”这样的查询。与基于时间发起请求的历史用例不同，轮询用例通常是基于帖子 ID 来发起请求的。

轮询使用模式的核心在于，每条新的帖子都有一个从 X 平台“发出”的[唯一 ID](/zh/resources/fundamentals/x-ids)，通常按递增顺序生成。如果一条帖子的 ID 比另一条小，意味着它发布得更早。

recent search 端点支持按帖子 ID 在帖子归档中进行导航。该端点的响应中包含 `oldest_id` 和 `newest_id` 帖子 ID。在轮询模式下，请求会使用到目前为止收到的最大/最新 ID 作为 `since_id`。 

例如，假设每五分钟查询一次与 snow（雪）相关的新帖子，而我们上一次收到的最后一条帖子的帖子 ID 为 10000。到轮询时间时，请求如下所示：

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=10000](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=10000)

接下来，假设自上次请求以来又发布了七条新帖子。由于这些帖子都能放在单个数据“页面”中，因此就没有 `next_token`。响应中会提供最新（最新发布）的帖子的帖子 ID：

```
"meta": {
        "newest_id": "12000",
        "oldest_id": "10005",
        "result_count": 7
    }
```

要发出下一次轮询查询，需要使用这个 newest&#95;id 值来设置下一次的 since&#95;id 参数：

`https://api.x.com/2/tweets/search/recent?query=snow&since_id=12000`

当有更多可用数据且返回了 next token 时，只需要第一页结果中的 newest&#95;id 值即可。每一页数据都会包含 newest&#95;id 和 oldest&#95;id 值，但实际在下一个定期的轮询请求中，只需要第一页提供的那个值。因此，如果你实现的是轮询模式，或者按 ID 范围搜索帖子，分页逻辑会稍微复杂一些。 

现在假设又出现了 18 条匹配的帖子。该端点首先会返回一个包含完整数据页的初始响应，以及一个 next&#95;token，用于在这 5 分钟时间段内请求下一页数据。它还会包含在接下来 5 分钟轮询间隔中所需的最新帖子 ID。

```
"meta": {
        "newest_id": "13800",
        "oldest_id": "12500",
        "next_token": "fnsih9chihsnkjbvkjbsc",
        "result_count": 10
    }
```

要收集该五分钟时间段内的全部匹配数据，请在下一次请求中同时传递 `next_token`，并保持 `since_id` 值与上一次请求相同。

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=12000&amp;next&#95;token=fnsih9chihsnkjbvkjbsc](https://api.x.com/2/tweets/search/recent?query=snow\&since\\_id=12000\&next\\_token=fnsih9chihsnkjbvkjbsc)

```
"meta": {
        "newest_id": "12300",
        "oldest_id": "12010",
        "result_count": 8
    }
```

第二个响应返回剩余的八条帖子，并且不包含 next&#95;token。请注意，我们不会更新 newest&#95;id 值（12300），而是基于第一次响应的 newest&#95;id 值来发起下一次带有 since&#95;id 的请求：

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=13800](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=13800)
