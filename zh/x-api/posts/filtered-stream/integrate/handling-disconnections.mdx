---
title: 处理断开连接
sidebarTitle: 处理断开连接
keywords: ["流式断开连接", "处理断开连接", "重新连接流", "流重连", "断开连接处理", "流错误"]
---

<div id="what-is-a-disconnection">
  ### 什么是断开连接？
</div>

与流式 API 建立连接意味着发起一个生命周期非常长的 HTTPS 请求，并以增量方式解析响应。在连接到 `filtered stream` 端点时，你应当构造一个 HTTPS 请求，并尽可能长时间地持续读取返回的流数据。我们的服务器会在没有服务器端错误、客户端严重延迟、网络问题、例行服务器维护或重复登录的情况下无限期保持该连接处于打开状态。对于与流式端点的连接，连接被断开是很常见、并且应当预料到的情况，因此需要构建相应的重连逻辑。
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### 为什么流式连接可能会断开
</div>

你的流可能会由于多种原因而断开。检查流返回的错误信息，以了解失败的原因。可能导致断开的原因包括：

* 身份验证错误（例如使用了错误的令牌或错误的身份验证方法）。
* X 端的流式服务器被重启。这通常与代码部署相关，属于预期情况，应在设计时加以考虑。
* 你的客户端无法跟上流中投递的帖子量，或者读取数据的速度太慢。每个流式连接背后都有一个要发送给客户端的消息队列。如果该队列随着时间推移变得过大，连接将被关闭。
* 你的账号超出了每日/每月的帖子配额。
* 你有太多处于活动状态的冗余连接。
* 客户端突然停止读取数据。如果从流中读取帖子的速率突然下降，连接将被关闭。
* 服务器与客户端之间可能存在网络问题。
* 临时的服务器端故障、计划内维护或更新。（查看[状态页](https://api.twitterstat.us/)）
   

<div id="common-disconnection-errors-include">
  #### 常见的断开连接错误包括：
</div>

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "此流因操作原因已在上游断开连接。",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "This stream is currently at the maximum allowed connection limit.",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### 预判断线并进行重连
</div>

在流式传输帖子时，目标是尽可能长时间保持连接，同时要意识到断开连接难以完全避免。该接口会提供一个 20 秒的保活心跳（会表现为一个换行符）。使用此信号来检测你是否已被断开连接。

1. 你的代码应当检测到新内容和心跳不再到达的情况。
2. 如果发生这种情况，你的代码应当触发重连逻辑。一些客户端和编程语言允许你指定读取超时时间，你可以将其设置为 20 秒。
3. 你的服务应当检测到这些断开连接，并尽快重新连接。

一旦已建立的连接中断，应立即尝试重新连接。如果重连失败，请根据遇到的错误类型降低重连尝试的频率：

* 对 TCP/IP 层面的网络错误采用线性退避。这类问题通常是暂时的，往往会很快恢复。每次重连尝试将延迟增加 250ms，最多增加到 16 秒。
* 对适合重连的 HTTP 错误采用指数退避。从等待 5 秒开始，每次尝试将等待时间加倍，最多加到 320 秒。
* 对 HTTP 429（超出速率限制）错误采用指数退避。从等待 1 分钟开始，每次尝试将等待时间加倍。请注意，每收到一次 HTTP 429，都会增加你必须等待的时间，直到你的账号不再受到速率限制为止。
   

<div id="recovering-lost-data">
  #### 恢复丢失的数据
</div>

如果你确实遇到了断开连接，可以采用多种策略来确保获取所有可能错过的数据。我们在集成指南的[数据恢复](/zh/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features)页面中介绍了一些关键步骤，帮助你恢复遗漏的数据。 
 

<div id="rate-limits-and-usage">
  #### 速率限制和使用情况
</div>

要检查连接限制，响应中会返回三个 header。借助它们，你可以了解规则端点可以被使用多少次，以及流式端点允许多少次重连尝试。

* `x-rate-limit-limit` 表示在 15 分钟时间窗内，允许你的 client 发起的请求总数。

* `x-rate-limit-remaining` 表示在当前 15 分钟时间窗内，剩余可用的请求数量。

* `x-rate-limit-reset` 是一个 UNIX 时间戳，表示 15 分钟时间窗何时重置，届时 `x-rate-limit-remaining` 会被重置为 0。

过滤流端点目前不会报告使用情况数据。若要检查已传送了多少条帖子，你的代码可以实现计量逻辑，以便在需要时衡量并暂停消费。 

在你承载流的客户端代码中，只需将接收到的帖子插入一个先进先出（FIFO）队列，或类似的内存结构；由一个单独的进程/线程从该队列中消费帖子，以解析并准备内容用于存储。基于这种设计，你可以实现一个在传入帖子量发生剧烈变化时仍能高效扩展的服务。从概念上讲，你可以将其视为通过 HTTP 下载一个无限长的文件。

<div id="reconnection-best-practices">
  #### 重新连接最佳实践
</div>

**测试退避策略**

测试退避实现的一个好方法是使用无效的授权凭证，并检查重新连接尝试的情况。良好的实现不应收到任何 429 响应。

**为多次重新连接发出告警**

如果客户端达到预设的重连间隔上限阈值，它应当向你发送通知，以便你可以排查影响连接的问题。

**处理 DNS 变更**

测试你的客户端进程是否遵守 DNS 的生存时间（TTL）。某些技术栈会在整个进程的生命周期内缓存解析后的地址，并不会在规定的 TTL 内采纳 DNS 变更。这种激进的缓存会在 X 在 IP 地址之间进行负载切换时导致你的客户端服务中断。

**User Agent**

确保你的 HTTP User-Agent 头中包含客户端的版本信息。这对于诊断 X 端的问题至关重要。如果你的运行环境无法设置 User-Agent 字段，则改为设置一个 X-User-Agent 头。