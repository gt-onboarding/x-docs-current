---
title: "Account Activity API：Enterprise"
keywords: ["Enterprise Account Activity API", "Enterprise AAA", "Account Activity Enterprise", "Enterprise webhooks", "Enterprise activity"]
---

<Note>
  此端点已更新，现包含帖子编辑相关元数据。请在[“编辑帖子”基础知识页面](/zh/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets)了解这些元数据的更多信息。 

  此端点通常与 Direct Messages 端点一起使用。我们已推出新的 [v2 Direct Messages 端点](/zh/x-api/direct-messages/manage/introduction)。请注意，Enterprise 和 Premium Account Activity API 支持 v2 一对一消息，但尚不支持群组会话。   
</Note>

概览

`Enterprise`

Account Activity API 允许你通过 webhooks 订阅与用户账号相关的实时活动。也就是说，你可以通过单一连接，从一个或多个你拥有或订阅的账号接收实时帖子、Direct Messages，以及其他账号事件。

对于在你的 webhook 注册中订阅的每个用户，你都会收到以下所有相关活动：

| 活动类型 |     |
| :--- | :--- |
| * 帖子（由用户发布）  <br />    <br />* 帖子删除（由用户执行）<br />* @ 提及（提及该用户）<br />* 回复（发给用户或由用户发出）<br />* 转推（由用户转推或转推该用户的帖子）<br />* 引用帖子（由用户引用或引用该用户的帖子）<br />* 对引用帖子的转推（由用户转推或转推引用该用户帖子的帖子）<br />* 点赞（由用户点赞或点赞用户的帖子）<br />* 关注（由用户关注或关注用户）  <br />    <br />* 取消关注（由用户执行） | * 拉黑（由用户执行）<br />* 取消拉黑（由用户执行）<br />* 静音（由用户执行）<br />* 取消静音（由用户执行）<br />* Direct Messages 已发送（由用户发送）<br />* Direct Messages 已接收（用户接收）<br />* 正在输入指示器（发给用户）<br />* 已读回执（发给用户）<br />* 订阅撤销（由用户执行） |

**请注意** - 我们不会通过 Account Activity API 提供主页时间线数据。请使用 [GET statuses/home&#95;timeline](https://developer.x.com/en/docs/x-api/v1/tweets/timelines/overview) 来拉取这些数据。
 

<div id="video-series">
  #### 视频系列
</div>

观看我们关于 Account Activity API 的[四集视频系列](https://www.youtube.com/watch?v=otPxejFhyy8\&index=0\&list=PLFKjcMIU2WshGG6Yj940XM7Z6BFs1zfBg)，帮助你快速上手！

<iframe src="https://platform.x.com/embed/Tweet.html?dnt=false&embedId=twitter-widget-0&features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOltdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2ZvbGxvd2VyX2NvdW50X3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9iYWNrZW5kIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19yZWZzcmNfc2Vzc2lvbiI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfZm9zbnJfc29mdF9pbnRlcnZlbnRpb25zX2VuYWJsZWQiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X21peGVkX21lZGlhXzE1ODk3Ijp7ImJ1Y2tldCI6InRyZWF0bWVudCIsInZlcnNpb24iOm51bGx9LCJ0ZndfZXhwZXJpbWVudHNfY29va2llX2V4cGlyYXRpb24iOnsiYnVja2V0IjoxMjA5NjAwLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3Nob3dfYmlyZHdhdGNoX3Bpdm90c19lbmFibGVkIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19kdXBsaWNhdGVfc2NyaWJlc190b19zZXR0aW5ncyI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdXNlX3Byb2ZpbGVfaW1hZ2Vfc2hhcGVfZW5hYmxlZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdmlkZW9faGxzX2R5bmFtaWNfbWFuaWZlc3RzXzE1MDgyIjp7ImJ1Y2tldCI6InRydWVfYml0cmF0ZSIsInZlcnNpb24iOm51bGx9LCJ0ZndfbGVnYWN5X3RpbWVsaW5lX3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9mcm9udGVuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9fQ%3D%3D&frame=false&hideCard=false&hideThread=false&id=996790447048613888&lang=en&origin=https%3A%2F%2Fdeveloper.x.com%2Fen%2Fdocs%2Fx-api%2Fenterprise%2Faccount-activity-api%2Foverview&sessionId=81f4a0339cbd7bd77b669faa00bd3a7224bc4418&theme=light&widgetsVersion=2615f7e52b7e0%3A1702314776716&width=550px" height="400px" />

<div id="feature-summary">
  ### 功能概览
</div>

| 层级 | 定价 | 唯一订阅数 | webhook 数量 | 可靠性和活动恢复 |
| :--- | :--- | :--- | :--- | :--- |
| Enterprise | [联系销售团队](/zh/x-api/enterprise-gnip-2.0/enterprise-gnip) | 最多 500+ | 3+  | [重试](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries) 和 [回放](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) |

* 有疑问？遇到错误？
  * 请阅读我们的 [常见问题](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions) 或 [错误排查指南](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions)。

* 浏览我们的示例代码：
  * [Enterprise Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard-enterprise)，一个使用 Enterprise 层级的 Account Activity API 来显示 webhook 事件的 Node Web 应用程序，并包含 [回放](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) 功能。
  * [SnowBot 聊天机器人](https://github.com/xdevplatform/SnowBotDev)，一个基于 Enterprise Account Activity 和 Direct Message API 构建的 Ruby Web 应用程序。

<div id="manage-webhooks-and-subscribed-users">
  ## 管理 webhooks 和订阅用户
</div>

**⏱ 10 分钟阅读**

Enterprise Account Activity API 会在与订阅了你服务的 X 账号相关的事件发生时，通过 webhook 向你提供 JSON 格式的消息。X 会将这些活动发送到你注册的 webhook。通过以下步骤，你将学习如何管理 webhooks 和订阅用户。

你将学习如何注册、查看和移除 webhooks 以及订阅用户。我们将使用简单的 cURL 命令向各个 API 端点发起请求。cURL 是一个使用 URL 语法来发送或获取请求的命令行工具。

你需要准备：

* 一个已注册的 X 应用 - *[在此注册](https://developer.x.com/content/developer-twitter/en/apps)*
* 一个 Bearer Token - *[了解更多](/zh/resources/fundamentals/authentication#using-and-generating-an-app-only-bearer-token)*
* 一个通过 Challenge-Response Check (CRC) 的 webhook - *[了解更多](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks)*
* 一个 Enterprise 账户 - *[在此申请]https://developer.x.com/en/products/x-api/enterprise*

*在开始之前，我们建议你先查看我们的 [GitHub 仓库](https://github.com/xdevplatform/account-activity-dashboard)，其中提供了一个示例 Web 应用和一些辅助脚本，帮助你开始使用 X 的 Account Activity API。*

<div id="managing-a-webhook">
  #### 管理 webhook：
</div>

使用 webhook 可以让你通过单一连接订阅与某个用户账户相关的实时活动。 

<Tabs>
  <Tab title="添加 webhook">
    先为指定的应用注册一个新的 webhook URL。

    在保存之前，该 URL 将通过 CRC 请求进行验证。注册好 webhook 之后，请务必记录 webhook ID，后续会用到。

    根据下列说明完成替换后，将以下 cURL 请求复制到命令行中运行：

    * **URL** `<URL>`，例如 `https://yourdomain.com/webhooks/twitter/`

    * **Consumer key** `<CONSUMER_KEY>`，例如 `xvz1evFS4wEEPTGEFPHBog`

    * **Access token** `<ACCESS_TOKEN>`，例如  `370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```
      curl --request POST --url 'https://api.x.com/1.1/account_activity/webhooks.json?url=<URL>' --header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<ACCESS_TOKEN>", oauth_version="1.0"'
      ```
  </Tab>

  <Tab title="查看 webhook">
    运行以下命令，可以返回指定应用已注册的所有 webhook URL 及其状态。

    根据下列说明完成替换后，将以下 cURL 请求复制到命令行中运行：

    * **Bearer Token** `<BEARER_TOKEN>`，例如 `AAAAAAAAAAAA0%2EUifi76ZC9Ub0wn...`

      ```curl --request GET --url https://api.x.com/1.1/account_activity/webhooks.json --header 'authorization: Bearer <BEARER_TOKEN>'
      ```
  </Tab>

  <Tab title="移除 webhook">
    要从指定应用的配置中移除某个 webhook，根据下列说明完成替换后，将以下 cURL 请求复制到命令行中运行：

    * **Webhook ID** `<:WEBHOOK_ID>`，例如 `1234567890`

    * **Consumer key** `<CONSUMER_KEY>`，例如 `xvz1evFS4wEEPTGEFPHBog`

    * **Access token** `<ACCESS_TOKEN>`，例如  `370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```curl --request DELETE --url https://api.x.com/1.1/account_activity/webhooks/<:WEBHOOK_ID>.json --header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<ACCESS_TOKEN>", oauth_version="1.0"'
      ```
  </Tab>
</Tabs>

<div id="managing-subscribed-users">
  #### 管理已订阅用户：
</div>

在注册 Webhook 之后，你可以将已订阅用户添加到 Account Activity API 中，以开始接收其账户活动。

<Tabs>
  <Tab title="添加订阅">
    我们先从为用户创建订阅开始，这样你就能接收所有事件类型。

    在完成以下替换后，将下面的 cURL 请求复制到命令行中：

    * **Webhook ID** `<:WEBHOOK_ID>`，例如：`1234567890`

    * **Consumer key 名称** `<CONSUMER_KEY>`，例如：`xvz1evFS4wEEPTGEFPHBog`

    * **订阅用户的访问令牌** `<SUBSCRIBING_USER'S_ACCESS_TOKEN>`，例如：`370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```
      curl --request POST --url https://api.x.com/1.1/account_activity/webhooks/<:WEBHOOK_ID>/subscriptions/all.json --header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<SUBSCRIBING_USER'S_ACCESS_TOKEN>", oauth_version="1.0"'
      ```
  </Tab>

  <Tab title="查看订阅">
    若要查看指定 Webhook 的所有活动类型订阅列表，在完成以下替换后，将下面的 cURL 请求复制到命令行中：

    * **Webhook ID** `<:WEBHOOK_ID>`，例如：`1234567890`

    * **Bearer token** `<BEARER_TOKEN>`，例如：`AAAAAAAAAAAA0%2EUifi76ZC9Ub0wn...`

      ```
      curl --request GET --url https://api.x.com/1.1/account_activity/webhooks/<:WEBHOOK_ID>/subscriptions/all/list.json --header 'authorization: Bearer <BEARER_TOKEN>'
      ```
  </Tab>

  <Tab title="移除订阅">
    停用后，请求用户的所有事件将不再发送到该 Webhook URL。

    要在给定的用户上下文和应用下停用订阅，在完成以下替换后，将下面的 cURL 请求复制到命令行中：

    * **Webhook ID** `<:WEBHOOK_ID>`，例如：`1234567890`

    * **Consumer key** `<CONSUMER_KEY>`，例如：`xvz1evFS4wEEPTGEFPHBog`

    * **订阅用户的访问令牌** `<SUBSCRIBING_USER'S_ACCESS_TOKEN>`，例如：`370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```
      curl --request DELETE --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all.json --header 'authorization: OAuth oauth_consumer_key="CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="SUBSCRIBED_USER'S_ACCESS_TOKEN", oauth_version="1.0"'
      ```
  </Tab>
</Tabs>

做得很好！现在你应该已经可以管理你的 webhooks 和已订阅用户了。

<div id="referenced-articles">
  #### 参考文章
</div>

* [挑战-响应校验（CRC）概览](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks)
* [账户活动数据类型](/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-data-object-structure
* [管理 Webhook 和订阅](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#managing-webhooks-and-subscriptions)

<div id="a-video-walkthrough-of-the-account-activity-api">
  ## Account Activity API 的视频导览
</div>

在本视频中，你将了解 Account Activity API 的高级版和 Enterprise 层级所提供的功能。

看完本视频后，你将了解以下功能：

* 注册 webhook
* 添加用户订阅
* 删除用户订阅
* 接收账号活动
* 回放账号活动

<iframe src="https://platform.x.com/embed/Tweet.html?dnt=false&embedId=twitter-widget-0&features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOltdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2ZvbGxvd2VyX2NvdW50X3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9iYWNrZW5kIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19yZWZzcmNfc2Vzc2lvbiI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfZm9zbnJfc29mdF9pbnRlcnZlbnRpb25zX2VuYWJsZWQiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X21peGVkX21lZGlhXzE1ODk3Ijp7ImJ1Y2tldCI6InRyZWF0bWVudCIsInZlcnNpb24iOm51bGx9LCJ0ZndfZXhwZXJpbWVudHNfY29va2llX2V4cGlyYXRpb24iOnsiYnVja2V0IjoxMjA5NjAwLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3Nob3dfYmlyZHdhdGNoX3Bpdm90c19lbmFibGVkIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19kdXBsaWNhdGVfc2NyaWJlc190b19zZXR0aW5ncyI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdXNlX3Byb2ZpbGVfaW1hZ2Vfc2hhcGVfZW5hYmxlZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdmlkZW9faGxzX2R5bmFtaWNfbWFuaWZlc3RzXzE1MDgyIjp7ImJ1Y2tldCI6InRydWVfYml0cmF0ZSIsInZlcnNpb24iOm51bGx9LCJ0ZndfbGVnYWN5X3RpbWVsaW5lX3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9mcm9udGVuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9fQ%3D%3D&frame=false&hideCard=false&hideThread=false&id=1204084171334832128&lang=en&origin=https%3A%2F%2Fdeveloper.x.com%2Fen%2Fdocs%2Fx-api%2Fenterprise%2Faccount-activity-api%2Fquick-start%2Fa-visual-walkthrough-of-the-account-activity-api&sessionId=b5b8e259a4c6287be2413de9059093170036fb30&theme=light&widgetsVersion=2615f7e52b7e0%3A1702314776716&width=550px" />

* 有问题？遇到错误？
  * 阅读我们的[常见问题](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions)或[错误排查指南](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions)。

* 查看我们的示例代码：
  * [Enterprise Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard-enterprise)，一个使用 Account Activity API 的 Enterprise 级别来显示 webhook 事件，并包含 [Replay](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) 功能的 Node.js Web 应用。
  * [SnowBot chatbot](https://github.com/xdevplatform/SnowBotDev)，一个基于 Enterprise 级别 Account Activity 和 Direct Message API 构建的 Ruby Web 应用。

**Enterprise**

<div id="getting-started-with-webhooks">
  ## 使用 webhooks 入门
</div>

Account Activity API 是一种基于 webhook 的 API，它会将账号事件发送到你自行开发、部署并托管的 Web 应用。

在你的事件消费应用能够开始接收 webhook 事件之前，还有若干基础配置细节需要处理。如下所述，你需要创建一个 X 应用，获取 Account Activity API 的访问权限，并开发一个用于消费 webhook 事件的 Web 应用。 

<div id="1-create-a-x-app">
  ### 1. 创建一个 X 应用。
</div>

* 使用已获批准的开发者账号在[开发者门户](/zh/resources/fundamentals/developer-portal)中创建一个 [X 应用](/zh/resources/fundamentals/developer-apps)。如果你是代表公司创建应用，建议使用公司的 X 账号来创建该应用。要申请开发者账号，请[点击这里](/zh/resources/fundamentals/developer-apps)。
* 在你的应用页面的[权限](/zh/resources/fundamentals/developer-apps#oauth-1-0a-app-permissions)选项卡中启用“Read, Write and Access direct messages”。
* 在“Keys and Access Tokens”选项卡中，记下你的应用的 Consumer Key（API Key）和 Consumer Token（API Secret）。
* 在同一选项卡中，生成你的应用的 [Access Token 和 Access Token Secret](/zh/resources/fundamentals/authentication#obtaining-access-tokens-using-3-legged-oauth-flow)。你需要这些 Access Token 来注册你的 webhook URL，X 会将账号事件发送到该 URL。
* 如果你不熟悉 [X Sign-in](/zh/resources/fundamentals/authentication#log-in-with-x) 以及用户上下文在 X API 中的工作方式，请查看 [Obtaining Access Tokens](https://dev.x.com/webhooks/access-tokens)。当你添加要接收事件的账号时，你将使用该账号的 Access Token 为其订阅事件。
* 记下你的应用的数值 ID，可在[开发者门户](/zh/resources/fundamentals/developer-portal)的“[Apps](/zh/resources/fundamentals/developer-apps)”页面中查看。当你申请 Account Activity API 访问权限时，需要提供此应用 ID。
   

<div id="2-get-account-activity-api-access">
  ### 2. 获取 Account Activity API 访问权限
</div>

创建 X 应用之后，下一步是申请 Account Activity API 访问权限。 

Account Activity API 仅适用于 Enterprise，因此你需要通过以下链接提交申请。

<Button href="https://developer.x.com/en/enterprise-application.html">
  申请 Enterprise 访问权限
</Button>

<div id="3-develop-webhook-consumer-app">
  ### 3. 开发 webhook 消费者应用
</div>

在你获得 Account Activity API 访问权限后，需要开发、部署并托管一个用于接收 X webhook 事件的 Web 应用。 

* 创建一个带有 URL 的 Web 应用，将其作为你的 webhook 来接收事件。该 URL 是部署在你服务器上的端点，用于监听传入的 X webhook 事件。 
  * URI *path* 完全由你决定。以下示例是有效的：https://mydomain.com&#95;/service/listen&#95;

  * 如果你需要监听来自多种来源的 webhook，一个常见模式是：https://mydomain.com/webhook/twitter

  * 请注意，指定的 URL 不能包含端口号（https://mydomain.com:5000/NoWorkie）。

* 如我们的 [Securing Webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks) 指南中所述，第一步是编写代码，以接收 X Challenge Response Check (CRC) 的 GET 请求，并返回格式正确的 JSON 响应。 

* 注册你的 webhook URL。你需要向 /webhooks.json?url= 端点发起一个 POST 请求。当你发出该请求时，X 会向你的 Web 应用发送 CRC 请求。当 webhook 成功注册后，响应中会包含一个 webhook id。稍后在向 Account Activity API 发出某些请求时需要使用此 webhook id。 

* X 会将账户级 webhook 事件发送到你注册的 URL。请确保你的 Web 应用支持针对传入事件的 POST 请求。这些事件将使用 JSON 编码。示例 webhook JSON 负载见[此处](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-data-object-structure)。

* 当你的 Web 应用准备就绪后，下一步是添加需要接收活动的账户。在添加（或删除）账户时，你需要发送引用账户 id 的 POST 请求。更多信息请参阅我们的[添加订阅指南](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#managing-webhooks-and-subscriptions)。

<div id="4-validate-setup">
  ### 4. 验证设置
</div>

* 为验证你的应用和 webhook 已正确配置，给你的应用已订阅的某个 X 账号发布的帖子点一次赞（Favorite）。对于你的订阅者收到的每一次点赞，你都应当通过发送到你的 webhook URL 的 POST 请求收到一个 `favorite_events` 事件。
* 请注意，在添加订阅后，事件开始投递可能会有最长达 10 秒的延迟。

**重要说明**

* 在注册 webhook URL 时，你的 Web 应用必须使用其 consumer token 和 secret *以及应用所有者的用户访问令牌（user access token）及其密钥（secret）* 进行认证。 

* 所有收到的私信（Direct Messages）都会通过 webhooks 投递。所有通过 [POST direct&#95;messages/events/new (message&#95;create)](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event) 发送的私信也会通过 webhooks 投递。这样你的 Web 应用才能获知通过其他客户端发送的私信。

* 请注意，每个 webhook 事件都包含一个 `for_user_id` 用户 ID，用于指示该事件是针对哪个订阅投递的。

* 如果有两个用户在同一会话中使用你的 Web 应用收发私信，你的 webhook 会收到两条重复事件（每个用户一条）。你的 Web 应用需要对此进行处理。 

* 如果你有不止一个 Web 应用共享同一个 webhook URL，且同一用户映射到每个应用，则同一个事件会被多次发送到你的 webhook（每个 Web 应用一次）。

* 在某些情况下，你的 webhook 可能会收到重复事件。你的 webhook 应用应能够容忍这种情况，并按事件 ID 进行去重。

* 不要假定 Quick Reply 响应会紧跟在请求之后。用户可以忽略 Quick Reply 请求，并选择通过传统私信进行回复。用户也可能对他们先前在消息线程中尚未回复的请求给出 Quick Reply 响应。

* 请参见示例代码：
  * [Enterprise Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard-enterprise)，一个使用 Account Activity API Enterprise 等级、用于展示 webhook 事件并包含 [Replay](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) 功能的 Node Web 应用。

  * [SnowBot chatbot](https://github.com/xdevplatform/SnowBotDev)，一个基于 Account Activity 和 Direct Message API 构建的 Ruby Web 应用。该代码库包含一个用于帮助设置 Account Activity API webhooks 的[脚本](https://github.com/xdevplatform/SnowBotDev/wiki/Account-Activity-API-setup-script)。

<div id="securing-webhooks">
  ## 保护 Webhook 安全
</div>

X 基于 Webhook 的 API 提供了两种方法，用于确认你的 Webhook 服务器的安全性：

1. 挑战-响应检查使 X 能够验证接收 Webhook 事件的 Web 应用的所有权。
2. 每个 POST 请求中的签名请求头使你能够确认这些传入的 Webhook 确实来自 X。
    

<div id="challenge-response-checks">
  ### 挑战-响应检查
</div>

为了验证你既是应用的所有者又是 webhook URL 的所有者，X 会执行 Challenge-Response Check（CRC，挑战-响应检查），这与循环冗余校验（cyclic redundancy check）不同。当发送 CRC 时，X 会向你的 Web 应用发起一次带有 *`crc_token`* 参数的 GET 请求。当该请求被接收后，你的 Web 应用需要基于 *`crc_token`* 参数和你的应用的 Consumer Secret（详见下文）构建一个加密的 `response_token`。`response_token` 必须用 JSON 编码（参见下方示例），并在三秒内返回。成功后，会返回一个 webhook `id`。 

当你注册 webhook URL 时会发送一次 CRC，因此实现 CRC 响应代码是最基础的第一步。一旦你的 webhook 建立，X 将从上次收到成功响应的时间起，大约每 24 小时触发一次 CRC。当需要时，你的应用也可以通过使用 webhook `id` 发起 PUT 请求来触发 CRC。在开发 webhook 应用、部署新代码并重启服务之后，触发 CRC 非常有用。 

应当预期每次传入的 CRC 请求中 *`crc_token`* 都会发生变化，并且应将其作为参与计算的消息内容，而将你的 Consumer Secret 作为密钥。 

如果响应未在 3 秒内返回或响应变得无效，将不再向已注册的 webhook 发送事件。

<div id="the-crc-request-will-occur">
  #### CRC 请求将在以下情况下发生：
</div>

* 在注册 webhook URL 时。
* 大约每隔 *一小时* 验证一次你的 webhook URL。
* 你可以通过发送 PUT 请求手动触发 CRC。在开发 webhook 客户端时，应规划在编写 CRC 响应的同时手动触发 CRC。 
   

<div id="response-requirements">
  #### 响应要求：
</div>

* 使用 `crc_token` 和你的应用 Consumer Secret 创建的、经 base64 编码的 HMAC SHA-256 哈希值
* 有效的 response&#95;token，并采用 JSON 格式。
* 延迟小于 3 秒。
* 200 HTTP 响应状态码。
   

<div id="language-specific-hmac-libraries">
  #### 各语言的 HMAC 库：
</div>

* [Java/Scala](https://docs.oracle.com/javase/8/docs/api/index.html?javax/crypto/Mac.html)
* [Ruby](http://ruby-doc.org/stdlib-2.1.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html)
* [Node.js](https://nodejs.org/api/crypto.html#crypto_class_hmac)
* [Python](https://docs.python.org/2/library/hmac.html)

<div id="example-response-token-generation-in-python">
  #### 使用 Python 生成响应令牌的示例：
</div>

下面的示例在一个 Python 2.7 Flask Web 应用中定义了一个路由，用于正确通过挑战响应校验。

```
import base64
import hashlib
import hmac
import json


\# 为 GET 请求定义路由
@app.route('/webhooks/twitter', methods=\['GET'\])
def webhook_challenge():

  # 根据传入的令牌和您的消费者密钥创建 HMAC SHA-256 哈希值
  sha256\_hash\_digest = hmac.new(TWITTER\_CONSUMER\_SECRET, msg=request.args.get('crc_token'), digestmod=hashlib.sha256).digest()

  # 使用 base64 编码的哈希值构造响应数据
  response = {
    'response\_token': 'sha256=' + base64.b64encode(sha256\_hash_digest)
  }

  # 返回格式正确的 JSON 响应
  return json.dumps(response)
```

<div id="example-json-response">
  #### 示例 JSON 响应：
</div>

在按照上述方式定义路由后，当你在浏览器中访问 [https://your-app-domain/webhooks/twitter?crc&#95;token=foo](https://your-app-domain/webhooks/twitter?crc_token=foo) 时，你的 Web 应用应返回与下方类似的响应。

```
{
  "response_token": "sha256=x0mYd8hz2goCTfcNAaMqENy2BFgJJfJOb4PdvTffpwg="
}
```

<div id="other-examples">
  #### 其他示例：
</div>

* [此处](https://github.com/xdevplatform/account-activity-dashboard/blob/master/helpers/security.js) 是一个使用 Node/JS 编写的 CRC 响应方法示例。
* [此处](https://github.com/xdevplatform/SnowBotDev/blob/master/app/controllers/snow_bot_dev_app.rb) 是一个使用 Ruby 编写的 CRC 响应方法示例（参见 *generate&#95;crc&#95;response* 以及用于接收 CRC 事件的 /GET 路由）。

<div id="optional-signature-header-validation">
  ### 可选的签名头验证
</div>

当从 X 接收 POST 请求、发送 GET 请求来创建 webhook，或发送 GET 请求来执行手动 CRC 时，请求头中会以 x-twitter-webhooks-signature 字段传递一个哈希签名。该签名可用于验证数据确实来自 X。POST 请求的哈希签名以 sha256= 开头，表示使用 HMAC SHA-256 基于你的 X 应用 Consumer Secret 和负载内容生成签名。GET 请求的哈希则是根据查询参数字符串 crc&#95;token=$token&amp;nonce=$nonce 计算得到的。 

**验证请求的步骤**

1. 使用你的 Consumer Secret 和传入请求体内容生成一个哈希值。
2. 将生成的哈希与经过 base64 编码的 x-twitter-webhooks-signature 值进行比较。使用类似 [compare&#95;digest](https://docs.python.org/2/library/hmac.html) 的方法，以降低遭受计时攻击的风险。

<div id="additional-security-guidelines">
  ### 其他安全指南
</div>

以下是你的 Web 应用程序在安全性方面还需考虑的一些其他指南。即使未实施这些指南，也不会影响你的 webhook 正常工作，但 X 信息安全团队仍强烈建议你采纳这些措施。如果你不熟悉以下建议，请咨询你的服务器管理员。

<div id="x-aggregate-network-blocks">
  #### X 汇总网络网段
</div>

为提高安全性，建议将以下汇总网络网段添加到白名单中：

* 199.59.148.0/22

* 199.16.156.0/22

* 192.133.77.0/26

* 64.63.15.0/24

* 64.63.31.0/24

* 64.63.47.0/24

* 202.160.128.0/24

* 202.160.129.0/24

* 202.160.130.0/24

<div id="recommended-server-configurations">
  #### 推荐的服务器配置
</div>

* 在 [ssllabs.com](http://ssllabs.com/) 测试中获得 “A” 级评级
* **启用 TLS 1.2**
* 启用前向保密（Forward Secrecy）
* 关闭 SSLv2
* 关闭 SSLv3（由于 POODLE 漏洞）
* 关闭 TLS 1.0
* 关闭 TLS 1.1
* 关闭 TLS 压缩
* 关闭会话票据（Session Tickets），除非你会定期轮换会话票据密钥。
* 在 SSL 配置中将 “ssl&#95;prefer&#95;server&#95;ciphers” 或 “SSLHonorCipherOrder” 选项设置为 “on”。
* 确保使用现代的密码套件列表，例如：
  `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:DES-CBC3-SHA`

<div id="managing-webhooks-and-subscriptions">
  ## 管理 Webhook 和订阅
</div>

<div id="creating-changing-webhooks">
  ### 创建和更改 webhook
</div>

若要更改 webhook 的 URL，必须先删除现有的 webhook，然后再创建一个新的。请注意，执行此操作时，你需要为新的 webhook 重新添加用户订阅。

<div id="webhook-configuration-management-endpoints">
  #### Webhook 配置管理端点：
</div>

|     |     |
| :--- | :--- |
| **Method** | Enterprise |
| 注册 webhook URL / 生成 webhook&#95;id | [POST webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) |
| 返回所有 webhook URL 及其状态 | [GET webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |
| 删除应用当前的 webhook 配置 | [DELETE webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) |
| 手动触发 CRC 请求 | [PUT webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) |

<div id="why-cant-i-just-update-the-webhook-url">
  #### 为什么我不能直接更新 webhook URL？
</div>

为什么 webhook 配置是不可更改的？X 对安全性极为重视。如果你的 webhook URL 被更改，就有可能意味着你的应用 consumer key 和 consumer secret 已经泄露。通过要求你创建一个新的 webhook 配置，你也必须重新为用户的事件创建订阅。这需要使用恶意方不太可能掌握的访问令牌。这样一来，其他方获取你用户私人信息的可能性就会降低。
 

<div id="adding-removing-user-subscriptions">
  ### 添加和删除用户订阅
</div>

通过 Enterprise 级别可以支持成千上万条订阅。如果你已经有客户经理，请就相关问题与其联系。要申请 Enterprise API 的访问权限，[点击此处](https://developer.x.com/en/products/x-api/enterprise)。 

<div id="subscription-management-endpoints">
  #### 订阅管理端点
</div>

|     |     |
| :--- | :--- |
| 方法 | Enterprise |
| 添加新的用户订阅 | [POST webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) |
| 获取用户订阅 | [GET webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) |
| 返回所有活跃订阅的列表 | [GET webhooks/:webhook&#95;id/subscriptions/all/list](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |
| 使用仅应用级 OAuth 停用用户订阅 | [DELETE webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |

Account Activity API：Enterprise

<Note>
  **请注意**： 

  在开始使用该 API 之前，X 需要为你的开发者应用启用对 Account Activity API 的访问权限。为此，请务必将你打算用于身份验证的 App ID 提供给你的客户经理或技术支持团队。
</Note>

[Account Activity API](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity) 由一组端点组成，这些端点允许你创建和管理用户订阅，通过单一连接接收所有已订阅账户的实时账户活动。 

Account Activity API 提供两种可用的身份验证方法（[OAuth 1.0a](/zh/resources/fundamentals/authentication#oauth-1-0a-2) 和 [OAuth 2.0 Bearer Token](/zh/resources/fundamentals/authentication#bearer-token-also-known-as-app-only)。你应当使用哪一种身份验证方法取决于你正在调用的端点。

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| **描述** | **端点** | OAuth 1.0a  <br />(用户上下文) | OAuth 2.0 Bearer Token（仅限应用） |
| 为指定的应用上下文注册一个新的 webhook URL | [POST account&#95;activity/webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks) | ✓   |     |
| 返回指定应用的所有 URL 及其状态 | [GET account&#95;activity/webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |     | ✓   |
| 为指定 webhook 的 URL 触发质询响应检查 (CRC) | [PUT account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) | ✓   |     |
| 将应用订阅到某个用户的账号事件 | [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 返回当前活跃订阅的数量 | [GET account&#95;activity/subscriptions/count](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |     | ✓   |
| 检查某个 webhook 配置是否已订阅某用户的事件 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 返回当前活跃订阅的列表 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all-list) |     | ✓   |
| 删除一个 webhook | [DELETE account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) | ✓   |     |
| [DEPRECATED] 停用指定用户上下文和应用的订阅 | [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) | ✓ * |     |
| 使用仅限应用的 OAuth 停用订阅 | [DELETE /account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |     | ✓   |
| 将活动重新投递到 webhook | [POST /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#replay-api) |     | ✓   |

*&#95; 身份验证需要订阅用户的访问令牌。&#95;

对于那些需要 OAuth 1.0a 用户上下文身份验证的端点，你需要提供以下凭证来对请求进行身份验证： 

* Consumer Keys（API Key 和 Secret）
* Access Tokens（访问令牌和 Secret）

对于以下三个端点，您在应用上下文中执行写操作（不涉及任何 X 用户）。因此，你需要提供的 Access Tokens 是属于你的开发者应用的那些。这些可以直接在[开发者门户](https://developer.x.com/en/portal/projects-and-apps)中、你的 App 的 “Keys and tokens” 选项卡下生成。  

* [POST account&#95;activity/webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks)：为指定的应用上下文注册一个新的 webhook URL
* [PUT account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id)：为给定 webhook 的 URL 触发一次挑战响应检查（CRC）
* [DELETE account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id)：删除一个 webhook

另一方面，对于以下三个端点，你发起的是允许应用代表某个 X 用户访问受保护数据（例如私信 Direct Messages）的请求。因此，你必须提供属于相应订阅用户的访问令牌（Access Tokens）。所需的访问令牌可以通过三方 OAuth 流程获取（参见 [OAuth 1.0a: how to obtain a user’s Access Tokens](/zh/resources/fundamentals/authentication#obtaining-access-tokens-using-3-legged-oauth-flow)）。这些端点已经在上表中用星号（*）标出。

* [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all)：为应用订阅某个用户账号的事件
* [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all)：检查某个 webhook 配置是否已订阅某个用户的事件
* [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated)：停用指定用户上下文和应用的订阅 [已弃用]

<Note>
  **Please note**: 

  请确保你的开发者应用已启用 &quot;Read, Write, and Direct Messages&quot;。你可以在开发者账号的 [Projects &amp; Apps section](https://developer.x.com/en/portal/projects-and-apps) 中所选开发者应用的 “App permissions” 下更改此设置。更改权限设置后，你需要重新生成应用凭证。
</Note>

你可以在 [API 参考文档](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index) 中找到 Account Activity API 提供的所有端点列表，包括相关说明以及包含身份验证实现示例的 cURL 请求示例。

如需更多信息，可以查看 XDev 提供的 [示例 Web 应用和辅助脚本](https://github.com/xdevplatform/account-activity-dashboard-enterprise)，以开始使用 Enterprise Account Activity API。

<Note>
  **Please note**: 

  在你开始使用该 API 之前，X 需要为你的开发者应用启用对 Account Activity API 的访问。为此，请务必将你计划用于身份验证的 App ID 提供给你的客户经理或技术支持团队。
</Note>

[Account Activity API](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity) 由一组端点组成，允许你创建和管理用户订阅，通过单一连接实时接收所有已订阅账号的账号活动。 

Account Activity API 提供两种可用的身份验证方法（[OAuth 1.0a](/zh/resources/fundamentals/authentication#oauth-1-0a-2) 和 [OAuth 2.0 Bearer Token](/zh/resources/fundamentals/authentication#oauth-2-0)）。你应当使用哪种身份验证方法取决于你正在使用的具体端点。

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| **Description** | **Endpoint ** | OAuth 1.0a  <br />(user context) | OAuth 2.0 Bearer Token (application-only) |
| 为指定应用上下文注册一个新的 webhook URL | [POST account&#95;activity/webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks) | ✓   |     |
| 返回指定应用的所有 URL 及其状态 | [GET account&#95;activity/webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |     | ✓   |
| 为给定 webhook 的 URL 触发一次 CRC 挑战响应检查 | [PUT account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) | ✓   |     |
| 将应用订阅到某个用户的账户事件 | [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 返回当前处于活动状态的订阅数量 | [GET account&#95;activity/subscriptions/count](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |     | ✓   |
| 检查某个 webhook 配置是否已订阅某个用户的事件 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 返回当前处于活动状态的订阅列表 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all-list) |     | ✓   |
| 删除一个 webhook | [DELETE account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) | ✓   |     |
| [DEPRECATED] 针对给定的用户上下文和应用停用一个订阅 | [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) | ✓ * |     |
| 使用仅应用 OAuth 停用一个订阅 | [DELETE /account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |     | ✓   |
| 将活动重新投递到某个 webhook | [POST /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#replay-api) |     | ✓   |

*&#95; 认证需要订阅用户的访问令牌。 &#95;

对于那些需要 OAuth 1.0a 用户上下文认证的端点，你需要提供以下凭证来对请求进行身份验证： 

* Consumer Keys（API Key 和 Secret）
* Access Tokens（Access Token 和 Secret）

在下面这三个端点中，你是在应用上下文内执行写操作（不涉及任何 X 用户）。因此，你需要提供的 Access Tokens 是属于你的开发者应用的访问令牌。你可以直接在 [developer portal](https://developer.x.com/en/portal/projects-and-apps) 中，为你的 App 在 “Keys and tokens”（“密钥和令牌”）选项卡下生成这些令牌。  

* [POST account&#95;activity/webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks)：为给定的应用上下文注册一个新的 webhook URL
* [PUT account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id)：为给定 webhook 的 URL 触发一次质询-响应检查（CRC）
* [DELETE account&#95;activity/webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id)：删除一个 webhook

另一方面，对于下面这三个端点，你发起的请求会允许你的应用代表某个 X 用户访问受保护的数据（例如私信）。因此，你必须提供属于相应订阅用户的访问令牌（Access Tokens）。所需的访问令牌可以通过三方 OAuth 流程获取（参见 [OAuth 1.0a: how to obtain a user’s Access Tokens](/zh/resources/fundamentals/authentication#obtaining-access-tokens-using-3-legged-oauth-flow)）。这些端点在上表中已用星号（*）标注。

* [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all)：将应用订阅到某个用户的账户事件
* [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all)：检查某个 webhook 配置是否已订阅某个用户的事件
* [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated)：停用给定用户上下文和应用的订阅 [已废弃（DEPRECATED）]

<Note>
  **请注意**： 

  确保你的开发者应用已启用 &quot;Read, Write, and Direct Messages.&quot;。你可以在开发者账号的 [Projects &amp; Apps 部分](https://developer.x.com/en/portal/projects-and-apps)中，在所选开发者应用的 &quot;App permissions&quot; 下更改此设置。更改权限设置后，你需要重新生成应用凭证。
</Note>

你可以在 [API 参考文档](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index)中找到 Account Activity API 的全部可用端点列表，其中包含相关说明以及带有身份验证实现示例的 cURL 请求示例。

如需更多信息，可以查看 XDev 的[示例 Web 应用和辅助脚本](https://github.com/xdevplatform/account-activity-dashboard-enterprise)，以开始使用 Enterprise Account Activity API。

<div id="retries">
  ## 重试
</div>

`Enterprise`

Account Activity API 的 Enterprise 级别有一个优势，就是为 webhook 事件提供重试机制。如果未收到表示“成功”的 HTTP 200 响应状态码，X 服务器会启动重试机制，在五分钟内最多重新发送该 webhook 事件三次。这个 webhook 事件重试服务有助于在发生网络问题，以及客户端服务中断或进行部署期间，提升可靠性并实现事件恢复。
 

<div id="what-are-retries">
  ### 什么是重试？
</div>

当客户端的 Web 应用未对账户活动 webhook 事件返回“成功”的 200 响应时，Account Activity API 会提供重试机制。当客户端未确认成功接收某个事件时，X 会假定该事件未被接收。如果收到的是非 200 响应、在三秒内未收到响应，或者完全没有收到响应，我们会重试该请求，并将该请求保持在打开状态三秒钟。这意味着，在两次尝试中，你大约有五秒时间来进行响应，以接收我们尝试发送到你 webhook URL 的活动事件。如果你的服务器没有响应或返回的是暂时性错误，我们会在五分钟内持续重试。总共会有三次重试尝试来确认验证成功。这样可以提供冗余和保障，确保你接收到所有 webhook 事件。请注意，启用重试的订阅会针对其 webhook 上所有已订阅用户的任何/所有活动接收被重试的事件。

如果你在这八次尝试内未确认验证，Account Activity API 将不再提供该活动数据。 

<div id="retry-timeline">
  ### 重试时间线
</div>

Account Activity API 会在五分钟内最多重试三次，直到收到 200 响应为止。有关更多详细信息，请参阅下表。大约五分钟之后，将无法再通过 Account Activity API 重新发送该活动。你需要使用其他 X 端点来收集遗漏的数据。例如，可以使用 [search APIs](/zh/x-api/enterprise-gnip-2.0/fundamentals/search-api) 来检索相关的帖子、转发、引用帖子、提及和回复。遗漏的私信可以通过[此端点](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events)检索。

<div id="retries-timeline">
  #### 重试时间线
</div>

|     |
| :--- |
| 活动创建后，Account Activity API 向 webhook URL 发送 POST 请求，并在三秒后超时。 |
| 在上一次超时结束后等待三秒，然后 Account Activity API 再次向 webhook URL 发送 POST 请求，并在三秒后超时。 |
| 在上一次超时结束后等待 27 秒，然后 Account Activity API 再次向 webhook URL 发送 POST 请求，并在三秒后超时。 |
| 在上一次超时结束后等待 242 秒，然后 Account Activity API 再次向 webhook URL 发送 POST 请求，并在三秒后超时。 |
| 此后，Account Activity API 将停止尝试发送 POST。客户端必须使用其他 X 端点来恢复数据。 |

<div id="account-activity-data-object-structure">
  ## Account Activity 数据对象结构
</div>

| Object | Details |
| :--- | :--- |
| for&#95;user&#95;id | 标识该事件所关联的订阅用户。 |
| is&#95;blocked&#95;by | （条件）仅当其他用户提及你订阅的用户时显示。仅在帖子提及事件中且为 true 时才会包含。 |
| source | 执行动作的用户。例如，进行关注、屏蔽或静音操作的用户是 source 用户。 |
| target | 动作所作用到的用户。例如，被关注、被屏蔽或被静音的用户是 target 用户。 |

**可用活动**

| Message Type | Details |
| :--- | :--- |
| [tweet&#95;create&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#tweet-create-events-posts-retweets-replies-quotetweets) | 当订阅用户发帖，或由/针对订阅用户发生以下任一操作时的帖子状态负载：发帖、转发、回复、@ 提及、引用帖子、转发引用帖子。 |
| [favorite&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#favorite-events) | 包含用户和目标用户的“收藏”（点赞）事件状态。 |
| [follow&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#follow-events) | 包含用户和目标用户的关注事件。 |
| [unfollow&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#unfollow-events) | 包含用户和目标用户的取消关注事件。 |
| [block&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#block-events) | 包含用户和目标用户的屏蔽事件。 |
| [unblock&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#unblock-events) | 包含用户和目标用户的取消屏蔽事件。 |
| [mute&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#mute-events) | 包含用户和目标用户的静音事件。 |
| [unmute&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#unmute-events) | 包含用户和目标用户的取消静音事件。 |
| [user&#95;event](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#user-event) | 当用户移除应用授权且订阅被自动删除时发送的撤销事件。 |
| [direct&#95;message&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-events) | 当私信被发送或接收时，包含用户和目标用户的私信状态。 |
| [direct&#95;message&#95;indicate&#95;typing&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-indicate-typing-events) | 包含用户和目标用户的“私信正在输入”事件。 |
| [direct&#95;message&#95;mark&#95;read&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-mark-read-events) | 包含用户和目标用户的私信已读事件。 |
| [tweet&#95;delete&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#tweet-delete-events) | 已删除帖子通知，以便更轻松地保持合规性。 |

**负载示例**

请参阅下方针对上表中每个 Account Activity 事件的负载示例。

<div id="tweet_create_events-posts-retweets-replies-quotetweets">
  #### tweet&#95;create&#95;events (帖子、转发帖子、回复、引用帖子)
</div>

```
{
	"for_user_id": "2244994945",
	"tweet_create_events": [
	  {
		<Tweet Object>
	  }
	]
}
```

<div id="tweet_create_events-mentions">
  #### tweet&#95;create&#95;events (@ 提及)
</div>

```
{
	"for_user_id": "2244994945",
	"user_has_blocked": "false",
	"tweet_create_events": [
	  {
		<Tweet Object>
	  }
	]
}
```

<div id="favorite_events">
  #### favorite&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"favorite_events": [{
		"id": "a7ba59eab0bfcba386f7acedac279542",
		"created_at": "Mon Mar 26 16:33:26 +0000 2018",
		"timestamp_ms": 1522082006140,
		"favorited_status": {
			<Tweet Object>
		},
		"user": {
			<User Object>
		}
	}]
}
```

<div id="follow_events">
  #### follow&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"follow_events": [{
			"type": "follow",
			"created_timestamp": "1517588749178",
			"target": {
				<User Object >
			},
			"source": {
				< User Object >
			}
		]
	}
}
```

<div id="unfollow_events">
  #### unfollow&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"follow_events": [{
			"type": "unfollow",
			"created_timestamp": "1517588749178",
			"target": {
				<User Object >
			},
			"source": {
				< User Object >
			}
		]
	}
}
```

<div id="block_events">
  #### block&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"block_events": [{
		"type": "block",
		"created_timestamp": "1518127020304",
		"source": {
			<User Object>
		},
		"target": {
			<User Object>
		}
	}]
}
```

<div id="unblock_events">
  #### unblock&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"block_events": [{
		"type": "unblock",
		"created_timestamp": "1518127020304",
		"source": {
			<User Object>
		},
		"target": {
			<User Object>
		}
	}]
}
```

<div id="mute_events">
  #### mute&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"mute_events": [
		{
			"type": "mute",
		  	"created_timestamp": "1518127020304",
			"source": {
				<User Object>
			},
			"target": {
				<User Object>
			}
		}
	]
}
```

<div id="unmute_events">
  #### unmute&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"mute_events": [
		{
			"type": "unmute",
		  	"created_timestamp": "1518127020304",
			"source": {
				<User Object>
			},
			"target": {
				<User Object>
			}
		}
	]
}
```

<div id="user_event">
  #### user&#95;event
</div>

```
{
	"user_event": {
		"revoke": {
			"date_time": "2018-05-24T09:48:12+00:00",
			"target": {
				"app_id": "13090192"
			},
			"source": {
				"user_id": "63046977"
			}
		}
	}
}
```

<div id="direct_message_events">
  #### direct&#95;message&#95;events
</div>

```
{
  	"for_user_id": "4337869213",
	"direct_message_events": [{
		"type": "message_create",
		"id": "954491830116155396",
		"created_timestamp": "1516403560557",
		"message_create": {
			"target": {
				"recipient_id": "4337869213"
			},
			"sender_id": "3001969357",
			"source_app_id": "13090192",
			"message_data": {
				"text": "你好世界！",
				"entities": {
					"hashtags": [],
					"symbols": [],
					"user_mentions": [],
					"urls": []
				}
			}
		}
	}],
	"apps": {
		"13090192": {
			"id": "13090192",
			"name": "FuriousCamperTestApp1",
			"url": "https://x.com/furiouscamper"
		},
		"users": {},
		"3001969357": {
			"id": "3001969357",
			"created_timestamp": "1422556069340",
			"name": "Jordan Brinks",
			"screen_name": "furiouscamper",
			"location": "Boulder, CO",
			"description": "Alter Ego - X PE opinions-are-my-own",
			"url": "https://t.co/SnxaA15ZuY",
			"protected": false,
			"verified": false,
			"followers_count": 22,
			"friends_count": 45,
			"statuses_count": 494,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
		},
		"4337869213": {
			"id": "4337869213",
			"created_timestamp": "1448312972328",
			"name": "Harrison Test",
			"screen_name": "Harris_0ff",
			"location": "Burlington, MA",
			"protected": false,
			"verified": false,
			"followers_count": 8,
			"friends_count": 8,
			"profile_image_url": "null",
			"statuses_count": 240,
			"profile_image_url_https": "https://abs.twimg.com/sticky/default_profile_images/default_profile_normal.png"
		}
	}
}
```

<div id="direct_message_indicate_typing_events">
  #### direct&#95;message&#95;indicate&#95;typing&#95;events
</div>

```
{
	"for_user_id": "4337869213",
	"direct_message_indicate_typing_events": [{
		"created_timestamp": "1518127183443",
		"sender_id": "3284025577",
		"target": {
			"recipient_id": "3001969357"
		}
	}],
	"users": {
		"3001969357": {
			"id": "3001969357",
			"created_timestamp": "1422556069340",
			"name": "Jordan Brinks",
			"screen_name": "furiouscamper",
			"location": "Boulder, CO",
			"description": "Alter Ego - X PE opinions-are-my-own",
			"url": "https://t.co/SnxaA15ZuY",
			"protected": false,
			"verified": false,
			"followers_count": 23,
			"friends_count": 47,
			"statuses_count": 509,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
		},
		"3284025577": {
			"id": "3284025577",
			"created_timestamp": "1437281176085",
			"name": "Bogus Bogart",
			"screen_name": "bogusbogart",
			"protected": true,
			"verified": false,
			"followers_count": 1,
			"friends_count": 4,
			"statuses_count": 35,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/763383202857779200/ndvZ96mE_normal.jpg"
		}
	}
}
```

<div id="direct_message_mark_read_events">
  #### direct&#95;message&#95;mark&#95;read&#95;events
</div>

```
{
	"for_user_id": "4337869213",
	"direct_message_mark_read_events": [{
		"created_timestamp": "1518452444662",
		"sender_id": "199566737",
		"target": {
			"recipient_id": "3001969357"
		},
		"last_read_event_id": "963085315333238788"
	}],
	"users": {
		"199566737": {
			"id": "199566737",
			"created_timestamp": "1286429788000",
			"name": "Le Braat",
			"screen_name": "LeBraat",
			"location": "Denver, CO",
			"description": "data by day @X, design by dusk",
			"protected": false,
			"verified": false,
			"followers_count": 299,
			"friends_count": 336,
			"statuses_count": 752,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/936652894371119105/YHEozVAg_normal.jpg"
		},
		"3001969357": {
			"id": "3001969357",
			"created_timestamp": "1422556069340",
			"name": "Jordan Brinks",
			"screen_name": "furiouscamper",
			"location": "Boulder, CO",
			"description": "Alter Ego - X PE opinions-are-my-own",
			"url": "https://t.co/SnxaA15ZuY",
			"protected": false,
			"verified": false,
			"followers_count": 23,
			"friends_count": 48,
			"statuses_count": 510,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
		}
	}
}
```

<div id="tweet_delete_events">
  #### tweet&#95;delete&#95;events
</div>

```
{
    "for_user_id": "930524282358325248",
    "tweet_delete_events": [
{
        "status": {
            "id": "1045405559317569537",
            "user_id": "930524282358325248"
        },
        "timestamp_ms": "1432228155593"
    }
   ]
}
```

<div id="account-activity-replay-api">
  ## Account Activity Replay API
</div>

`Enterprise`

Account Activity Replay API 是一款数据恢复工具，可让你检索最早可追溯到五天前的事件。它应在你的 [webhook](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) 服务器错过事件时用于恢复数据——无论是由于断连时间超过了 [retry window](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries)，还是在那些需要几天时间才能将系统恢复正常的灾难恢复场景中。

Account Activity Replay API 是为在一段时间内未能摄取 [activities](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity) 的任何场景而开发的。它会将 activities 发送到用于原始实时投递的同一个 webhook。该产品是恢复工具而非回填工具，这意味着只有在曾尝试过投递的事件才会被重放。Account Activity Replay API 无法为订阅创建时间之前的时间段投递事件。

<div id="using-account-activity-replay-api">
  ### 使用 Account Activity Replay API
</div>

如果你的账户已配置 Replay 功能，你可以以类似调用 Account Activity API 的方式发起请求。需要特别注意的是，你的请求必须指定一个 webhook id 参数，以指明你希望重放哪个 webhook 的活动。换句话说，Replay 请求会让 Account Activity Replay API 根据 webhook id 和应用 id，从起始日期时间到结束日期时间检索事件。

请注意，所有时间均应为 UTC。相关活动会通过与该 id 关联的已注册 webhook 投递，速率最高可达每秒 2,500 个事件。同时请记住，同一时间每个 webhook 只能运行一个 Replay 任务，但在该 webhook 上、处于你指定日期/时间范围内的所有处于活动状态的订阅，都会被重放。

事件的投递会从指定时间段内的第一个（最早）分钟开始，按时间顺序持续进行（尽可能保持顺序），直到最后一分钟的事件被投递完成。此时，Replay 会向该 webhook 投递一个[任务完成事件](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#job-completed-successfully-message)。由于我们按时间顺序投递活动，如果在起始时间附近几乎没有或完全没有匹配结果，那么在首次结果被投递前，很可能会有一段时间的等待。

<div id="limitations">
  ### 限制
</div>

Replay 旨在作为一种工具，方便地恢复最早可追溯到五天前的活动，但它不会提供早于某个订阅创建时间的事件。比如，如果你在三天前添加了一个新订阅，并运行了一个时间范围为从今天往前五天的 Replay 作业，你只会收到该新订阅在这三天内生效期间的数据。

<div id="data-availability-and-types">
  ### 数据可用性和类型
</div>

Account Activity Replay API 最多支持回放自你发起请求时起往前五天内的活动，新产生的活动通常会在某个活动创建后大约 10 分钟变为可回放。你可以在该五天时间窗口内，通过请求中的 from&#95;date 和 to&#95;date 参数指定一个时间范围来发起请求。在开通 Replay 访问权限之前已投递的事件无法被回放。比如，如果你的账户在 2019 年 6 月 1 日协调世界时 (UTC) 下午 3:30 被启用 Account Activity Replay API 访问权限，则你将无法使用 Replay 来检索该日期和时间之前发生的任何事件。

继续阅读 [Account Activity Replay API 参考](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated)

<div id="migration-introduction">
  ## 迁移简介
</div>

**我们已于 2018 年下线了 Site Streams、User Streams，以及 Account Activity API - DM Only 的标准测试版本产品。如果你一直在使用这些产品，请务必迁移到 Account Activity API 的 premium 或 Enterprise 版本。**

**我们也已经下线了旧版 Direct Message 端点。如果你一直在使用这些端点，请务必迁移到新的 DM 端点，或者迁移到 Account Activity API 的 premium 或 Enterprise 版本。**

**请查阅[此公告](https://devcommunity.x.com/t/details-and-what-to-expect-from-the-api-deprecations-this-week-on-august-16-2018/110746)了解更多信息。**

以下端点将受到这些变更的影响：

* User Streams
* Site Streams
* GET direct&#95;messages
* GET direct&#95;messages/sent
* GET direct&#95;messages/show
* POST direct&#95;messages/new
* POST direct&#95;messages/destroy
   

我们提供了新的端点和服务，能够提供类似的访问方式，并且对于 Direct Messages，还增加了一些新功能：

* Account Activity API 的 [enterprise](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) 和 [premium](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index) 版本
* [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events)
* [GET direct&#95;messages/events/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event)
* [POST direct&#95;messages/events/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event)
* [POST direct&#95;messages/events/destroy](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/delete-message-event)

为帮助你顺利迁移到这些新的端点和服务，我们提供了两份迁移指南：

* [Account Activity API 迁移指南](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#migration-guide-moving-from-user-streams-site-streams-to-account-activity-api)，适用于从 User Streams 和 Site Streams 迁移到我们全新的基于 webhooks 的服务
* [Direct Message 迁移指南](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/guides/direct-message-migration)，适用于在不同 Direct Message REST 端点之间迁移
   

此外，我们还有一[系列视频](https://www.youtube.com/playlist?list=PLFKjcMIU2WshGG6Yj940XM7Z6BFs1zfBg)，介绍 Account Activity API 以及如何开始使用。

最后，我们还提供了代码示例，以进一步加深你的理解并帮助你快速上手：

* [Account Activity Dashboard](https://github.com/xdevplatform/Account-Activity-dashboard) 是一个示例 Node.js Web 应用，包含用于开始使用 Account Activity API 的辅助脚本。
* [SnowBot](https://github.com/xdevplatform/SnowBotDev) 是一个使用 Account Activity API 和 REST Direct Message 端点的示例聊天机器人。它使用 Ruby 编写，基于 Sinatra Web 应用框架，并部署在 Heroku 上。

<div id="migration-guide-moving-from-user-streamssite-streams-to-account-activity-api">
  ## 迁移指南：从 User Streams/Site Streams 迁移到 Account Activity API
</div>

**自 2018 年 8 月 23 日起，我们已停用 Site Streams 和 User Streams。请务必迁移到 Account Activity API。**

**请查阅[本公告](https://devcommunity.x.com/t/details-and-what-to-expect-from-the-api-deprecations-this-week-on-august-16-2018/110746)以了解更多信息。**

本指南旨在帮助你从旧版 User Streams 和 Site Streams API 迁移到其替代方案 Account Activity API。下文将介绍变更摘要、新功能列表，以及有助于完成迁移过程的关键差异和注意事项。若需要从基础 DM 端点迁移的指导，请参阅[私信迁移指南](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/guides/direct-message-migration)。

<div id="summary-of-changes">
  ### 变更摘要
</div>

与 User Streams 和 Site Streams 使用的流式连接不同，Account Activity API 会通过 webhooks 向你推送已通过身份验证且已订阅的账号事件。

<div id="deprecated-apis">
  #### 已弃用 API
</div>

GET user

GET site（包括控制流端点：GET site/c/:stream&#95;id、GET site/c/:stream&#95;id/info.json、GET site/c/:stream&#95;id/friends/ids.json、POST site/c/:stream&#95;id/add&#95;user.json、POST /site/c/:stream&#95;id/remove&#95;user.json）

<div id="replacement-apis">
  #### 替代的 API
</div>

[Enterprise Account Activity API - 所有活动](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api)

<div id="differences-migration-considerations">
  ### 差异与迁移注意事项
</div>

**API 格式：** 新的 Account Activity API 的运作方式与 User Streams 和 Site Streams 不同。你需要修改你的 Web 应用，以通过 webhooks 接收数据。你可以在[这里](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks)找到有关 webhooks 的更多信息。

**可用的数据：** 你会注意到的另一个关键差异体现在传递的数据方面。X 将不再发送来自你在 X 上关注的人的事件（也就是你的主页时间线）。这是一个有意为之的改动，我们今后也不打算改变这一点。

**可靠性：** 与流式传输不同，webhooks 支持确认投递，并可以重试未能成功到达 webhook URL 的 POST 活动。这样即使出现短暂断连或停机，也能进一步确保应用接收到所有相关活动。

<div id="new-features">
  ### 新功能
</div>

Account Activity API 提供了许多新功能，其中最显著的一点是现在通过 webhooks 而不是流式传输来推送数据。与流式传输相比，webhooks 有许多优势，其中最突出的是速度和可靠性。API 会在有 JSON 事件产生时将数据发送给你，你不再需要维护一个持久连接或轮询端点。这样可以减少对冗余机制的需求，并整体提升效率。关于 webhooks 的更多信息，请参阅[技术文档](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks)。

<div id="managing-user-subscriptions">
  ### 管理用户订阅
</div>

Account Activity API 允许在单个已注册的 webhook 上创建多个订阅。这样可以将多个用户订阅的活动发送到同一个终端，类似 Site Streams 的架构，但采用的是 webhooks。也就是说，你可以在与 webhook 连接解耦的情况下，结合订阅上限独立跟踪各个订阅。这也有利于扩展，使单个 webhook 能够从只有一两个订阅扩展到成千上万的订阅。

<div id="how-to-migrate">
  ### **如何迁移**
</div>

<div id="follow-the-steps-below-to-easily-migrate-from-the-site-streams-api-to-the-account-activity-api">
  ### **按照以下步骤，轻松将 Site Streams API 迁移到 Account Activity API**
</div>

**步骤 1：选择套餐**

根据你当前使用 User Streams 或 Site Streams 的方式，你应当考虑迁移到 Account Activity API 的 Enterprise 或 Premium 版本。请考虑你当前支持的应用数量或已授权用户数量，并根据所需的规模和可靠性进行合理扩展。在决定最适合你需求的套餐时，值得考虑的因素包括：

* 所需的 webhook 数量
* 你的应用当前/预期管理的订阅数/授权用户数
* 当前 X 客户端应用的数量
* 你希望从 X 获得的支持级别（论坛支持或 Enterprise 级别的一对一托管支持）
* 各套餐的价格

**步骤 2：** **在开发者门户中检查你的 X 应用设置**

当前用于 User Streams 或 Site Streams 的 [X app](/zh/resources/fundamentals/developer-apps) 会在 [开发者门户](/zh/resources/fundamentals/developer-portal) 中列在所属用户名下。该 X 应用也可以用于 Account Activity API，以保留该应用的已授权用户。你也可以创建一个新的应用，并在需要时让用户为这个新应用重新授权。如果你是代表企业创建新应用，建议使用企业的 X @handle 账号来创建该应用。

* 在 X 应用页面中的 [permissions](/zh/resources/fundamentals/developer-apps#app-permissions) 选项卡上启用“Read, Write and Access direct messages”。
  *请注意，更改这些设置并不会对过去产生追溯效果，任何已授权用户会保留其在授权当时的权限设置。如果某个用户尚未授予你读取、写入和访问私信的权限，你需要让该用户重新授权你的应用。
* 如果你不熟悉 [X Sign-in](/zh/resources/fundamentals/authentication#log-in-with-x) 以及用户上下文在 X API 中的工作方式，请查阅 [Obtaining Access Tokens](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks)。
* 在 “Keys and Tokens” 选项卡底部为 X 应用所有者生成访问令牌。在同一选项卡上记下你的 Consumer Key、Consumer Secret、Access Token 和 Access Token Secret。你在使用 API 时需要这些信息。
* 使用你的 Consumer Key 和 Consumer Secret 为 [application-only](/zh/resources/fundamentals/authentication#bearer-token-also-known-as-app-only) API 方法生成 Bearer Token。

**步骤 3：设置并配置你的 Webhook**

* 创建一个带有端点的 Web 应用，将其作为 webhook 来接收事件（例如：https://your&#95;domain.com/webhook/twitter 或 https://webhooks.your&#95;domain.com）。

* 在创建 webhook 时使用你的 Consumer Key、Consumer Secret、Access Token 和 Access Token Secret。请注意，你的端点必须返回一个包含 `response_token` 的 JSON 响应，该 `response_token` 是使用 `crc_token` 和你的应用 Consumer Secret 创建的、经 base64 编码的 HMAC SHA-256 哈希值。

* 查阅 [Securing Webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks) 文档，特别注意 Challenge Response Check (CRC) 的要求。

* 确保你的 webhook 支持用于接收事件的 POST 请求，以及用于 CRC 的 GET 请求。

* 确保你的 webhook 具有较低的延迟（响应 POST 请求的时间小于 3 秒）。

**步骤 4：验证你的 Webhook 设置**

* Webhook API 将通过两种方式保护你的 webhook：

               - 要求发起挑战响应检查，以验证 webhook 所有者就是该 Web 应用的所有者。

               - 在每个发送到你 Web 应用的 POST 请求中包含签名头部，以便验证请求来源。

* 为验证你同时是 Web 应用的所有者以及 webhook URL 的所有者，X 会执行一次 Challenge Response Check (CRC)，这与循环冗余校验（cyclic redundancy check）不同。
* 一条带有名为 `crc_token` 参数的 GET 请求会被发送到你的 webhook URL。你的端点必须返回一个包含 `response_token` 的 JSON 响应，该 `response_token` 是使用 `crc_token` 和你的应用 Consumer Secret 创建的、经 base64 编码的 HMAC SHA-256 哈希值。
* 你应当预期每个传入的 CRC 请求都会携带不同的 `crc_token`。在计算中，应将 `crc_token` 作为消息内容，而将你的 Consumer Secret 作为密钥。
* 如果响应无效，将停止向已注册的 webhook 发送事件。

**步骤 5：为每个 User Stream 或 Site Streams 授权用户创建订阅**

从 User Streams 迁移到 Account Activity API：

* 获取你当前在 User Streams 上的用户订阅列表
* 使用以下请求设置新的 Account Activity API 订阅：  *POST account&#95;activity/all/:env&#95;name/subscriptions*
* 使用以下请求确认你的 Account Activity API 订阅：  &#95;GET account&#95;activity/all/:env&#95;name/subscriptions/list
   &#95;

从 Site Streams 迁移到 Account Activity API：（使用控制流）：

* 使用以下请求获取你当前在 Site Streams 上的订阅列表：  *GET /1.1/site/c/:stream&#95;id/info.json*
* 使用以下请求设置新的 Account Activity API 订阅：  *POST account&#95;activity/all/:env&#95;name/subscriptions*
* 使用以下请求确认你的 Account Activity API 订阅：  &#95;GET account&#95;activity/all/:env&#95;name/subscriptions/list
   &#95;

注册 Webhook 并创建订阅（不是从 Site Streams 或 User Streams 迁移）

* 使用 [POST webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) 在你的应用中注册 webhook URL，并接收一个 webhook&#95;id。
* 使用返回的 webhook&#95;id，通过 [POST webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) 添加用户订阅。

<div id="the-account-activity-dashboard-sample-account-activity-api-application">
  ### Account Activity 仪表盘（Account Activity API 示例应用）
</div>

我们创建了一个示例应用，让你可以更快速地测试 Account Activity API：   

* 在[此处](https://github.com/xdevplatform/Account-Activity-dashboard)下载 Account Activity Dashboard 示例应用（基于 Node.js）
* 按照 README 中的说明安装并启动该应用
* 应用启动后，你可以通过界面轻松设置 webhook 并创建新的订阅

<div id="available-activities">
  ### 可用活动
</div>

| 消息类型 | 详情 |
| :--- | :--- |
| [tweet&#95;create&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#tweet-create-events-posts-retweets-replies-quotetweets) | 当订阅用户发起或收到以下任一操作时的帖子状态有效负载：帖子、转帖、回复、@提及、引用帖子 |
| [favorite&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#favorite-events) | 包含用户和目标用户信息的点赞（Favorite）事件状态。 |
| [follow&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#follow-events) | 包含用户和目标用户信息的关注事件。 |
| [block&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#block-events) | 包含用户和目标用户信息的屏蔽事件。 |
| [mute&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#mute-events) | 包含用户和目标用户信息的静音事件。 |
| [direct&#95;message&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-events) | 包含用户和目标用户信息的私信状态。 |
| [direct&#95;message&#95;indicate&#95;typing&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-indicate-typing-events) | 包含用户和目标用户信息的私信输入中事件。 |
| [direct&#95;message&#95;mark&#95;read&#95;events](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-mark-read-events) | 包含用户和目标用户信息的私信已读事件。 |

<div id="deprecated-streaming-message-types">
  ### 已弃用的流式消息类型
</div>

|     |     |
| :--- | :--- |
| 空行 | 在 Account Activity API 中将不再发送空行，因为在 User Streams 和 Site Streams 中，空行被用作保活消息。 |
| 限制通知 | 限制通知将不再发送到指定的 webhook。相反，用户可以调用 API 来获取当前可用账号的使用情况。这些信息也将在未来的某个时间点在开发者门户中提供。 |
| 断开连接消息 | 将不再需要断开连接通知，因为 webhook 不依赖活动的连接。 |
| 阻塞警告 | 将不再需要阻塞警告，因为 webhook 不依赖能够处理大量传入消息的活动连接。 |
| 好友列表 | 将不再主动发送好友列表。现在会提供一个 REST 端点来获取此信息。 |

<div id="deprecated-event-types">
  ### 已弃用的事件类型
</div>

|     |     |     |     |     |
| :--- | :--- | :--- | :--- | :--- |
| **描述** | **事件名称** | **来源** | **目标** | **目标对象** |
| 用户删除一个帖子 | delete | 当前用户 | 当前用户 | Post |
| 被关注用户删除一个帖子 | delete | 被关注用户 | 被关注用户 | Post |
| 用户取消收藏一个帖子 | unfavorite | 当前用户 | 帖子作者 | Post |
| 用户的帖子被取消收藏 | unfavorite | 取消收藏的用户 | 当前用户 | Post |
| 用户取消关注某人 | unfollow | 当前用户 | 被关注用户 | Null |
| 用户创建一个列表 | list&#95;created | 当前用户 | 当前用户 | List |
| 用户删除一个列表 | list&#95;destroyed | 当前用户 | 当前用户 | List |
| 用户编辑一个列表 | list&#95;updated | 当前用户 | 当前用户 | List |
| 用户将某人添加到列表 | list&#95;member&#95;added | 当前用户 | 被添加用户 | List |
| 用户被添加到列表 | list&#95;member&#95;added | 添加者 | 当前用户 | List |
| 用户将某人从列表中移除 | list&#95;member&#95;removed | 当前用户 | 被移除用户 | List |
| 用户被从列表中移除 | list&#95;member&#95;removed | 移除者 | 当前用户 | List |
| 用户订阅一个列表 | list&#95;user&#95;subscribed | 当前用户 | 列表所有者 | List |
| 用户的列表被订阅 | list&#95;user&#95;subscribed | 订阅者 | 当前用户 | List |
| 用户取消订阅一个列表 | list&#95;user&#95;unsubscribed | 当前用户 | 列表所有者 | List |
| 用户的列表被取消订阅 | list&#95;user&#95;unsubscribed | 取消订阅者 | 当前用户 | List |
| 用户更新个人资料 | user&#95;update | 当前用户 | 当前用户 | Null |
| 用户更新账号保护状态 | user&#95;update | 当前用户 | 当前用户 | Null |

<div id="direct-message-migration-guide">
  ## 私信迁移指南
</div>

**自 2018 年 9 月 17 日起，我们已停用旧版私信（Direct Message）端点。
如果你一直在使用这些端点，请务必迁移到新的私信端点或 Account Activity API。**

**请查看 [此公告](https://devcommunity.x.com//t/details-and-what-to-expect-from-the-api-deprecations-this-week-on-august-16-2018/110746) 以了解更多信息。**

本指南旨在帮助你从旧版私信 REST API 迁移到其已结束测试阶段的增强版替代接口。下文将介绍更改摘要、新功能列表，以及有助于过渡的关键差异和注意事项。新的私信端点现已向所有开发者开放。关于从 User Streams 或 Site Streams 迁移的指导，请参阅[迁移到 Account Activity API 的指南](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#migration-guide-moving-from-user-streams-site-streams-to-account-activity-api)。

* [更改摘要](#summary)
* [新功能](#features)
* [发送私信](#sending)
* [接收私信](#receiving)
* [删除私信](#deleting)

<div id="summary-of-changes">
  ### 变更摘要
</div>

如果你仍在使用以下 DM 端点，则必须迁移到对应的新端点。 

| 已弃用端点 | 对应的新端点 |
| :--- | :--- |
| [POST direct&#95;messages/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event) | [POST direct&#95;messages/events/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event) |
| [GET direct&#95;messages/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event) | [GET direct&#95;messages/events/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event) |
| [GET direct&#95;messages](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events) | [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events) |
| [GET direct&#95;messages/sent](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event) | [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events) |
| [POST direct&#95;messages/destroy](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/delete-message-event) | [DELETE direct&#95;messages/events/destroy](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/delete-message-event "GET direct_messages/events/list") |

<div id="new-features">
  ### 新功能
</div>

新的私信 API 端点支持多项新功能，并改进了对历史私信的访问。新功能包括：

* 支持媒体附件（图片、GIF 和视频）。
* 可以通过预定义的选项列表提示用户选择结构化回复。
* 最长可访问过去 30 天内的私信。

有关新的私信功能的完整列表以及其他新 API 端点，请参阅[技术文档](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/overview)。
 

<div id="differences-migration-considerations">
  ### 差异与迁移注意事项
</div>

新的 API 端点与之前对应的端点在行为上有很大不同。仅更新端点 URL 会导致应用程序出错。在为迁移更新应用程序时，请注意以下事项。

<div id="new-direct-message-object">
  #### 新的私信对象
</div>

你很可能首先注意到的是私信对象的新结构。这个新的 Message Create 对象结构是为支持 [Quick Replies](https://developer.x.com/en/docs/x-api/v1/direct-messages/quick-replies/overview) 和 [Attachments](https://developer.x.com/en/docs/x-api/v1/direct-messages/message-attachments/overview) 等新功能而引入的。新的对象还包含一个更小、更精简的用户对象。你的应用需要在解析以及（可能）数据模型或存储层面进行更新，以适配这一新的对象结构。关于每个属性的说明，请参阅 [Message Create 对象的完整文档](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/guides/message-create-object)。

**Message Create 对象示例**

```json
{
      "type": "message_create",
      "id": "1234858592",
      "created_timestamp": "1392078023603",
      "initiated_via": {
        "tweet_id": "123456",
        "welcome_message_id": "456789"
      },
      "message_create": {
        "target": {
          "recipient_id": "1234858592"
        },
        "sender_id": "3805104374",
        "source_app_id": "268278",
        "message_data": {
          "text": "Blue Bird",
          "entities": {
            "hashtags": [],
            "symbols": [],
            "urls": [],
            "user_mentions": [],
          },
          "quick_reply_response": {
            "type": "options",
            "metadata": "external_id_2"
          },
          "attachment": {
            "type": "media",
            "media": {
             ...
            }
          }
        }
      }
```

<div id="summary">
  #### 摘要
</div>

* 全新的私信（Direct Message）对象结构。
* 精简的用户对象。
* 新增信息（快速回复响应、附件等）。

<div id="sending-direct-messages">
  ### 发送私信
</div>

[POST direct&#95;messages/events/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event) 是发送私信的直接替代端点。这个端点最大的变化在于，现在所有信息都以 JSON 格式包含在 POST 请求体中，而不再通过单独的 POST 参数传递。

**Twurl 请求示例**

```bash
twurl -A 'Content-type: application/json' -X POST /1.1/direct\_messages/events/new.json -d '{"event": {"type": "message\_create", "message\_create": {"target": {"recipient\_id": "4534871"}, "message_data": {"text": "Hello World!"}}}}'
```

请注意，在上述请求中，`Content-Type` 被设置为 `application/json`，而不是 `application/x-www-form-urlencoded`。另外，如果你在构造 OAuth 1.0a 签名，请注意在生成签名时不会包含 JSON 请求体。大多数 OAuth 库已经考虑了这一点。如果你使用 [twurl](https://github.com/twitter/twurl)，请确保使用的版本至少为 0.9.3。

<div id="summary">
  #### 摘要
</div>

* 消息在 JSON POST 正文中定义
* Content-Type 请求头必须设置为 application/json
* JSON 正文不会参与 OAuth 签名的生成。
   

<div id="retrieving-direct-messages">
  ### 检索私信
</div>

现在可以通过单个 API 端点来检索历史私信： [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events)。这个新端点的一个主要区别在于，它现在会按时间倒序返回已发送和已接收的消息。这可以让你更容易重建一段会话。不过，如果你只想获取已发送或已接收的消息，就需要通过引用 `sender_id` 属性对响应结果进行后处理。

现在的分页是基于游标值而不是某条私信的 ID。每个响应都会返回一个游标属性。[GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events) 将返回最多过去 30 天的消息，而不管过去 30 天内存在多少条消息。如果未返回游标，则表示没有更多消息可返回。使用 [GET direct&#95;messages/events/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event) 访问单条私信的方法保持不变，不过如前所述，返回的私信对象结构已经发生变化。

最后，对私信的实时访问现在将通过 webhook 配合 [Account Activity API](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity) 来实现。关于从 User Streams 或 Site Streams 迁移的指导，请参阅 Account Activity API 迁移指南以了解更多信息。

<div id="summary">
  #### 摘要
</div>

* 已发送和已接收的消息现在由同一个端点返回。
* 最多返回最近 30 天内的消息。
* 基于游标的分页。
* 通过 webhook 实时访问私信。

<div id="deleting-direct-messages">
  ### 删除私信
</div>

现在可以通过 DELETE direct&#95;messages/events/destroy 删除私信。接口基本保持不变，仍然需要提供要删除消息的 ID。主要区别在于，该 endpoint 现在需要使用 DELETE 请求，而不再是使用 POST 请求。

已删除私信在官方 X 客户端中的呈现方式保持不变。私信只会从当前用户上下文对应的界面中移除，对话中的其他成员仍然可以访问该私信。

<div id="summary">
  #### 摘要
</div>

* 删除一条私信需要提供该消息的 id。
* 新端点需要发送 DELETE 请求。
* 已删除私信在官方 X 客户端中的呈现方式保持不变。

**关于迁移到新的私信端点有疑问？**
请在开发者社区论坛 [devcommunity.com](https://devcommunity.x.com/) 提出你的问题。

<div id="frequently-asked-questions">
  ## 常见问题解答
</div>

<div id="general">
  ### 通用
</div>

**使用 Account Activity API 有哪些优势？**

Account Activity API 使用 webhooks，这意味着与流式 API 不同，我们不要求你保持一个打开的连接来接收我们发送给你的信息。Webhooks 也不同于 REST API，因为你不需要每 15 分钟轮询我们数百次来获取你关心的数据。这样可以提高用户与你的应用之间的效率，因为它会在事件发生时立即投递数据。

Account Activity API 具有以下优点：

1. **速度**：我们以 X 的速度向你投递数据。
2. **简单**：我们通过单一的 webhook 连接向你投递某个账号的所有事件。API 中投递的活动包括 Posts、@mentions、replies、Retweets、Quote Tweets、Retweets of Quote Tweets、favorites、Direct Messages sent、Direct Messages received、follows、blocks、mutes。
3. **可扩展性**：对于你管理的账号，你可以接收其所有活动，而不会受到任何事件上限或速率限制的约束。

Account Activity API 以高级沙盒、高级付费和 Enterprise 形式提供，因此当你需要为责任相关功能或额外功能添加更多账号时，可以按需扩展。

要开始使用，请从 [GitHub](https://github.com/xdevplatform/account-activity-dashboard) 下载示例代码片段。
 

**如何确定哪个产品层级最适合我？**

请阅读我们的 [Account Activity API Overview](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity) 页面，了解 Premium 选项与 Enterprise 选项之间的差异。 
 

**Premium 环境和 Enterprise webhook 有什么区别？**

没有区别。每个 Premium 环境都会有其自己的 webhook&#95;id。
 

**我需要为 Account Activity API 准备开发、预发布和生产环境，这可以实现吗？**

可以！在 Account Activity API 的付费层级（付费 Premium 和 Enterprise）中，你可以注册多个 webhook URL，并通过 API 方法分别管理每个 URL 的订阅。此外，可以将多个客户端应用添加到允许列表中，以保持当前已授权用户的授权状态。
 

**你们是否提供有关如何设置 Account Activity API 的分步指南？**

当然有！

* 如果你刚刚开始，我们建议你先阅读 [Getting started with webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks) 指南

* 跟随我们由 X Dev 提供的脚本操作： 
  * [Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard)，一个用于展示 webhook 事件的 Node Web 应用程序。
  * [SnowBot chatbot](https://github.com/xdevplatform/SnowBotDev)，一个基于 Account Activity 和 Direct Message API 构建的 Ruby Web 应用程序。该代码库包含一个用于帮助设置 Account Activity API webhooks 的[脚本](https://github.com/xdevplatform/SnowBotDev/wiki/Account-Activity-API-setup-script)。
     

**如果我们的系统在一段时间内宕机，是否有办法恢复数据？**

在 Account Activity API 的付费层级（付费 Premium 和 Enterprise）中，我们的系统会在 4 小时内[重试](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries)多次向你发送这些活动。如果你的系统在这 4 小时内没有响应，那么该活动将会丢失，你将需要在 7 天内使用其他 REST 端点来恢复数据。

我们建议你将不同的 webhooks 或环境用作冗余工具，例如使用 [Account Activity Replay API](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api)，以确保当你的某个系统宕机时不会错过任何活动。
 

**使用 Account Activity API 需要哪种认证方式？**

Account Activity API 所需的授权方式在各个方法的 [API 参考页面](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index)中分别进行了说明。如果你刚开始接触 X 认证，我们建议你阅读[本章节](/zh/resources/fundamentals/authentication)。

**什么是 challenge-response check (CRC)？**

Account Activity API 质询响应（CRC）检查是一项安全功能，用于确保通过 Account Activity API 发送的活动数据会发送给正确的开发者。开发者也可以利用它来确保自己接收到的数据确实来自 X。自上次验证 webhook URL 起，X 会每 24 小时自动向你的 webhook URL 发送一次 CRC。你的系统必须在 3 秒内返回有效响应，才能保持验证状态。 

请访问我们的页面 [Securing webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks) 了解更多详情。
 

**有什么情况会立即使我的 webhook URL 失效？**

如果发生以下任一情况，我们会立即将你的 webhook 标记为无效：

* 服务器对 CRC 的响应包含错误的令牌（token）。此时，我们的系统不会[重试](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries)向你发送活动。
* webhook URL 配置了错误的证书。此时，我们的系统不会[重试](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries)向你发送活动。
* 你的服务器返回的状态码不是 2XX、4XXX 或 5XXX。
* 你声明使用 gzip，但实际并未使用。
* 你未声明使用 gzip，但在响应中实际发送了 gzip。
   

**如果我订阅的用户彼此之间有互动，我会收到重复的活动吗？**

会的。如果你的 web 应用对用户 A 和用户 B 都有有效订阅，而用户 A 在一条帖子中提及了用户 B，那么会向已注册的 webhook 发送两个 POST 活动。每个活动都会带有一个 &quot;for&#95;user&#95;id&quot; 指示器，用来表明该活动属于哪个订阅。
 

**当我向我的 webhook 创建订阅时，能否将下面这个端点中的 `/all/` 部分替换为其它账号活动数据对象，以限制 API 发送的活动类型？** `POST https://api.x.com/1.1/account_activity/all/:env_name/subscriptions.json`

不能，目前这是不可能的。就目前而言，我们只提供 `/all/` 这一产品选项。
 

**有没有办法在不向用户请求 Direct Messages 权限的情况下使用 Account Activity API？**

目前必须请求 Direct Messages 权限，因为没有办法为这个 API “过滤掉” Direct Messages 活动。 
 

**Account Activity API 有免费版本吗？**

有的，我们提供沙盒版本作为免费层级。我们的沙盒选项限制为单个 webhook，且最多只能有 15 个订阅。你可以在[我们的文档](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity)中阅读有关沙盒选项的更多信息。 

**能否使用 Account Activity API 获取转发包含已订阅用户的帖子（Retweets of Posts）的活动？**

很遗憾，这不在该 API 提供的活动范围内。为此，我们建议改用 Streaming API。 
 

**tweet&#95;create&#95;event 可能代表哪些活动类型？**

在以下情况下会发送 tweet&#95;create&#95;event 负载：

如果订阅用户执行了以下任一操作：

* 创建帖子
* 转发
* 回复帖子

如果其他用户：

* 使用 @ 提及订阅用户
* 引用订阅用户创建的 Tweet

*注意：Account Activity API 只在订阅用户会从 X 收到通知并且可以公开看到该事件时才会投递事件。这意味着，如果被提及账号 (@userA) 关注了受保护账号 (@userB)，那么 UserA 会收到 UserB 提及他们的通知。如果 UserA 没有关注 UserB（且没有被 UserB 批准），UserA 将不会收到通知，因此如果 @userA 有订阅，也不会通过 AAA 发送 tweet&#95;create&#95;event。*

**如果被我屏蔽的用户提及了我已订阅的用户，我如何识别这一点？**

你会在 JSON 响应的顶层看到一个布尔字段 `user_has_blocked`，其值为 “true” 或 “false”。该字段只会在帖子提及时暴露。 

Enterprise

**如何将我的应用加入 allowlist，或者检查我的应用是否已经在 allowlist 中？**

若要管理你已添加到允许列表、以通过 Enterprise API 访问的 [X apps](/zh/resources/fundamentals/developer-apps)，请联系你的客户经理并提供你的应用 ID。你可以通过前往 [开发者门户](/zh/resources/fundamentals/developer-portal) 中的 [&quot;Apps&quot;](/zh/resources/fundamentals/developer-apps) 页面来找到你的应用 ID。
 

**如果我有三个 webhook 的访问权限，是否可以为我已注册用于 Enterprise 的每个应用分别使用三个 webhook？**

webhook 限制是设置在账户级别，而不是应用级别。如果你有三个 webhook 的访问权限，并且有两个应用注册用于 Enterprise，你可以在一个应用上使用两个 webhook，在另一个应用上使用第三个 webhook，但不能在每个应用上都使用三个 webhook。 

**我可以指定哪些类型的事件会通过 Account Activity Replay API 进行重新投递吗？**

无法指定要重放的事件类型。在所指定的日期和时间窗口内投递的所有事件都会被重放。 

**如果我的应用未能摄取某个 Account Activity Replay API 事件，是否会有重试？**

不会，不会有任何重试。如果应用未能摄取由 Account Activity Replay API 发送的某个事件，可以为同一时间范围再次提交一个 Replay 作业，以尝试重新投递任何遗漏的 Replay 事件。 

**当我收到部分成功的完成事件时，该怎么做？**

我们建议记录已接收事件的时间戳，并为遗漏的事件再次请求一个 Replay 作业。 

**我一次可以运行多少个 Account Activity Replay API 作业？**

每个 webhook 一次只能运行一个 Account Activity Replay API 作业。 

**在事件被投递到我的 webhook 时，我如何区分 Account Activity Replay API 事件与实时生产事件？**

由于 Account Activity Replay API 始终投递过去的事件，因此可以根据事件的时间戳，将其与实时生产事件区分开来。 

**在我的应用丢弃或错过某个活动之后，我多久可以开始使用 Account Activity Replay API 来重新投递该活动？**

活动在创建大约 10 分钟后即可用于重新投递。 

<div id="error-troubleshooting-guide">
  ### 错误排查指南
</div>

<div id="code-32">
  #### Code 32
</div>

此错误通常意味着你在请求、请求头（headers）、授权信息（authorization）或 URL 中指定的内容存在格式问题。这不是 Account Activity API 错误，而是授权错误，即 X 没有收到正确的 OAuth 配置或 URL。

* **Enterprise** - 请确保你使用的 consumer key 和 access token 属于一个已注册可使用 Enterprise 产品的 [X 应用](/zh/resources/fundamentals/developer-apps)。如果你没有 consumer key 和 access token，或需要将你的 X 应用添加到 allowlist，请联系你的客户经理。 

* 如果在用户上下文下进行身份验证，请确保已使用正确的 `oauth nonce`、`oauth_signature` 和 `oauth_timestamp` [为请求授权](/zh/resources/fundamentals/authentication#authorizing-a-request)。

* 确保你的 access token 拥有正确的权限级别。
  * 在 [app dashboard](/zh/resources/fundamentals/developer-apps) 的 “Keys and tokens” 选项卡中，请确认你的 access token 具有 “Read, write, and direct messages” 的[权限级别](/zh/resources/fundamentals/developer-apps#app-permissions)。 
  * 如果 token 的权限级别低于此要求，请转到 “Permissions” 选项卡，将访问权限调整为 “Read, write, and direct messages”，然后在 “Keys and tokens” 选项卡中重新生成你的 access token 和 secret。

* 确保你的 URL 构造正确。
  * 请注意，`:env_name` 区分大小写。
     

<div id="code-200-forbidden">
  #### Code 200 - 禁止访问
</div>

* **Premium** - 在尝试向 API 发起请求之前，请确保你已拥有通过审核的[开发者账号](/zh/resources/fundamentals/developer-portal)。你还必须在请求中使用正确的 :env&#95;name，并可在 [dev environments](/zh/resources/fundamentals/developer-portal) 页面上进行设置。

* **Enterprise** - 请确保你的客户经理已为你开通 Account Activity API 的访问权限。

* 请确保你已正确设置 URI。如果你在请求中输入了错误的 URI，也会触发此错误。
   

<div id="code-214-webhook-url-does-not-meet-the-requirements">
  #### 代码 214 - Webhook URL 不符合要求。
</div>

* 请确保您使用的是 HTTPS。
* 您的 webhook URL 可能格式不正确。
* 请在[开始使用 webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks)页面的[开发 webhook consumer 应用](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#3-develop-webhook-consumer-app)部分了解如何设置您的 webhook URL。
   

<div id="code-214-high-latency-on-crc-get-request-your-webhook-should-respond-in-less-than-3-seconds">
  #### 代码 214 - CRC GET 请求延迟过高。您的 webhook 应在 3 秒内做出响应。
</div>

* 这表示您的服务器响应较慢。请确保在 3 秒内响应 CRC 请求。
   

<div id="code-214-non-200-response-code-during-crc-get-request-ie-404-500-etc">
  #### 代码 214 - 在 CRC GET 请求期间出现非 200 响应码（例如 404、500 等）。
</div>

* 你的服务器已宕机或不可用。请确保你的服务器正在正常运行。
   

<div id="code-214-too-many-resources-already-created">
  #### 代码 214 - 已创建的资源过多。
</div>

* **Enterprise** - 你已经用完了所有 webhook。对每个已注册的应用使用 [GET webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) 端点，以确定你的 webhook 都分布在哪些应用中。 

<div id="code-261-application-cannot-perform-write-actions">
  #### 代码 261 - 应用无法执行写入操作。
</div>

* 你与 API 搭配使用的应用，其访问令牌（access token）和访问令牌密钥（access token secret）未设置正确的[权限级别](/zh/resources/fundamentals/developer-apps#app-permissions)。请前往 [X apps](/zh/resources/fundamentals/developer-apps) 仪表板中的“Keys and tokens”选项卡，检查分配给你的访问令牌和访问令牌密钥的权限级别。如果其设置为 “Read, write and Direct Messages” 以外的任何选项，则需要在 “Permission” 选项卡下调整设置，并重新生成访问令牌和访问令牌密钥，使新的设置生效。
* 另一种情况是，你正尝试使用仅应用身份验证（app-only authentication）来注册 webhook，但这种方式不受支持。请改为按照 [Enterprise Account Activity API](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks) 中注册 webhook 的 API 参考文档说明，在用户上下文下进行认证。

<div id="account-activity-api-reference-index">
  ## Account Activity API 参考索引
</div>

|     |     |
| :--- | :--- |
| **用途** | Enterprise |
| 注册一个 webhook URL / 生成一个 webhook&#95;id | [POST  <br />webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) |
| 返回所有 webhook URL 及其状态 | [GET  <br />webhooks](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |
| 手动触发质询响应检查 | [PUT  <br />webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) |
| 将应用订阅到某个账号的事件 | [POST  <br />webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) |
| 返回当前处于活动状态的订阅数量 | [GET  <br />subscriptions/count](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |
| 检查某个 webhook 是否已订阅某个账号 | [GET  <br />webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) |
| 返回当前处于活动状态的订阅列表 | [GET  <br />webhooks/:webhook&#95;id/subscriptions/all/list](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |
| 删除该 webhook | [DELETE  <br />webhooks/:webhook&#95;id](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) |
| 使用三方 OAuth 停用订阅（已弃用） | [DELETE  <br />webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) |
| 使用仅应用 OAuth 停用订阅 | [DELETE  <br />webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |
| 将活动重新投递到 webhook | [POST  <br />replay/webhooks/:webhook&#95;id/subscriptions/all](/zh/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) |

<div id="enterprise-account-activity-api">
  ### Enterprise 账户活动 API
</div>

<div id="post-account_activitywebhooks">
  #### POST account&#95;activity/webhooks[](#post-account-activity-webhooks "Permalink to this headline")
</div>

为指定的应用上下文注册一个新的 webhook URL。该 URL 在保存前会通过 CRC 请求进行验证。如果验证失败，将向请求方返回详细的错误信息。

允许的 webhook 数量由计费套餐决定。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 需要身份验证 | 是（用户上下文 - 所有 consumer 和访问令牌） |
| 受速率限制 | 是 |
| 每 15 分钟窗口内的请求数（用户身份验证） | 15  |
| 帖子编辑支持 | 所有帖子对象都会包含描述该帖子编辑历史的帖子编辑元数据。详情参见 [&quot;Tweet edits&quot; 基础知识](/zh/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets) 页面。 |

<div id="parameters">
  ### 参数[](#parameters "指向此标题的固定链接")
</div>

|     |     |
| :--- | :--- |
| url（必需） | 回调端点的已编码 URL。 |

<div id="example-request">
  ### 示例请求[](#example-request "该标题的永久链接")
</div>

$ curl --request POST
--url &#39;https://api.x.com/1.1/account&#95;activity/webhooks.json?url=https%3A%2F%2Fyour&#95;domain.com%2Fwebhooks%2Ftwitter%2F0&#39;
--header &#39;authorization: OAuth oauth&#95;consumer&#95;key=&quot;CONSUMER&#95;KEY&quot;, oauth&#95;nonce=&quot;GENERATED&quot;, oauth&#95;signature=&quot;GENERATED&quot;, oauth&#95;signature&#95;method=&quot;HMAC-SHA1&quot;, oauth&#95;timestamp=&quot;GENERATED&quot;, oauth&#95;token=&quot;ACCESS&#95;TOKEN&quot;, oauth&#95;version=&quot;1.0&quot;&#39;

<div id="http-responses">
  ### HTTP Responses[](#http-responses "Permalink to this headline")
</div>

| HTTP Code | Message |
| :--- | :--- |
| 200 | Webhook URL 已注册到所提供的应用程序 |
| 403 | 你的请求存在错误。请参阅下方的错误消息部分。 |

### 成功响应示例[](#example-response-success "Permalink to this headline")

```json
_HTTP 200_

    {
      "id": "1234567890",
      "url": "https://your_domain.com/webhook/twitter/0",
      "valid": true,
      "created_at": "2016-06-02T23:54:02Z"
    }
```

<div id="error-messages">
  ### 错误信息[](#error-messages "Permalink to this headline")
</div>

| Code | Message                                   |
| :--- | :---------------------------------------- |
| 214  | Webhook URL 不符合要求。                        |
| 214  | 资源数量已达上限。                                 |
| 214  | Webhook URL 不符合要求。CRC 令牌无效或 JSON 响应格式无效。  |
| 214  | CRC GET 请求延迟过高。webhook 必须在 3 秒内作出响应。      |
| 214  | CRC GET 请求期间返回了非 200 的响应状态码（如 404、500 等）。 |

*HTTP 403*

```json
    {
      "errors": [
        {
          "code": 214,
          "message": "Too many resources already created."
        }
      ]
    }
```

<div id="get-account_activitywebhooks">
  #### GET account&#95;activity/webhooks[](#get-account-activity-webhooks "Permalink to this headline")
</div>

返回指定应用的所有 URL 及其状态。

如果某个 URL 在每日校验中失败，我们会将其标记为无效。要重新启用该 URL，请调用 update 端点。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 需要身份验证 | 是（仅应用 - Bearer Token） |
| 受速率限制 | 是 |
| 请求数 / 每 15 分钟窗口（应用级认证） | 15  |

### 示例请求[](#example-request "此标题的固定链接")

```bash
    $ curl --request GET
     --url https://api.x.com/1.1/account_activity/webhooks.json
     --header 'authorization: Bearer TOKEN'
```

<div id="example-response">
  ### 示例响应[](#example-response "Permalink to this headline")
</div>

*HTTP 200 OK*

```json
    [
      {
        "id": "1234567890",
        "url": "https://your_domain.com/webhook/twitter/0",
        "valid": true,
        "created_at": "2016-06-02T23:54:02Z"
      }
      {
        "id": "2468013579",
        "url": "https://your_domain2.com/webhook/twitter/0",
        "valid": true,
        "created_at": "2016-06-04T22:31:29Z"
      }
    ]
```

<div id="error-messages">
  ### 错误信息[](#error-messages "Permalink to this headline")
</div>

| Code | 错误信息 |
| :--- | :--- |
| 99  | 您无权访问此资源。 |

<div id="put-account_activitywebhookswebhook_id">
  #### PUT account&#95;activity/webhooks/:webhook&#95;id[](#put-account-activity-webhooks-webhook-id "Permalink to this headline")
</div>

对指定 webhook 的 URL 触发挑战响应检查（CRC）。如果检查成功，则返回 204，并将其状态设置为 `valid`，从而重新启用该 webhook。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 需要身份验证 | 是（用户上下文——所有 consumer 令牌和访问令牌） |
| 受速率限制 | 是 |
| 请求数 / 每 15 分钟窗口（用户身份验证） | 15  |

### 参数[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | webhook 的 id，定义在资源路径中。 |

### 示例请求[](#example-request "Permalink to this headline")

```json
    $ curl --request PUT
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID.json
     --header 'authorization: OAuth oauth_consumer_key="CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="ACCESS_TOKEN", oauth_version="1.0"'
```

<div id="response">
  ### 响应[](#response "Permalink to this headline")
</div>

*HTTP 204 OK*

```
    { }
```

<div id="error-messages">
  ### 错误信息[](#error-messages "Permalink to this headline")
</div>

| Code | Message |
| :--- | :--- |
| 34  | Webhook 不存在，或与其他 X 应用关联。 |
| 214 | Webhook URL 不符合要求。 |
| 214 | Webhook URL 不符合要求。CRC token 或 JSON 响应格式无效。 |
| 214 | CRC GET 请求延迟过高。你的 webhook 必须在 3 秒内完成响应。 |
| 214 | CRC GET 请求期间返回的响应码不是 200（如 404、500 等）。 |

<div id="post-account_activitywebhookswebhook_idsubscriptionsall">
  #### POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all[](#post-account-activity-webhooks-webhook-id-subscriptions-all "Permalink to this headline")
</div>

为指定的应用订阅指定用户上下文中所有消息类型的全部事件。激活后，与发起请求的用户相关的所有事件都会通过 POST 请求发送到该应用的 webhook。

当前可用的订阅数量受你的账户配置限制。如果你需要添加更多订阅，请联系你的客户经理。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 是否需要认证 | 是（三方 OAuth - 已加入白名单的 consumer key 和订阅用户的访问令牌 Access Token） |
| 是否有速率限制 | 是 |
| 每 15 分钟窗口内的请求数（用户认证） | 500 |

### 参数[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id（必填） | Webhook ID。在资源路径中指定。 |

<div id="example-request">
  ### 示例请求[](#example-request "该标题的永久链接")
</div>

```bash
    $ curl --request POST
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all.json
     --header 'authorization: OAuth oauth_consumer_key="WHITELISTED_CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="SUBSCRIBING_USER'S_ACCESS_TOKEN", oauth_version="1.0"'
```

<div id="example-response-success">
  ### 示例响应 - 成功[](#example-response-success "Permalink to this headline")
</div>

*HTTP 204 无内容*

```
    {}
```

<div id="error-messages">
  ### 错误信息[](#error-messages "Permalink to this headline")
</div>

| Code | Message |
| :--- | :--- |
| 34  | Webhook 不存在或与其他 X 应用关联。 |
| 348 | 客户端应用无权访问此用户的 webhook 订阅。 |

<div id="get-account_activitysubscriptionscount">
  #### GET account&#95;activity/subscriptions/count[](#get-account-activity-subscriptions-count "Permalink to this headline")
</div>

返回当前在你的账户上处于活动状态的订阅数量。请注意，/count 端点需要仅限应用的 OAuth（application-only OAuth），因此你应当使用 Bearer Token 而不是用户上下文来发起请求。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/subscriptions/count.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | HTTP 响应代码 |
| 需要身份验证 | 是（仅应用级 - Bearer Token） |
| 受速率限制 | 是 |
| 每 15 分钟窗口内的请求数（应用级验证） | 15  |

### HTTP 状态码[](#http-response-codes "Permalink to this headline")

|     |     |
| :--- | :--- |
| 状态码 | 说明 |
| 200 | 成功。将返回所请求 webhook 的订阅数量。 |
| 401 | 您的应用没有权限查看指定 webhook 的订阅。 |

### 请求示例[](#example-request "本标题的永久链接")

```bash
    $ curl --request GET
     --url https://api.x.com/1.1/account_activity/subscriptions/count.json
     --header 'authorization: Bearer TOKEN'
```

<div id="example-response-success">
  ### 示例响应 - 成功[](#example-response-success "Permalink to this headline")
</div>

*HTTP 200*

```bash
    {
      "account_name":"my-account",
      "subscriptions_count_all":"1",
      "subscriptions_count_direct_messages":"0",
      "provisioned_count":"50"
    }
```

<div id="error-messages">
  ### 错误信息[](#error-messages "Permalink to this headline")
</div>

| Code | Message   |
| :--- | :-------- |
| 32   | 无法验证您的身份。 |

*HTTP 401*

```abash
    {
      "errors": [
        {
           "code": 32,
          "message": "Could not authenticate you."
        }
      ]
    }
```

<div id="get-account_activitywebhookswebhook_idsubscriptionsall">
  #### GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all[](#get-account-activity-webhooks-webhook-id-subscriptions-all "Permalink to this headline")
</div>

提供一种方式来判断某个 webhook 配置是否已订阅指定用户的事件。\
如果在给定的用户上下文中，该用户与所提供的应用之间存在一个活动订阅，则返回 204 OK。\
如果响应状态码不是 204，则表示该用户没有活动订阅。详细信息请参阅下面的 HTTP 响应状态码和错误信息说明。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 需要身份验证 | 是（3-legged OAuth - 列入白名单的 consumer key 和订阅用户的访问令牌） |
| 受速率限制 | 是 |
| 请求次数 / 每 15 分钟窗口（用户认证） | 500 |

### 参数[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id（必需） | Webhook ID。在资源路径中定义。 |

### 示例请求[](#example-request "指向此标题的固定链接")

$ curl --request GET
--url https://api.x.com/1.1/account&#95;activity/webhooks/:WEBHOOK&#95;ID/subscriptions/all.json
--header &#39;authorization: OAuth oauth&#95;consumer&#95;key=&quot;WHITELISTED&#95;CONSUMER&#95;KEY&quot;, oauth&#95;nonce=&quot;GENERATED&quot;, oauth&#95;signature=&quot;GENERATED&quot;, oauth&#95;signature&#95;method=&quot;HMAC-SHA1&quot;, oauth&#95;timestamp=&quot;GENERATED&quot;, oauth&#95;token=&quot;SUBSCRIBING&#95;USER&#39;S&#95;ACCESS&#95;TOKEN&quot;, oauth&#95;version=&quot;1.0&quot;&#39;

### 示例响应：成功[](#example-response-success "Permalink to this headline")

*HTTP 204 NO CONTENT*

```
    { }
```

<div id="get-account_activitywebhookswebhook_idsubscriptionsalllist">
  #### GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list[](#get-account-activity-webhooks-webhook-id-subscriptions-all-list "此标题的永久链接")
</div>

返回指定 webhook 当前 “All Activity” 类型订阅的列表。请注意，/list 端点需要仅应用级（application-only）OAuth，因此请求应使用 Bearer Token，而不是基于用户上下文的认证。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all/list.json`

### 资源信息[](#resource-information "此标题的永久链接")

|     |     |
| :--- | :--- |
| 响应格式 | HTTP 响应状态码 |
| 需要认证 | 是（仅应用 - Bearer Token） |
| 受速率限制 | 是 |
| 每 15 分钟窗口的请求数（应用认证） | 50  |

### 参数[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | Webhook ID，在资源路径中定义。 |

<div id="http-response-codes">
  ### HTTP 响应代码[](#http-response-codes "Permalink to this headline")
</div>

| Code | Message |
| :--- | :--- |
| 200 | 成功。将返回所请求 webhook 的订阅列表。 |
| 401 | 您的应用无权查看指定 webhook 的订阅列表。 |

### 示例请求[](#example-request "指向此标题的永久链接")

$ curl --request GET
--url https://api.x.com/1.1/account&#95;activity/webhooks/:WEBHOOK&#95;ID/subscriptions/all/list.json
--header &#39;authorization: Bearer TOKEN&#39;

<div id="example-response-success">
  ### 示例响应 - 成功[](#example-response-success "Permalink to this headline")
</div>

*HTTP 200*

```bash
    {
      "webhook_id": "1234567890",
      "webhook_url": "https://your_domain.com/webhook/twitter/0",
      "application_id": "11231812",
      "subscriptions": [{
        "user_id": "20212306"
      }]
    }
```

<div id="error-messages">
  ### 错误信息[](#error-messages "Permalink to this headline")
</div>

| Code | 信息         |
| :--- | :--------- |
| 32   | 无法对您进行身份验证 |

*HTTP 401*

```bash
    {
      "errors": [
        {
           "code": 32,
          "message": "Could not authenticate you."
        }
      ]
    }
```

<div id="delete-account_activitywebhookswebhook_id">
  #### DELETE account&#95;activity/webhooks/:webhook&#95;id[](#delete-account-activity-webhooks-webhook-id "Permalink to this headline")
</div>

从指定应用的配置中移除该 webhook。可以通过调用 GET /1.1/account&#95;activity/webhooks 来获取 webhook 的 ID。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 需要身份验证 | 是（用户上下文 — 所有 consumer 令牌和访问令牌） |
| 受速率限制 | 是 |
| 每 15 分钟窗口的请求数（用户身份验证） | 15  |

### 参数[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | Webhook ID。在资源路径中定义。 |

### 示例请求[](#example-request "Permalink to this headline")

```bash
    $ curl --request DELETE
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID.json
     --header 'authorization: OAuth oauth_consumer_key="CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="ACCESS_TOKEN", oauth_version="1.0"'
```

<div id="response">
  ### 响应[](#response "Permalink to this headline")
</div>

*HTTP 204 OK*

```
    { }
```

<div id="delete-account_activitywebhookswebhook_idsubscriptionsall-deprecated">
  #### DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all (已弃用)[](#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated- "Permalink to this headline")
</div>

停用针对所提供用户上下文和应用的订阅。停用后，发起请求用户的所有事件将不再发送到该 webhook URL。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 是否需要身份验证 | 是（三方 OAuth - 已列入白名单的 consumer key 和已订阅用户的访问令牌） |
| 是否有速率限制 | 是 |
| 每 15 分钟时间窗口内的请求数（用户身份验证） | 500 |

### 参数[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | Webhook 的 id。在资源路径中定义。 |

### 请求示例[](#example-request "Permalink to this headline")

```bash
    $ curl --request DELETE
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all.json
     --header 'authorization: OAuth oauth_consumer_key="WHITELISTED_CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="SUBSCRIBED_USER'S_ACCESS_TOKEN", oauth_version="1.0"'
```

请求示例

```
    { }
```

<div id="delete-account_activitywebhookswebhook_idsubscriptionsuser_idalljson">
  #### DELETE /account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json[](#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json "Permalink to this headline")
</div>

为指定的 webhook 和用户 id 停用订阅。停用后，发起请求的用户的所有事件将不再发送到该 webhook URL。请注意，此端点需要仅应用级 OAuth（application-only OAuth），因此应使用 Bearer Token 发起请求，而不是使用用户上下文。

<div id="resource-url">
  ### 资源 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/:user_id/all.json`

<div id="resource-information">
  ### 资源信息[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 响应格式 | JSON |
| 需要身份验证 | 是（仅应用 - Bearer Token） |
| 速率限制 | 有 |
| 每 15 分钟窗口内的请求数 | 500 |

### 示例请求[](#example-request "Permalink to this headline")

```bash
    $ curl --request DELETE
     --url https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/:user_id/all.json
     --header 'authorization: Bearer TOKEN'
```

### 响应[](#response "固定链接到此标题")

*HTTP 204 无内容*

### 错误消息[](#error-messages "Permalink to this headline")

| Code | Message |
| :--- | :--- |
| 404 | 抱歉，此页面不存在。- 通常出现在指定的用户 id 实际并未订阅的情况下。 |

<div id="replay-api">
  ### Replay API
</div>

**POST /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json [¶](#post-1-1-account-activity-replay-webhooks-webhook-id-subscriptions-all-json- "Permalink to this headline")**

提交请求，从请求中指定的日期和时间窗口内存在的所有订阅中，检索最多过去五天内的活动。如果你的 webhook 存在处于活动状态的用户订阅，你也会同时收到这些事件。注意：在投递重放事件之前，我们会执行 CRC 校验。

|     |     |
| :--- | :--- |
| **Request Method** | HTTP POST |
| **URL** | /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json?from&#95;date=yyyymmddhhmm&amp;to&#95;date=yyyymmddhhmm |
| **Response Format** | JSON |
| **Requires Authentication** | 是（仅限应用 - Bearer Token） |
| **Rate Limit** | 每 15 分钟 5 个请求。目前对可请求的重放作业数量没有上限。 |
| **from&#95;date** | 提供事件的最早（开始）UTC 时间戳，必须为 “yyyymmddhhmm” 格式。时间戳的粒度为分钟，并且是包含性的（即 12:00 包含第 00 分钟）。合法时间必须在最近 5 天内（UTC 时间），且必须早于当前时间点至少 31 分钟。建议 from&#95;date 和 to&#95;date 之间的间隔控制在约 2 小时内。 |
| **to&#95;date** | 提供事件的最晚（结束）UTC 时间戳，必须为 “yyyymmddhhmm” 格式。时间戳的粒度为分钟，并且是排他性的（即 12:30 不包含该小时第 30 分钟）。合法时间必须在最近 5 天内（UTC 时间），且必须早于当前时间点至少 10 分钟。 |

<div id="responses">
  #### 响应
</div>

API 可能返回以下响应。大多数错误代码会在响应体中附带包含更多详细信息的字符串。对于非 200 响应，你应先解决错误然后重试。

| Status | Text | Error Code | Description | Message |
| :--- | :--- | :--- | :--- | :--- |
| 202 | Accepted | N/A | 请求已成功，活动将被发送。 | N/A |
| 400 | Bad Request | 214 | Webhook 已被标记为无效。 | Webhook 被标记为无效，需要进行 CRC 检查。 |
| 400 | Bad Request | 357 | 缺少查询参数。 | : queryParam 为必需项。 |
| 400 | Bad Request | 358 | 路由或查询参数格式错误。 | 无法解析参数。 |
| 400 | Bad Request | 360 | 路由参数为负数。 | webhook&#95;id: [] 不大于或等于 0。 |
| 400 | Bad Request | 368 | from&#95;date 或 to&#95;date 不是过去的时间。 | : [&lt;field&#95;value&gt;] 不是过去的时间。 |
| 400 | Bad Request | 356 | from&#95;date 必须早于 to&#95;date。 | from&#95;date 必须早于 to&#95;date。 |
| 400 | Bad Request | 356 | from&#95;date 必须在过去 5 天之内。 | from&#95;date 必须在过去 5 天之内。 |
| 401 | Unauthorized | 32  | 由于提供了 3-legged 认证导致 HTTP 身份验证失败。 | 无效的认证方式。请使用仅应用身份验证（application-only authentication）。 |
| 401 | Unauthorized | 61  | Client 不允许请求此方法。 | Client 不允许请求此方法。 |
| 403 | Forbidden | 200 | Client 没有启用 Replay 的 Enterprise 账户。 | 需要具有启用 replay 的 Account Activity API Enterprise 账户。请确认你拥有 Enterprise 账户并且已启用 replay。 |
| 404 | Not Found | 34  | 不存在的 webhook&#95;id；webhook&#95;id 与 application&#95;id 不匹配。 | Webhook 不存在或与其他 X 应用关联。 |
| 409 | Conflict | 355 | 已有请求在处理中，必须等待其处理完成后才能发起另一个请求。 | 此 webhook 已有回放作业在进行中。 |
| 429 | Too Many Requests | 88  | 触发速率限制（在给定时间段内达到请求次数上限）。 | 请求过多。请降低 API 请求频率。 |
| 500 | Internal Server Error | 0   | 内部服务器错误。 | 内部服务器错误。 |
| 503 | Service Unavailable | 67  | X 上的一个或多个依赖服务不可用。 | X 服务器错误。请使用指数退避模式重试。 |

<div id="job-completed-successfully-message">
  #### &quot;Job completed successfully” 消息
</div>

当你的作业成功完成后，Account Activity Replay API 将发送如下所示的作业完成事件。收到该事件后，表示该作业已运行结束，可以提交下一个作业。

```json
{
  "replay\_job\_status": {
    "webhook_id": "1234577122340233217",
    "job_state": "Complete",
    "job\_state\_description": "Job completed successfully"
    "job_id": "1095098195724558337"
  }
}
```

<div id="job-failed-to-complete-message">
  #### “Job failed to complete” 消息
</div>

如果你的作业未能成功完成，我们会返回以下消息，提示你重试 Replay 作业。收到此事件后，说明该作业已运行结束，你可以提交新的作业。

```json
{
  "replay\_job\_status": {
    "webhook_id": "123451374207332352",
    "job_state": "Incomplete",
    "job\_state\_description": "任务未能传递所有事件，请重试您的重放任务",
    "job_id": "1093226942650736640"
  }
}
```

<div id="example-curl-request">
  #### 示例 cURL 请求
</div>

```bash
    curl --request POST  --url 'https://api.x.com/1.1/account_activity/replay/webhooks/:webhook_id/subscriptions/all.json?from_date=yyyymmddhhmm&to_date=yyyymmddhhmm'
    --header 'authorization: Bearer TOKEN'
```

#### 示例响应

HTTP 202

```bash
{
  "job_id": "1234567890",
  "created_at": "2016-06-02T23:54:02Z"
}
```
