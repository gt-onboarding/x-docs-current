---
title: 认证
sidebarTitle: 认证
---

X API 要求对所有端点进行认证。XDK 支持三种认证方法：

1. Bearer Token（仅应用级）
2. OAuth 2.0 结合 PKCE
3. OAuth 1.0a（用户上下文）

- **Bearer Token**：用于对支持应用认证的端点进行只读访问（如搜索帖子、流式端点）。
- **OAuth 2.0 PKCE**：提供基于 scope、由用户授权的安全访问（例如获取已认证用户帖子中的非公开指标）。
- **OAuth 1.0a**：用于用户特定操作的遗留认证方式（例如代表用户发帖、管理列表）。

在 [X 开发者门户](https://developer.x.com/en/portal/dashboard) 获取凭证。你需要一个获批的开发者账号，以及一个具有相应权限（如读取 + 写入）的应用。

<div id="creating-a-client">
  ## 创建 Client
</div>

所有身份验证流程都会生成一个 `Client` 实例：

```python
from xdk import Client
```


<div id="1-bearer-token-app-only">
  ### 1. Bearer Token（仅限应用）
</div>

用于在无用户上下文的情况下执行只读操作。
**步骤**：

1. 在开发者门户中，为你的应用生成一个 Bearer Token。
2. 将其传递给 `Client`。
   **示例**：

```python
client = Client(bearer_token="XXXXX")
```

**用法**:

```python
# search_recent 返回一个迭代器,因此对其进行迭代
for page in client.posts.search_recent(query="python", max_results=10):
    if page.data and len(page.data) > 0:
        first_post = page.data[0]
        post_text = first_post.text if hasattr(first_post, 'text') else first_post.get('text', '')
        print(post_text)  # Access first Post
        break
```


<div id="2-oauth-20-with-pkce-user-context">
  ### 2. 使用 OAuth 2.0 与 PKCE（用户上下文）
</div>

此示例展示如何将 OAuth 2.0 与 Proof Key for Code Exchange (PKCE) 结合使用。将其用于用户上下文访问（例如代表某个用户发布帖子、为用户上传媒体等）。
**步骤**：

1. 在开发者门户中，使用重定向 URI（例如 `http://localhost:8080/callback`）注册你的应用。
2. 获取 Client ID（使用 PKCE 无需 client secret）。
3. 发起授权流程，将用户重定向到授权 URL 并处理回调。
   **示例**（使用 web 服务器来处理回调）：

```python
from xdk.oauth2_auth import OAuth2PKCEAuth
from urllib.parse import urlparse
import webbrowser
# 步骤 1：创建 PKCE 实例
auth = OAuth2PKCEAuth(
    client_id="YOUR_CLIENT_ID",
    redirect_uri="YOUR_CALLBACK_URL",
    scope="tweet.read users.read offline.access"
)
# 步骤 2：获取授权 URL
auth_url = auth.get_authorization_url()
print(f"访问此 URL 进行授权：{auth_url}")
webbrowser.open(auth_url)
# 步骤 3：处理回调（在实际应用中，使用 Flask 等 Web 框架）
# 假设 callback_url = "http://localhost:8080/callback?code=AUTH_CODE_HERE"
callback_url = input("在此粘贴完整的回调 URL：")
# 步骤 4：用授权码交换令牌
tokens = auth.fetch_token(authorization_response=callback_url)
access_token = tokens["access_token"]
refresh_token = tokens["refresh_token"]  # 存储以供续期
# 步骤 5：创建 Client
# 选项 1：使用 bearer_token（OAuth2 访问令牌可作为 Bearer Token 使用）
client = Client(bearer_token=access_token)
# 选项 2：传递完整的令牌字典以支持自动刷新
# client = Client(token=tokens)
```

**令牌刷新**（对于长期会话，SDK 会自动执行）：

```python
# If access token expires, refresh using stored refresh_token
# refresh_token 方法使用 OAuth2PKCEAuth 实例中存储的令牌
tokens = auth.refresh_token()
# Use the refreshed token
client = Client(bearer_token=tokens["access_token"])
# Or pass the full token dict: client = Client(token=tokens)
```


<div id="3-oauth-10a-user-context">
  ### 3. OAuth 1.0a（用户上下文）
</div>

对于旧版应用或需要使用 OAuth 1.0a 进行认证的特定用例：
**步骤**：

1. 在开发者门户中获取你的 API Key 和 API Secret。
2. 如果你已经拥有访问令牌，可以直接使用；否则，请完成 OAuth 1.0a 授权流程来获取它们。
3. 创建一个 OAuth1 实例并将其传入 Client。
   **示例**（使用已有访问令牌）：

```python
from xdk import Client
from xdk.oauth1_auth import OAuth1
# 步骤 1：使用凭据创建 OAuth1 实例
oauth1 = OAuth1(
    api_key="YOUR_API_KEY",
    api_secret="YOUR_API_SECRET",
    callback="http://localhost:8080/callback",
    access_token="YOUR_ACCESS_TOKEN",
    access_token_secret="YOUR_ACCESS_TOKEN_SECRET"
)
# 步骤 2：使用 OAuth1 创建客户端
client = Client(auth=oauth1)
# 步骤 3：使用客户端
response = client.users.get_me()
me = response.data
print(me)
```

**示例**（完整的 OAuth 1.0a 流程）：

```python
from xdk import Client
from xdk.oauth1_auth import OAuth1
import webbrowser
# 步骤 1:创建 OAuth1 实例
oauth1 = OAuth1(
    api_key="YOUR_API_KEY",
    api_secret="YOUR_API_SECRET",
    callback="http://localhost:8080/callback"
)
# 步骤 2:获取请求令牌
request_token = oauth1.get_request_token()
# 步骤 3:获取授权 URL
auth_url = oauth1.get_authorization_url(login_with_x=False)
print(f"访问此 URL 以进行授权:{auth_url}")
webbrowser.open(auth_url)
# 步骤 4:用户授权后您将收到 oauth_verifier
# 在实际应用中,通过回调 URL 处理
oauth_verifier = input("输入来自回调的 OAuth 验证码:")
# 步骤 5:交换获取访问令牌
access_token = oauth1.get_access_token(oauth_verifier)
# 步骤 6:创建 client
client = Client(auth=oauth1)
# 现在可以使用 client
response = client.users.get_me()
```

**注意**：

* 在生产环境中绝不要将机密信息硬编码到代码中；请使用环境变量或机密管理服务（例如 `os.getenv("X_BEARER_TOKEN")`）。
* 对于 PKCE，请确保在生产环境中的重定向 URI 使用 HTTPS。
* SDK 会验证令牌，如果验证失败会抛出 `xdk.AuthenticationError`。
  要查看使用 Python XDK 的详细代码示例，请访问我们的[代码示例 GitHub 仓库](https://github.com/xdevplatform/samples/tree/main/python)。
