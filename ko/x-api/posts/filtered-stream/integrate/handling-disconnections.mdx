---
title: 스트림 연결 끊김 처리
sidebarTitle: 스트림 연결 끊김 처리
keywords: ["스트리밍 연결 끊김", "연결 끊김 처리", "스트림 재연결", "스트림 재연결 처리", "연결 끊김 대처", "스트림 오류"]
---

<div id="what-is-a-disconnection">
  ### 연결 해제란 무엇인가요?
</div>

스트리밍 API에 연결을 설정한다는 것은 매우 오래 유지되는 HTTPS 요청을 보내고, 응답을 순차적으로 파싱한다는 의미입니다. filtered stream 엔드포인트에 연결할 때는 HTTPS 요청을 생성한 뒤, 가능한 한 오랫동안 결과 스트림을 읽어 들여 처리해야 합니다. 서버 측 오류, 과도한 클라이언트 측 지연, 네트워크 문제, 정기적인 서버 유지 관리, 중복 로그인 시도 등의 상황이 없는 한, 당사 서버는 연결을 무기한 유지합니다. 스트리밍 엔드포인트에 대한 연결은 중간에 끊어질 가능성이 높으며, 이런 연결 해제는 발생할 수 있는 정상적인 상황으로 예상하고 자동 재연결 로직을 구현해야 합니다.
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### 스트리밍 연결이 끊어질 수 있는 이유
</div>

스트림은 여러 가지 이유로 끊어질 수 있습니다. 실패 원인을 파악하려면 스트림에서 반환된 오류 메시지를 확인하십시오. 연결이 끊어질 수 있는 가능한 이유는 다음과 같습니다.

* 인증 오류(잘못된 토큰을 사용했거나 잘못된 인증 방식을 사용한 경우 등).
* X 측 스트리밍 서버가 재시작된 경우. 이는 일반적으로 코드 배포와 관련이 있으며, 언제든 발생할 수 있는 상황으로 보고 이에 맞게 설계해야 합니다.
* 클라이언트가 스트림이 전달하는 게시물 양을 따라가지 못하거나 데이터를 너무 느리게 읽는 경우. 모든 스트리밍 연결은 클라이언트로 전송할 메시지 큐를 기반으로 동작합니다. 이 큐가 시간이 지나면서 너무 커지면 연결이 종료됩니다.
* 계정이 일일/월간 게시물 할당량을 초과한 경우.
* 불필요하게 중복된 활성 연결이 너무 많은 경우.
* 클라이언트가 갑자기 데이터 읽기를 중단한 경우. 스트림에서 읽는 게시물 속도가 갑자기 떨어지면 연결이 종료됩니다.
* 서버와 클라이언트 간의 네트워크 문제 가능성.
* 일시적인 서버 측 문제 또는 예정된 유지 관리 및 업데이트.([status page](https://api.twitterstat.us/)를 확인하십시오.)
   

<div id="common-disconnection-errors-include">
  #### 자주 발생하는 연결 해제 오류는 다음과 같습니다:
</div>

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "운영상의 이유로 이 스트림의 업스트림 연결이 해제되었습니다.",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "이 스트림은 현재 허용된 최대 연결 제한에 도달했습니다.",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### 연결 끊김 예상 및 재연결
</div>

스트리밍으로 게시물을 수신할 때의 목표는 연결 끊김이 발생할 수 있다는 점을 인지하면서 가능한 한 오래 연결을 유지하는 것입니다. 이 엔드포인트는 20초마다 keep-alive 하트비트 신호를 제공합니다(줄 바꿈 문자로 보입니다). 이 신호를 사용해 연결이 끊기고 있는지 감지하십시오.

1. 코드에서는 새로운 콘텐츠와 하트비트가 도착하지 않는 시점을 감지해야 합니다.
2. 그런 상황이 발생하면, 코드에서 재연결 로직을 실행해야 합니다. 일부 클라이언트와 언어에서는 읽기 타임아웃을 지정할 수 있으며, 이를 20초로 설정할 수 있습니다.
3. 서비스는 이러한 연결 끊김을 감지하고 가능한 한 빨리 다시 연결해야 합니다.

이미 설정된 연결이 끊어지면 즉시 재연결을 시도하십시오. 재연결이 실패하면, 경험한 오류 유형에 따라 재연결 시도 간 간격을 점진적으로 늘리십시오:

* TCP/IP 수준 네트워크 오류의 경우 선형적으로 대기 시간을 늘리십시오. 이러한 문제는 일반적으로 일시적이며 빠르게 해소되는 경향이 있습니다. 재연결 지연을 시도할 때마다 250ms씩 늘려 최대 16초까지 증가시키십시오.
* 재연결이 적절한 HTTP 오류의 경우 지수적으로 대기 시간을 늘리십시오. 5초 대기부터 시작하여 각 시도마다 두 배로 늘려 최대 320초까지 증가시키십시오.
* HTTP 429 오류(Rate limit 초과)의 경우 지수적으로 대기 시간을 늘리십시오. 1분 대기부터 시작하여 각 시도마다 두 배로 늘리십시오. HTTP 429를 받을 때마다, 해당 계정에 대한 Rate limit 적용이 더 이상 유효하지 않게 될 때까지 기다려야 하는 시간이 증가한다는 점에 유의하십시오.
   

<div id="recovering-lost-data">
  #### 손실된 데이터 복구
</div>

연결이 끊기는 상황이 발생하면, 놓쳤을 수 있는 모든 데이터를 다시 수신할 수 있도록 사용할 수 있는 몇 가지 전략이 있습니다. 누락된 데이터를 복구하기 위해 취할 수 있는 핵심 단계들을 [데이터 복구](/ko/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features) 통합 가이드에 정리해 두었습니다. 
 

<div id="rate-limits-and-usage">
  #### 요청 한도 및 사용량
</div>

연결 한도를 확인하기 위해 응답에는 세 개의 헤더가 포함되어 반환됩니다. 이를 통해 rule 엔드포인트를 얼마나 자주 호출할 수 있는지, 그리고 스트리밍 엔드포인트에 대해 얼마나 많은 재연결 시도가 허용되는지 파악할 수 있습니다.

* x-rate-limit-limit은 15분 동안 클라이언트가 보낼 수 있도록 할당된 최대 요청 수를 나타냅니다.

* x-rate-limit-remaining은 해당 15분 동안 지금까지 수행된 요청 수를 나타냅니다.

* x-rate-limit-reset은 15분 시간 창이 언제 다시 시작되는지를 나타내는 UNIX 타임스탬프로, 이 시점에 x-rate-limit-remaining 값이 0으로 초기화됩니다.

filter stream 엔드포인트는 현재 사용량 데이터를 보고하지 않습니다. 얼마나 많은 게시물이 전달되었는지 확인하려면, 코드에 계량(metering) 로직을 구현하여 소비량을 측정하고 필요 시 중지 또는 일시 중지할 수 있도록 하십시오. 

스트림의 클라이언트 측을 호스팅하는 코드는 들어오는 게시물을 선입선출(FIFO) 큐 또는 유사한 메모리 구조에 삽입하기만 하면 됩니다. 별도의 프로세스/스레드가 그 큐에서 게시물을 가져와 파싱하고, 저장을 위한 콘텐츠를 준비해야 합니다. 이러한 설계를 사용하면, 들어오는 게시물 수가 급격히 변하는 경우에도 효율적으로 확장할 수 있는 서비스를 구현할 수 있습니다. 개념적으로는 HTTP를 통해 끝없이 긴 파일을 다운로드하는 것처럼 생각할 수 있습니다.

<div id="reconnection-best-practices">
  #### 재연결 모범 사례
</div>

**백오프 전략을 테스트하세요**

백오프 구현을 테스트하는 좋은 방법은 유효하지 않은 인증 자격 증명을 사용하고 재연결 시도를 관찰하는 것입니다. 제대로 구현되었다면 429 응답을 전혀 받지 않아야 합니다.

**여러 번 재연결되는 경우 알림을 발송하세요**

클라이언트가 재연결 간격의 상한값에 도달하면, 연결에 영향을 주는 문제를 파악하고 조치할 수 있도록 알림을 보내도록 구성해야 합니다.

**DNS 변경 처리**

클라이언트 프로세스가 DNS TTL(Time To Live)을 준수하는지 테스트하세요. 일부 스택은 프로세스가 실행되는 동안 해석된 주소를 캐싱하고, 지정된 TTL 내의 DNS 변경 사항을 반영하지 않습니다. 이러한 과도한 캐싱은 X가 IP 주소 간에 부하를 분산할 때 클라이언트에서 서비스 중단으로 이어질 수 있습니다.

**User Agent**

`user-agent` HTTP 헤더에 클라이언트 버전이 포함되도록 하세요. 이는 X 측에서 문제를 진단하는 데 매우 중요합니다. 환경상 `user-agent` 필드를 설정할 수 없다면, 대신 `x-user-agent` 헤더를 설정하세요.