---
title: 규칙 만들기
sidebarTitle: 규칙 만들기
keywords: ["규칙 만들기", "필터 규칙", "스트림 규칙", "규칙 빌더", "filtered stream rules", "규칙 생성", "규칙 가이드"]
---

<div id="building-rules-for-filtered-stream">
  ## filtered stream용 규칙 만들기
</div>

filtered stream 엔드포인트는 스트림에 적용된 일련의 규칙과 일치하는 게시물만 스트림으로 전송합니다. 규칙은 다양한 게시물 속성과 일치시키는 데 사용되는 연산자(operator)들로 구성됩니다.

여러 규칙은 [POST /tweets/search/stream/rules](/ko/x-api/posts/filtered-stream#post-2-tweets-search-stream-rules) 엔드포인트를 사용해 하나의 스트림에 적용할 수 있습니다. 규칙을 추가한 후 [GET /tweets/search/stream](/ko/x-api/posts/filtered-stream#get-2-tweets-search-stream) 엔드포인트를 사용해 스트림에 연결하면, 규칙과 일치하는 게시물만 지속적인 스트리밍 연결을 통해 전달됩니다. 규칙을 추가하거나 제거하기 위해 스트림 연결을 끊을 필요는 없습니다. 

<div id="table-of-contents">
  ### 목차
</div>

* [규칙 만들기](#building-a-rule)
  * [규칙 제한 사항](#rule-limitations)
  * [연산자 사용 가능 여부](#operator-availability)
  * [연산자 유형: 단독 사용 및 결합 필수](#operator-types-standalone-and-conjunction-required)
  * [불리언 연산자와 그룹화](#boolean-operators-and-grouping)
  * [연산 순서](#order-of-operations)
  * [구두점, 발음 구별 기호, 대소문자 구분](#punctuation-diacritics-and-case-sensitivity)
  * [구체성 및 효율성](#specificity-and-efficiency)
  * [규칙을 단계적으로 만들기](#iteratively-building-a-rule)
  * [규칙 추가 및 제거](#adding-and-removing-rules)
  * [규칙 예시](#rule-examples)

<div id="building-a-rule">
  ### 규칙 생성하기
</div>

<div id="rule-limitations">
  #### 규칙 제한
</div>

규칙 개수에 대한 제한은 어떤 [access level](/ko/x-api/getting-started/about-x-api)이 사용 중인 [프로젝트](/ko/resources/fundamentals/projects)에 적용되어 있는지에 따라 달라집니다.

이러한 제한이 어떻게 적용되는지는 [filtered stream 소개](/ko/x-api/posts/filtered-stream) 페이지에서 확인할 수 있습니다.

<div id="operator-types-standalone-and-conjunction-required">
  #### 연산자 유형: 단독 연산자와 결합이 필요한 연산자
</div>

**단독 연산자(standalone operators)**는 단독으로도 사용할 수 있고, (결합이 필요한 연산자를 포함해) 다른 어떤 연산자와 함께 사용할 수도 있습니다.

예를 들어, 다음 규칙은 단독 연산자인 `#hashtag` 연산자를 사용하기 때문에 유효합니다.

`#xapiv2`

**결합이 필요한(conjunction required) 연산자**는 규칙에서 단독으로 사용할 수 없으며, 규칙에 최소 하나의 단독 연산자가 포함된 경우에만 사용할 수 있습니다. 이러한 연산자만 단독으로 사용하면 조건이 지나치게 포괄적이어서, 너무 많은 양의 게시물과 일치하게 되기 때문입니다.

예를 들어, 다음 규칙들은 결합이 필요한 연산자만 포함하고 있으므로 지원되지 않습니다.

`has:media`

`has:links OR is:retweet`

`"X data"`와 같은 단독 연산자를 추가하면, 해당 규칙은 올바르게 작동합니다. 

`"X data" has:mentions (has:media OR has:links)`

<div id="boolean-operators-and-grouping">
  #### 불리언 연산자와 그룹화
</div>

하나의 규칙 안에서 여러 연산자를 함께 사용하려면, 다음과 같은 방식을 사용할 수 있습니다:

|     |     |
| :--- | :--- |
| **AND 로직** | 연속된 연산자 사이에 **공백이 있을 경우** 불리언 &quot;AND&quot; 로직이 적용됩니다. 이는 두 조건이 모두 충족될 때만 게시물이 일치한다는 의미입니다. 예를 들어 `snow day #NoSchool`은 snow와 day라는 용어, 그리고 해시태그 #NoSchool을 모두 포함하는 게시물과 일치합니다. |
| **OR 로직** | 연속된 연산자 사이에 OR를 넣으면 OR 로직이 적용됩니다. 이는 두 조건 중 하나라도 충족되면 게시물이 일치한다는 의미입니다. 예를 들어 `grumpy OR cat OR #meme`을 지정하면, grumpy 또는 cat 용어, 혹은 해시태그 #meme 중 적어도 하나를 포함하는 모든 게시물과 일치합니다. |
| **NOT 로직, 부정** | 키워드(또는 어떤 연산자든) 앞에 대시(-)를 붙이면 이를 부정(NOT)할 수 있습니다. 예를 들어 `cat #meme -grumpy`는 해시태그 #meme과 cat 용어를 포함하지만, grumpy 용어는 포함하지 않는 게시물과만 일치합니다. 자주 쓰이는 규칙 절(clause)로는 `-is:retweet`이 있으며, 이는 리트윗에는 일치하지 않으므로 원본 게시물, 인용 트윗, 답글에만 일치합니다. 모든 연산자는 부정할 수 있지만, 부정된 연산자만 단독으로 사용할 수는 없습니다. |
| **그룹화** | 괄호를 사용해 연산자를 함께 그룹화할 수 있습니다. 예를 들어 `(grumpy cat) OR (#meme has:images)`는 grumpy와 cat 용어를 모두 포함하는 게시물, 혹은 이미지가 있고 해시태그 #meme을 포함하는 게시물 중 하나와 일치합니다. AND가 먼저 적용되고, 그 다음에 OR가 적용된다는 점에 유의하세요. |

<Note>
  **부정 사용에 대한 참고 사항**

  `sample:`을 제외한 모든 연산자는 부정할 수 있으며, `-is:nullcast`는 항상 부정된 형태, 즉 대시가 붙은 `-is:nullcast`로만 사용해야 합니다. 부정된 연산자는 단독으로 사용할 수 없습니다.

  괄호로 묶인 연산자 집합 전체를 한 번에 부정하지 마세요. 대신 각 연산자를 개별적으로 부정하세요.

  예를 들어 `skiing -(snow OR day OR noschool)`을 사용하는 대신, `skiing -snow -day -noschool`을 사용할 것을 권장합니다. 
</Note>

<div id="order-of-operations">
  #### 연산 순서
</div>

AND와 OR 연산을 함께 사용할 때는, 다음과 같은 연산 순서에 따라 규칙이 평가됩니다.

1. AND 논리로 연결된 연산자가 먼저 결합됩니다
2. 그런 다음 OR 논리로 연결된 연산자가 적용됩니다

예를 들어:

* `apple OR iphone ipad`는 `apple OR (iphone ipad)`로 평가됩니다
* `ipad iphone OR android`는 `(iphone ipad) OR android`로 평가됩니다

모호성을 없애고 규칙이 의도한 대로 평가되도록 하려면, 필요에 따라 괄호로 용어를 묶어 주세요. 

예를 들어:

* `(apple OR iphone) ipad`
* `iphone (ipad OR android)`

<div id="punctuation-diacritics-and-case-sensitivity">
  #### 구두점, 발음 부호, 그리고 대소문자 구분
</div>

강세 기호나 발음 부호가 포함된 키워드 또는 해시태그 규칙을 지정하면, 해당 강세 기호나 발음 부호가 정확히 포함된 단어가 들어 있는 게시물과는 일치하지만, 같은 문자이지만 강세 기호나 발음 부호가 없는 경우와는 일치하지 않습니다. 

예를 들어, 키워드 `diacrítica` 또는 해시태그 `#cumpleaños` 규칙은 강세 기호나 발음 부호를 포함하고 있기 때문에 *diacrítica* 또는 &#95;#cumpleaños&#95;를 포함하는 게시물과는 일치합니다. 그러나 이러한 규칙은 틸데가 있는 í 또는 ñ(eñe)가 빠진 *Diacritica* 또는 &#95;#cumpleanos&#95;를 포함하는 게시물과는 일치하지 않습니다.

강세 기호나 발음 부호가 있는 문자는 일반 문자와 동일하게 취급되며, 단어 경계로 취급되지 않습니다. 예를 들어, 키워드 *cumpleaños* 규칙은 &#95;cumpleaños&#95;라는 단어를 포함하는 게시물과만 일치하고, *cumplea*, *cumplean* 또는 &#95;os&#95;를 포함하는 게시물과는 일치하지 않습니다.

모든 연산자는 대소문자를 구분하지 않고 평가됩니다. 예를 들어, 규칙 cat은 다음 모든 경우와 일치합니다: *cat*, *CAT*, *Cat*.

<Note>
  [Search Posts](/ko/x-api/posts/search/introduction)의 매칭 동작은 filtered stream과 다르게 동작합니다. [Search Posts 쿼리를 작성](/ko/x-api/posts/search/integrate/build-a-query)할 때, 강세 기호나 발음 부호가 포함된 키워드와 해시태그는 강세 기호와 발음 부호가 있는 형태뿐 아니라 일반 문자만 있는 형태와도 모두 일치한다는 점을 알아 두십시오. 

  예를 들어, 키워드 `Diacrítica` 또는 해시태그 `#cumpleaños`가 포함된 Search Posts 쿼리는 틸데가 있는 í 또는 ñ(eñe)가 포함된 *Diacrítica* 및 &#95;#cumpleaños&#95;뿐 아니라, 틸데가 없는 *Diacritica* 또는 &#95;#cumpleanos&#95;와도 일치합니다.
</Note>

<div id="specificity-and-efficiency">
  #### 구체성과 효율성
</div>

규칙을 만들기 시작할 때는 몇 가지를 염두에 두는 것이 중요합니다.

* 단일 키워드나 #hashtag와 같은 광범위한 단일 연산자를 규칙에 사용하는 것은 일반적으로 권장되지 않습니다. 이렇게 하면 매우 많은 양의 게시물과 일치하게 될 가능성이 높습니다. 더 견고한 규칙을 만들면 더 구체적인 게시물 집합과 일치하게 되어, 페이로드에서 가치 있는 인사이트를 찾기 위해 걸러내야 하는 노이즈의 양을 줄이는 데 도움이 됩니다. 
  * 예를 들어, 규칙이 단순히 키워드 `happy`뿐이라면 하루에 200,000~300,000개의 게시물을 받게 될 수 있습니다.
  * 더 많은 조건 연산자를 추가하면 검색 결과 범위를 좁힐 수 있습니다. 예를 들어 `(happy OR happiness) place_country:GB -birthday -is:retweet`
* 효율적인 규칙을 작성하는 것은 규칙 길이에 대한 문자 수 제한을 준수하는 데에도 도움이 됩니다. 문자 수는 공백과 연산자를 포함한 전체 규칙 문자열을 기준으로 계산됩니다.
  * 예를 들어, 다음 규칙의 길이는 59자입니다: `(happy OR happiness) place_country:GB -birthday -is:retweet`

<div id="quote-tweet-matching-behavior">
  #### 인용 트윗 매칭 동작
</div>

filtered stream 엔드포인트를 사용할 때 연산자는 인용된 원래 게시물의 콘텐츠와 인용 트윗의 콘텐츠 모두에 대해 일치 여부를 검사합니다.

다만 [게시물 검색](/ko/x-api/posts/search/introduction) 엔드포인트는 인용된 원래 게시물의 콘텐츠에는 일치하지 않고, 인용 트윗의 콘텐츠에만 일치한다는 점에 유의하십시오.

<div id="iteratively-building-a-rule">
  #### 규칙을 단계적으로 구축하기
</div>

<div id="test-your-rule-early-and-often">
  ##### 규칙을 가능한 한 일찍, 자주 테스트하세요
</div>

처음부터 규칙이 &quot;올바른&quot; 결과를 반환하는 일은 드뭅니다. X에는 처음에는 명확하지 않을 수도 있는 요소가 매우 많고, 위에서 설명한 규칙 문법은 원하는 검색과 정확히 맞추기 어려울 수 있습니다. 규칙을 만들어 나가는 동안 스트림 엔드포인트로 주기적으로 테스트하여 어떤 데이터를 반환하는지 확인하는 것이 중요합니다. 또한, 사용 중인 연산자들이 해당 엔드포인트에서도 사용 가능하다는 전제하에 [Search Post](/ko/x-api/posts/search/introduction) 엔드포인트 중 하나로 테스트할 수도 있습니다. 

이 섹션에서는 다음 규칙으로 시작하여, 테스트 과정에서 얻는 결과를 바탕으로 이를 조정해 보겠습니다. 

`happy OR happiness`

<div id="use-results-to-narrow-the-rule">
  ##### 결과를 활용해 규칙을 좁혀 나가기
</div>

규칙을 테스트할 때는, 반환된 게시물을 살펴보면서 기대하는 데이터가 포함되어 있는지 확인해야 합니다. 먼저 범위가 넓은 규칙과 더 많은 게시물 매치를 포함하는 상위 집합으로 시작하면, 그 결과를 검토한 뒤 원치 않는 결과를 필터링하도록 규칙을 점차 좁혀 나갈 수 있습니다.  

예시 규칙을 테스트해 보니, 다양한 언어로 작성된 게시물을 받는다는 것을 확인했습니다. 이 경우에는 영어로 된 게시물만 받도록 하고자 하므로 `lang:` 연산자를 추가하겠습니다:

`(happy OR happiness) lang:en`

테스트 결과, 생일을 축하하는 게시물이 많이 전달되었기 때문에 `-birthday`를 부정 키워드 연산자로 추가하겠습니다. 또한 원본 게시물만 받기를 원하므로, 부정된 `-is:retweet` 연산자도 추가합니다:

`(happy OR happiness) lang:en -birthday -is:retweet`

<div id="adjust-for-inclusion-where-needed">
  ##### 필요한 경우 포함 범위 조정하기
</div>

예상했던 데이터가 들어오지 않는데 실제로는 반환되어야 할 기존 게시물이 있다는 것을 알고 있다면, 원하는 데이터를 걸러내고 있을 수 있는 연산자를 제거해 규칙의 범위를 넓혀야 할 수 있습니다. 

이 예시에서 우리는 찾고 있는 감정을 표현하지만 테스트 결과에는 포함되지 않은 다른 게시물들이 개인 타임라인에 있다는 것을 확인했습니다. 더 넓은 범위를 확보하기 위해 `excited`와 `elated` 키워드를 추가하겠습니다.

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet`

<div id="adjust-for-popular-trendsbursts-over-the-time-period">
  ##### 시간 경과에 따른 인기 트렌드나 급증 현상에 맞게 조정하기
</div>

X에서는 트렌드가 빠르게 생겼다가 사라집니다. 규칙을 유지·관리하는 일은 능동적인 과정이어야 합니다. 하나의 규칙을 오래 사용할 계획이라면, 정기적으로 들어오는 데이터를 확인해 조정이 필요한지 살펴볼 것을 권장합니다.

예시에서는 사람들에게 “happy holidays”라고 인사하는 게시물을 일부 수집하기 시작했다는 점을 확인했습니다. 이러한 게시물을 결과에 포함하고 싶지 않기 때문에, 부정 키워드인 `-holidays`를 추가하겠습니다.

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet -holidays`

<div id="adding-and-removing-rules">
  #### 규칙 추가 및 제거
</div>

스트림에 규칙을 추가하거나 제거할 때는 모두 [POST /2/tweets/search/stream/rules](/ko/x-api/posts/filtered-stream#post-2-tweets-search-stream-rules) 엔드포인트를 사용합니다.

스트림에 하나 이상의 규칙을 추가하려면, 규칙을 포함하는 `value` 파라미터와, 이 규칙과 일치하는 반환된 [게시물을 식별하는 데 사용할 수 있는](/ko/x-api/posts/filtered-stream#matching-returned-posts-to-their-associated-rule) 임의의 텍스트를 담는 선택적 `tag` 파라미터를 포함한 배열로 구성된 `add` JSON 요청 본문을 전송하면 됩니다. 

예를 들어, 스트림에 규칙 집합을 추가하려는 경우 cURL 명령은 다음과 같을 수 있습니다:

```bash
curl -X POST 'https://api.x.com/2/tweets/search/stream/rules' \
-H "Content-type: application/json" \
-H "Authorization: Bearer $ACCESS_TOKEN" -d \
'{
  "add": [
    {"value": "cat has:media", "tag": "cats with media"},
    {"value": "cat has:media -grumpy", "tag": "미디어가 있는 행복한 고양이"},
    {"value": "meme", "tag": "funny things"},
    {"value": "meme has:images"}
  ]
}'
```

마찬가지로, 스트림에서 하나 이상의 룰을 제거하려면, 삭제하려는 룰 ID를 포함하는 `id` 파라미터 배열이 들어 있는 `delete` JSON 본문을 전송하면 됩니다.

예를 들어, 스트림에서 여러 개의 룰을 제거하려는 경우 cURL 명령은 다음과 같이 작성할 수 있습니다:

```bash
curl -X POST 'https://api.x.com/2/tweets/search/stream/rules' \
  -H "Content-type: application/json" \
  -H "Authorization: Bearer $ACCESS_TOKEN" -d \
  '{
    "delete": {
      "ids": [
        "1165037377523306498",
        "1165037377523306499"
      ]
    }
  }'
```

여러 프로그래밍 언어로 제공되는 샘플 코드는 [GitHub](https://github.com/xdevplatform/Twitter-API-v2-sample-code/tree/master/Filtered-Stream)에서 확인할 수 있습니다.

<div id="rule-examples">
  #### 규칙 예시
</div>

<div id="tracking-a-natural-disaster">
  ##### 자연 재해 추적
</div>

다음 규칙은 2017년에 휴스턴을 강타한 허리케인 Harvey와 관련해 기상 기관과 측정 장비에서 생성된 게시물과 일치했습니다. [matching rules](/ko/x-api/posts/filtered-stream#matching-returned-posts-to-their-associated-rule) 태그의 사용과, 규칙을 [POST /2/tweets/search/stream/rules endpoint](/ko/x-api/posts/filtered-stream#post-2-tweets-search-stream-rules)에 제출할 때 사용해야 하는 JSON 형식에 주목하세요.

```json
{
    "value": "-is:retweet has:geo (from:NWSNHC OR from:NHC_Atlantic OR from:NWSHouston OR from:NWSSanAntonio OR from:USGS_TexasRain OR from:USGS_TexasFlood OR from:JeffLindner1)",
    "tag": "theme:info has:geo original from weather agencies and gauges"
}
```

<div id="reviewing-the-sentiment-of-a-conversation">
  ##### 대화의 감성 파악하기
</div>

다음 규칙은 해시태그 *#nowplaying*을 중심으로 형성되는 대화의 전반적인 감성을 더 잘 파악하는 데 사용할 수 있지만, 북미 지역에서 게시된 게시물만을 대상으로 합니다.

```json
{
    "value": "#nowplaying (happy OR exciting OR excited OR favorite OR fav OR amazing OR lovely OR incredible) (place_country:US OR place_country:MX OR place_country:CA) -horrible -worst -sucks -bad -disappointing",
    "tag": "#nowplaying positive"
},
{
    "value": "#nowplaying (horrible OR worst OR sucks OR bad OR disappointing) (place_country:US OR place_country:MX OR place_country:CA) -happy -exciting -excited -favorite -fav -amazing -lovely -incredible",
    "tag": "#nowplaying negative"
}
```

<div id="find-posts-that-relate-to-a-specific-post-annotation">
  ##### 특정 게시물 주석과 연관된 게시물 찾기
</div>

이 규칙은 게시물에서 식별된 언어가 일본어이고, 고양이가 아닌 반려동물 이미지를 포함한 원본 게시물을 검색하도록 만들어졌습니다. 이를 위해 `context:` 연산자를 사용하여 [Post annotation](/ko/x-api/fundamentals/post-annotations) 기능을 활용했습니다. 먼저 [Post lookup](/ko/x-api/posts/lookup/introduction) 엔드포인트와 `tweet.fields=context_annotations` 필드 파라미터를 사용하여 쿼리에서 사용해야 하는 domain.entity ID 값을 파악했습니다:

* 고양이와 관련된 게시물은 `domain` 66(Interests and Hobbies 카테고리)과 `entity` 852262932607926273(Cats)을 반환합니다. 
* 반려동물과 관련된 게시물은 `domain` 65(Interests and Hobbies Vertical)와 `entity` 852262932607926273(Pets)을 반환합니다. 
   

규칙은 다음과 같이 구성할 수 있습니다:

```json
{
    "value": "context:65.852262932607926273 -context:66.852262932607926273 -is:retweet has:images lang:ja",
    "tag": "Japanese pets with images - no cats"
}
```
