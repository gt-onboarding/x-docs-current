---
title: 스트리밍 데이터 수신하기
sidebarTitle: 스트리밍 데이터 수신하기
keywords: ["스트리밍 데이터 수신하기", "스트리밍 데이터", "스트림 처리", "스트림 처리하기", "스트림 프로세싱", "스트림 수신"]
---

<div id="building-a-client-to-consume-streaming-data">
  ### 스트리밍 데이터를 수신하는 클라이언트 구축
</div>

스트리밍 엔드포인트를 사용할 때는 효율적인 활용을 위해 고려해야 할 일반적인 모범 사례들이 있습니다.  
 

<div id="client-design">
  #### Client 설계
</div>

filter stream 엔드포인트로 솔루션을 구축할 때, 다음을 수행할 수 있는 클라이언트가 필요합니다:

1. filter stream 엔드포인트에 대한 HTTPS 스트리밍 연결을 설정합니다.
2. 스트림에 규칙을 추가·삭제하기 위해 filter stream rules 엔드포인트로 비동기적으로 POST 요청을 전송합니다.
3. 낮은 데이터량 처리 – 스트리밍 연결을 유지하고, 게시물 객체와 keep-alive 신호를 감지합니다.
4. 높은 데이터량 처리 – 비동기 프로세스를 사용해 스트림 수집을 후속 처리와 분리하고, 클라이언트 측 버퍼가 정기적으로 플러시되도록 합니다.
5. 클라이언트 측에서 데이터 사용량 추적을 관리합니다.
6. 스트림 연결 해제를 감지하고, 이를 평가한 뒤 스트림에 자동으로 재연결합니다.
    

<div id="connecting-to-a-streaming-endpoint">
  #### 스트리밍 endpoint에 연결하기
</div>

X API v2 스트리밍 endpoint에 연결을 설정한다는 것은 수명이 매우 긴 HTTP 요청을 보내고 응답을 순차적으로 파싱하는 것을 의미합니다. 개념적으로는 HTTP를 통해 무한히 긴 파일을 다운로드하는 것으로 생각할 수 있습니다. 연결이 설정되면, 연결이 유지되는 동안 X 서버는 해당 연결을 통해 Post 이벤트를 계속 전송합니다.
 

<div id="consuming-data">
  #### 데이터 수신
</div>

JSON 객체의 개별 필드는 순서가 정해져 있지 않으며, 모든 상황에서 모든 필드가 항상 존재하는 것은 아닙니다. 마찬가지로, 개별 activity들은 정렬된 순서로 전달되지 않으며, 중복 메시지가 발생할 수 있습니다. 시간이 지나면서 새로운 메시지 타입이 추가되어 스트림을 통해 전송될 수 있다는 점도 염두에 두십시오.

따라서 클라이언트는 다음을 허용해야 합니다:

* 임의의 순서로 나타나는 필드
* 예기치 않거나 누락된 필드
* 정렬되지 않은 게시물
* 중복 메시지
* 스트림을 통해 언제든 내려올 수 있는 임의의 새로운 메시지 타입

관련 게시물 데이터와 요청한 필드 매개변수 외에도, 스트림 연결에서는 다음과 같은 유형의 메시지가 전달될 수 있습니다. 이 목록이 전체를 포괄하지 않을 수 있으며, 추가 객체가 스트림에 도입될 수 있다는 점에 유의하십시오. 파서가 예기치 않은 메시지 포맷도 허용하도록 구현해야 합니다.
 

<div id="buffering">
  #### 버퍼링
</div>

스트리밍 엔드포인트는 데이터가 이용 가능해지는 즉시 전송하므로, 많은 경우 매우 큰 데이터 양으로 이어질 수 있습니다. X 서버가 스트림에 새 데이터를 바로 쓸 수 없는 경우(예: 클라이언트가 충분히 빠르게 읽지 못하는 경우, 자세한 내용은 [handling disconnections](/ko/x-api/posts/filtered-stream#what-is-a-disconnection)을 참고) 서버 쪽에서 콘텐츠를 버퍼링하여 클라이언트가 따라잡을 수 있도록 합니다. 그러나 이 버퍼가 가득 차면 연결을 끊기 위한 강제 연결 종료가 발생하고, 버퍼링된 게시물은 삭제되며 다시 전송되지 않습니다. 자세한 내용은 아래를 참고하세요.

앱이 처리 속도에서 뒤처지고 있는 시점을 파악하는 한 가지 방법은 수신 중인 게시물의 타임스탬프를 현재 시간과 비교하고, 이를 시간에 따라 추적하는 것입니다.

공용 인터넷 환경에서는 잠재적인 지연과 간헐적인 장애로 인해 스트림 적체를 완전히 없앨 수는 없지만, 앱을 적절히 구성하면 대부분의 적체를 방지할 수 있습니다. 적체 발생을 최소화하려면 다음을 수행하세요.

* 클라이언트가 스트림을 충분히 빠르게 읽고 있는지 확인하세요. 일반적으로 스트림을 읽는 동안 실질적인 처리 작업을 수행해서는 안 됩니다. 스트림을 읽고, 처리할 작업을 다른 스레드/프로세스/데이터 저장소에 넘겨 비동기적으로 처리하세요.
* 데이터 센터가 큰 지속적 데이터 양과 그보다 훨씬 큰 스파이크(예: 평상시의 5~10배 데이터 양)를 수용할 수 있을 만큼 충분한 수신 대역폭을 보유하고 있는지 확인하세요. filtered stream의 경우, 발생하는 데이터 양과 그에 따른 필요한 대역폭은 전적으로 규칙이 어떤 게시물을 매칭하느냐에 달려 있습니다.
   

<div id="usage-tracking-and-rule-management">
  #### 사용량 추적 및 규칙 관리
</div>

개발자들이 스트림에서 기대하는 “정상적인” 데이터 볼륨 수준이 제각기 다르기 때문에, 특정 퍼센트 감소/증가나 기간에 대한 일반적인 권장값은 제공하지 않습니다. 

스트림 데이터 볼륨을 모니터링하여 예상치 못한 편차가 있는지 확인하는 것이 좋습니다. 데이터 볼륨 감소는 스트림 연결 해제와는 다른 문제의 징후일 수 있습니다. 이러한 상황에서는 스트림이 여전히 keep-alive 신호와 일부 신규 활동 데이터를 수신하고 있을 수 있습니다. 그러나 게시물 수가 눈에 띄게 감소했다면, 애플리케이션이나 네트워크로 유입되는 데이터 볼륨 감소를 초래하는 원인이 있는지 조사하고, 관련 공지가 있는지 [status page](https://api.twitterstat.us/)를 확인해야 합니다.

이러한 모니터링을 위해 일정 시간 동안 예상되는 신규 게시물 수를 추적할 수 있습니다. 스트림의 데이터 볼륨이 지정된 임계값보다 충분히 낮아지고, 설정된 시간 내에 회복되지 않는다면, 경보 및 알림이 발생하도록 구성해야 합니다. 또한 필터링 스트림에서 규칙을 수정하는 과정에 있거나, 게시물 활동이 급증하는 이벤트가 발생한 경우와 같이 데이터 볼륨이 크게 증가하는 상황도 함께 모니터링하는 것이 좋습니다.

필터링 스트림을 통해 전달되는 게시물은 전체 월간 게시물 볼륨에 포함되므로, 최적화를 위해 소비량을 추적하고 조정해야 합니다. 볼륨이 높은 경우, 각 규칙에 sample: 연산자를 추가하여 100% 매칭에서 필요에 따라 sample:50 또는 sample:25로 줄이는 것을 고려하십시오. 

또한 앱 내에 사전에 설정한 임계값을 초과할 때 팀에 알림을 보내는 기능을 구현하고, 너무 많은 데이터를 가져오는 규칙을 자동으로 삭제하거나, 극단적인 경우에는 스트림에서 완전히 연결을 끊는 등의 조치를 도입하는 것을 권장합니다.
 

<div id="responding-to-system-messages">
  #### 시스템 메시지에 응답하기
</div>

Keep-alive 신호
최소 20초마다 스트림은 열린 연결을 통해 \r\n 캐리지 리턴 형태의 keep-alive 신호(또는 heartbeat)를 전송하여 클라이언트가 타임아웃되지 않도록 합니다. 클라이언트 애플리케이션은 스트림에 포함된 \r\n 문자를 정상적으로 처리할 수 있어야 합니다.

클라이언트가 HTTP 라이브러리에서 읽기(read) 타임아웃을 올바르게 구현했다면, 이 기간 동안 어떤 데이터도 읽히지 않을 경우 HTTP 프로토콜과 HTTP 라이브러리가 이벤트를 발생시키므로 \r\n 문자를 별도로 명시적으로 모니터링할 필요는 없습니다.

이 이벤트는 일반적으로 예외가 발생하는 형태이거나, 사용 중인 HTTP 라이브러리에 따라 다른 형태의 이벤트일 수 있습니다. 이러한 타임아웃을 감지하기 위해 HTTP 메서드를 오류/이벤트 핸들러로 감싸는 것을 강력히 권장합니다. 타임아웃이 발생하면 애플리케이션은 재연결을 시도해야 합니다.

오류 메시지
v2 스트리밍 엔드포인트에서는 스트림 내에서 오류 메시지를 전달할 수도 있습니다. 아래에는 이러한 메시지의 기본 형식과 몇 가지 예시가 제공되어 있습니다. 전달되는 메시지는 변경될 수 있으며, 새로운 메시지가 도입될 수도 있다는 점에 유의하십시오. 클라이언트 애플리케이션은 변경될 수 있는 시스템 메시지 페이로드를 처리할 수 있어야 합니다.

또한 오류 메시지에는 문제를 해결하는 방법을 설명하는 문서에 대한 링크가 포함된다는 점에 유의하십시오.

메시지 형식:

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "This stream has been disconnected upstream for operational reasons.",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

버퍼가 가득 찼을 때의 강제 연결 해제를 나타내는 오류 메시지는, 해당 강제 연결 해제를 유발한 백로그 때문에 메시지가 전달되지 못하는 경우 클라이언트에 도달하지 못할 수 있습니다. 따라서 앱은 재연결을 시작할 때 이러한 메시지에 의존해서는 안 됩니다.
