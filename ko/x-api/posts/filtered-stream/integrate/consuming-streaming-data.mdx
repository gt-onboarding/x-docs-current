---
title: 스트리밍 데이터 수신
sidebarTitle: 스트리밍 데이터 수신
keywords: ["스트리밍 데이터 수신", "스트리밍 데이터", "스트림 처리", "스트림 처리", "스트림 프로세싱", "스트림 수신"]
---

<div id="building-a-client-to-consume-streaming-data">
  ### 스트리밍 데이터를 처리하는 클라이언트 구축
</div>

스트리밍 엔드포인트를 사용할 때는 사용을 최적화하기 위해 고려해야 할 일반적인 모범 사례가 있습니다.  
 

<div id="client-design">
  #### 클라이언트 설계
</div>

filter stream endpoint로 솔루션을 구축할 때, 다음과 같은 작업을 수행할 수 있는 클라이언트가 필요합니다.

1. filter stream endpoint에 대한 HTTPS 스트리밍 연결을 설정합니다.
2. 스트림의 규칙을 추가·삭제하기 위해 filter stream rules endpoint로 POST 요청을 비동기적으로 전송합니다.
3. 데이터량이 적을 때의 처리 – 스트리밍 연결을 유지하고 게시물 객체와 keep-alive 신호를 감지합니다.
4. 데이터량이 많을 때의 처리 – 비동기 프로세스를 사용해 스트림 수집과 추가 처리를 분리하고, 클라이언트 측 버퍼가 정기적으로 플러시되도록 보장합니다.
5. 클라이언트 측에서 데이터 사용량 추적을 관리합니다.
6. 스트림 연결이 끊어졌는지 감지하고, 상태를 평가한 뒤 스트림에 자동으로 재연결합니다.
    

<div id="connecting-to-a-streaming-endpoint">
  #### 스트리밍 엔드포인트에 연결하기
</div>

X API v2 스트리밍 엔드포인트에 연결한다는 것은 수명이 매우 긴 HTTP 요청을 보내고, 응답을 점진적으로 파싱하는 것을 의미합니다. 개념적으로는 HTTP를 통해 끝없이 긴 파일을 다운로드하는 것처럼 생각할 수 있습니다. 일단 연결이 설정되면, 연결이 열려 있는 동안 X 서버는 해당 연결을 통해 게시물 이벤트를 계속 전달합니다.
 

<div id="consuming-data">
  #### 데이터 소비
</div>

JSON 객체의 개별 필드는 순서가 보장되지 않으며, 모든 상황에서 모든 필드가 항상 존재하는 것은 아닙니다. 마찬가지로, 개별 activity는 정렬된 순서로 전달되지 않으며, 중복 메시지가 발생할 수도 있습니다. 시간이 지남에 따라 새로운 메시지 유형이 추가되어 스트림을 통해 전송될 수 있다는 점을 유념하세요.

따라서, 클라이언트는 다음을 처리할 수 있어야 합니다:

* 어떤 순서로든 나타나는 필드
* 예기치 않은 필드 또는 누락된 필드
* 정렬되지 않은 게시물
* 중복 메시지
* 언제든지 스트림을 통해 내려올 수 있는 새로운 임의의 메시지 유형

관련 게시물 데이터와 요청한 필드 매개변수 외에도, 다음과 같은 유형의 메시지가 스트림 연결에서 전달될 수 있습니다. 이 목록이 완전하지 않을 수 있으며, 추가 객체가 스트림에 도입될 수 있다는 점에 유의하세요. 파서가 예기치 않은 메시지 형식도 무리 없이 처리할 수 있도록 구현하세요.
 

<div id="buffering">
  #### 버퍼링
</div>

스트리밍 엔드포인트는 데이터가 사용 가능해지는 즉시 전송하므로, 경우에 따라 매우 많은 데이터가 발생할 수 있습니다. X 서버가 스트림에 새 데이터를 바로 쓸 수 없는 경우(예: 클라이언트가 데이터를 충분히 빠르게 읽지 못하는 경우, 자세한 내용은 [연결 끊김 처리](/ko/x-api/posts/filtered-stream#what-is-a-disconnection) 참고) 클라이언트가 따라잡을 수 있도록 서버 측에서 콘텐츠를 버퍼링합니다. 하지만 이 버퍼가 가득 차면 연결을 끊기 위한 강제 연결 해제가 수행되고, 버퍼에 있던 게시물은 삭제되며 다시 전송되지 않습니다. 자세한 내용은 아래를 참조하세요.

앱이 처리 속도에서 뒤처지고 있는 시점을 파악하는 한 가지 방법은, 수신 중인 게시물의 타임스탬프를 현재 시각과 비교하고 이를 시간에 따라 추적하는 것입니다.

공용 인터넷 환경에서는 잠재적인 지연 시간(latency)과 일시적인 장애로 인해 스트림 백업을 완전히 제거할 수는 없지만, 앱을 적절히 구성하면 대부분의 문제를 줄일 수 있습니다. 백업 발생을 최소화하려면 다음을 수행하세요.

* 클라이언트가 스트림을 충분히 빠르게 읽고 있는지 확인합니다. 일반적으로 스트림을 읽는 동시에 실제 처리 작업을 수행해서는 안 됩니다. 스트림은 읽기만 하고, 해당 작업은 다른 스레드/프로세스/데이터 저장소로 넘겨 비동기적으로 처리하세요.
* 데이터 센터에 지속적으로 큰 데이터 볼륨을 수용할 수 있는 충분한 인바운드 대역폭과, 그보다 훨씬 큰 스파이크(예: 평상시의 5~10배 볼륨)도 감당할 수 있는 대역폭이 있는지 확인합니다. filtered stream의 경우, 발생하는 트래픽과 그에 따른 필요한 대역폭은 전적으로 규칙이 어떤 게시물과 매칭되는지에 달려 있습니다.
   

<div id="usage-tracking-and-rule-management">
  #### 사용량 추적 및 규칙 관리
</div>

스트림에서 어느 정도의 데이터 양을 “정상적인” 수준으로 볼지에 대한 개발자들의 기대치가 제각각이므로, 특정 퍼센트의 증감이나 특정 기간에 대해 일반적인 권장값을 제시하지는 않습니다. 

스트림 데이터 양에서 예상치 못한 변동이 있는지 모니터링하는 것을 고려하십시오. 데이터 양 감소는 스트림이 끊어진 것과는 다른 문제가 원인일 수 있습니다. 이런 상황에서는 스트림이 여전히 keep-alive 신호와 일부 신규 활동 데이터는 수신하고 있을 것입니다. 그러나 게시물 수가 눈에 띄게 줄어든 경우, 애플리케이션이나 네트워크로 유입되는 데이터 양을 감소시키는 요인이 있는지 조사하고, 관련 공지가 있는지 [상태 페이지](https://api.twitterstat.us/)를 확인해야 합니다.

이와 같은 모니터링을 구현하려면, 일정 시간 동안 새로 수신되기를 기대하는 게시물 수를 추적할 수 있습니다. 스트림의 데이터 양이 지정된 임계값보다 충분히 낮아지고, 설정한 기간 내에 회복되지 않는다면 경고와 알림이 발생하도록 해야 합니다. 또한, 특히 필터링 스트림의 규칙을 수정하는 중이거나 게시물 활동이 급증하는 이벤트가 발생한 경우에는 데이터 양이 크게 증가하는 상황도 함께 모니터링하는 것이 좋습니다.

필터링 스트림을 통해 전송되는 게시물은 전체 월간 게시물 볼륨에 포함되며, 최적화를 위해 소비량을 추적하고 조정해야 한다는 점이 중요합니다. 볼륨이 높은 경우, 각 규칙에 sample: 연산자를 추가하여 100% 매칭을 필요에 따라 sample:50 또는 sample:25로 줄이는 방안을 고려하십시오. 

또한, 볼륨이 사전에 설정한 임계값을 초과했을 때 팀에 알림을 보내는 기능을 앱 내에 구현할 것을 권장하며, 너무 많은 데이터를 끌어오는 규칙을 자동으로 삭제하거나, 극단적인 경우 스트림 연결을 완전히 해제하는 등의 조치를 도입하는 것도 고려하십시오.
 

<div id="responding-to-system-messages">
  #### 시스템 메시지에 응답하기
</div>

Keep-alive 신호
최소 20초마다 스트림은 열린 연결을 통해 \r\n 캐리지 리턴 형태의 keep-alive 신호(또는 heartbeat)를 보내서 클라이언트가 타임아웃되지 않도록 합니다. 클라이언트 애플리케이션은 스트림에 포함된 \r\n 문자를 문제 없이 처리할 수 있어야 합니다.

클라이언트가 사용하는 HTTP 라이브러리에서 읽기(read) 타임아웃을 올바르게 구현하면, 이 기간 동안 어떤 데이터도 읽히지 않을 때 HTTP 프로토콜과 HTTP 라이브러리가 이벤트를 발생시키므로 \r\n 문자를 별도로 모니터링할 필요가 없습니다.

이 이벤트는 일반적으로 예외가 발생하거나, 사용 중인 HTTP 라이브러리에 따라 다른 형태의 이벤트일 수 있습니다. 이러한 타임아웃을 감지할 수 있도록 HTTP 메서드를 오류/이벤트 핸들러로 감싸 두는 것을 강력히 권장합니다. 타임아웃이 발생하면 애플리케이션은 재연결을 시도해야 합니다.

오류 메시지
v2 스트리밍 엔드포인트는 스트림 내에서 오류 메시지를 전달할 수도 있습니다. 아래에는 이러한 메시지의 기본 형식과 몇 가지 예시가 제공되어 있습니다. 전달되는 메시지는 변경될 수 있으며, 새로운 메시지가 도입될 수도 있다는 점에 유의하십시오. 클라이언트 애플리케이션은 변경될 수 있는 시스템 메시지 페이로드를 유연하게 처리할 수 있어야 합니다.

오류 메시지에는 문제를 해결하는 방법을 설명하는 문서에 대한 링크가 포함됩니다.

메시지 형식:

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "This stream has been disconnected upstream for operational reasons.",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

버퍼 가득 참(full buffer)으로 인한 강제 연결 해제를 나타내는 오류 메시지는, 해당 강제 연결 해제를 유발한 백업(backup) 때문에 메시지가 전송되지 못하는 경우 클라이언트에 도달하지 못할 수 있습니다. 따라서 앱은 재연결을 시작할 때 이러한 메시지에 의존해서는 안 됩니다.
