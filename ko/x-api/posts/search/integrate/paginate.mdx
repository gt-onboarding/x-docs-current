---
title: 페이지네이션
sidebarTitle: 페이지네이션
keywords: ["검색 페이지네이션", "페이지네이션 가이드", "결과 페이지 이동", "페이지네이션 토큰", "검색 페이지네이션", "next_token"]
---

<div id="recent-search-pagination">
  ### Recent search 페이지네이션
</div>

<div id="introduction">
  #### 소개
</div>

검색 쿼리는 보통 단일 API 응답에 담을 수 있는 것보다 더 많은 게시물과 일치합니다. 이 경우 데이터는 여러 개의 ‘페이지’로 나뉘어 반환됩니다. 페이지네이션은 전체 데이터 세트를 가져오기 위해 이 모든 페이지를 순차적으로 요청하는 방법을 의미합니다.

다음은 최근 검색 페이지네이션의 기본 사항입니다:

* 최근 검색 엔드포인트는 쿼리에 대해 최소 한 페이지로 응답하며, 추가 페이지가 있을 경우 JSON 응답에 next&#95;token을 제공합니다. 일치하는 게시물을 모두 받으려면 응답에 토큰이 포함되지 않을 때까지 이 과정을 반복하면 됩니다.

* next&#95;token은 만료되지 않습니다. 동일한 next&#95;token 값을 사용한 여러 요청은, 요청 시점에 관계없이 동일한 결과를 받게 됩니다.

* 게시물은 UTC 시간대를 기준으로 최신순(역순)으로 전달됩니다. 이는 개별 페이지 내에서도, 여러 페이지에 걸쳐서도 동일하게 적용됩니다:
  * 첫 번째 응답의 첫 번째 게시물은 쿼리와 일치하는 게시물 중 가장 최신 게시물입니다.
  * 마지막 응답의 마지막 게시물은 쿼리와 일치하는 게시물 중 가장 오래된 게시물입니다.

* max&#95;results 요청 파라미터를 사용하면 응답당 반환되는 게시물 수를 설정할 수 있습니다. 기본값은 게시물 10개이며, 최대값은 100개입니다. 

* 모든 페이지네이션 구현에서는 응답 페이로드에서 next&#95;token 값을 파싱한 뒤, 이를 ‘다음 페이지’ 검색 요청에 포함해야 합니다. 이러한 ‘다음 페이지’ 요청을 구성하는 방법에 대한 자세한 내용은 아래를 참고하세요.
   

최근 검색 엔드포인트는 두 가지 기본 사용 패턴을 지원하도록 설계되었습니다:

* **과거 데이터 가져오기 (Get historical)** - 관심 있는 특정 기간의 일치하는 게시물을 요청하는 패턴입니다. 일반적으로 과거 연구를 지원하기 위한 일회성 요청입니다. 검색 요청은 start&#95;time 및 end&#95;time 요청 파라미터를 기준으로 할 수 있습니다. 최근 검색 엔드포인트는 최신 일치 게시물부터 시작하여 게시물을 최신순(역순)으로 응답합니다. 

* **폴링 (Polling)** - 마지막으로 받은 게시물 이후에 게시된, 일치하는 게시물을 요청하는 패턴입니다. 이러한 사용 사례는 보통 준실시간(near-real-time)을 목표로 하며, 관심 있는 새 게시물을 “청취”하기 위해 잦은 요청이 이루어진다는 특징이 있습니다. 최근 검색 엔드포인트는 이 ‘폴링’ 패턴을 지원하기 위해 since&#95;id 요청 파라미터를 제공합니다. 게시물 ID 기준으로 탐색할 수 있도록 until&#95;id 요청 파라미터도 사용할 수 있습니다.
   

다음으로 과거 모드(historical mode)에 대해 설명합니다. 이는 최근 검색 엔드포인트의 기본 모드이며 페이지네이션의 기본 개념을 보여 줍니다. 그다음 폴링 사용 사례 예시를 살펴보겠습니다. 폴링으로 인해 페이지네이션이 발생하는 경우 검색 요청을 관리하기 위한 추가 단계가 필요합니다.
 

<div id="retrieving-historical-data">
  #### 과거 데이터 검색
</div>

이 섹션에서는 start&#95;time 및 end&#95;time 요청 매개변수를 사용해 관심 있는 기간(현재는 최근 7일로 제한) 동안의 게시물을 가져오는 방법을 설명합니다. 과거 데이터 요청은 일반적으로 연구와 분석을 지원하기 위한 일회성 요청입니다. 

특정 기간의 데이터를 요청하는 방식은 recent search 엔드포인트의 기본 모드입니다. 검색 요청에 start&#95;time, end&#95;time, 또는 since&#95;id 요청 매개변수가 지정되지 않은 경우, end&#95;time은 기본적으로 &quot;now&quot;(실제로는 쿼리 시점 기준 30초 전)로 설정되고, start&#95;time은 기본적으로 7일 전으로 설정됩니다.

엔드포인트는 가장 최근 게시물부터 시작해 시간 역순(reverse‑chronological order)으로 정렬된 첫 번째 &#39;페이지&#39;의 게시물을 반환합니다. 응답 JSON payload에는 추가 데이터 페이지가 있는 경우 next&#95;token도 포함됩니다. 일치하는 게시물을 페이지 수와 관계없이 모두 수집하려면 next&#95;token이 더 이상 제공되지 않을 때까지 요청을 반복하면 됩니다. 

예를 들어, 지난 1주일 동안 키워드 snow를 포함하는 게시물을 조회하는 초기 요청은 다음과 같습니다:

[https://api.x.com/2/tweets/search/recent?query=snow](https://api.x.com/2/tweets/search/recent?query=snow)

응답에는 가장 최근 10개의 게시물과 함께 JSON 응답에 다음과 같은 &quot;meta&quot; 속성이 포함됩니다:

```
"meta": {
        "newest_id": "1204860593741553664",
        "oldest_id": "1204860580630278147",
        "next_token": "b26v89c19zqg8o3fobd8v73egzbdt3qao235oql",
        "result_count": 10
    }
```

다음 10개의 게시물을 가져오려면 이 next&#95;token을 원래 요청에 추가하면 됩니다. 요청은 다음과 같습니다:

[https://api.x.com/2/tweets/search/recent?query=snow&amp;next&#95;token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql](https://api.x.com/2/tweets/search/recent?query=snow\&next_token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql)

next&#95;token을 확인하고 이를 이후 요청에 포함하는 과정을, 모든(또는 일정 개수의) 게시물을 수집할 때까지 또는 지정된 요청 횟수에 도달할 때까지 반복할 수 있습니다. 데이터 완전성(쿼리와 일치하는 모든 결과를 수집하는 것)이 사용 사례에서 핵심이라면, 단순히 &quot;request.next&#95;token이 null이 될 때까지 반복&quot;하는 설계로 충분합니다.

<div id="polling-and-listening-use-cases">
  #### 폴링 및 리스닝 사용 사례
</div>

이 섹션에서는 `since_id` 요청 매개변수를 사용해 최근 검색 엔드포인트를 폴링(polling)하여 최신 게시물을 가져오는 방법을 설명합니다. 

폴링 사용 사례에서는 ‘새로 관심 있는 게시물이 있나요?’와 같은 쿼리를 지속적이고 빈번하게 수행합니다. 요청 시점을 시간에 기반해 구성하는 과거 데이터 사용 사례와 달리, 폴링 사용 사례는 일반적으로 게시물 ID를 기준으로 요청을 구성합니다.

폴링 패턴의 핵심은 모든 새 게시물이 X 플랫폼에서 일반적으로 오름차순으로 ‘발급(emitted)’되는 [고유 ID](/ko/resources/fundamentals/x-ids)를 가진다는 점입니다. 한 게시물의 ID가 다른 게시물의 ID보다 작다면, 그 게시물이 더 먼저 게시되었다는 의미입니다.

최근 검색 엔드포인트는 게시물 ID를 기준으로 게시물 아카이브를 탐색하는 기능을 지원합니다. 이 엔드포인트의 응답에는 `oldest_id` 및 `newest_id` 게시물 ID가 포함됩니다. 폴링 모드에서는 지금까지 받은 ID 중 가장 크고(가장 최신인) ID를 `since_id`로 설정해 요청을 보냅니다. 

예를 들어, 눈(snow)에 대한 새 게시물을 5분마다 조회하고 있고, 마지막으로 수신한 게시물의 게시물 ID가 10000이라고 가정해 보겠습니다. 폴링 시점의 요청은 다음과 같습니다:

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=10000](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=10000)

다음으로, 마지막 요청 이후 게시물 7개가 새로 게시되었다고 가정해 보겠습니다. 이 게시물들이 모두 하나의 데이터 ‘페이지’에 들어가기 때문에 `next_token`은 존재하지 않습니다. 응답에는 가장 최근(최신) 게시물의 게시물 ID가 제공됩니다:

```
"meta": {
        "newest_id": "12000",
        "oldest_id": "10005",
        "result_count": 7
    }
```

다음 폴링 쿼리를 수행하기 위해 이 newest&#95;id 값을 사용하여 다음 since&#95;id 파라미터를 설정합니다:

`https://api.x.com/2/tweets/search/recent?query=snow&since_id=12000`

더 많은 데이터가 있고 next 토큰이 제공되는 경우에는, 결과의 첫 번째 페이지에서 나온 newest&#95;id 값만 필요합니다. 각 데이터 페이지에는 newest&#95;id와 oldest&#95;id 값이 포함되지만, 다음에 정기적으로 실행될 폴링 요청에는 첫 번째 페이지에서 제공된 값만 사용하면 됩니다. 따라서 폴링 방식으로 구현하거나 ID 범위로 게시물을 검색하는 경우, 페이지네이션 로직이 조금 더 복잡해집니다. 

이제 일치하는 게시물이 18개 더 있다고 가정해 보겠습니다. 이 엔드포인트는 이 5분 구간에서 다음 페이지의 데이터를 요청할 수 있도록, 전체 데이터 페이지와 함께 next&#95;token이 포함된 초기 응답을 반환합니다. 또한 5분 후 다음 폴링 주기에 필요한 최신 게시물 ID도 함께 제공합니다.

```
"meta": {
        "newest_id": "13800",
        "oldest_id": "12500",
        "next_token": "fnsih9chihsnkjbvkjbsc",
        "result_count": 10
    }
```

이 5분 구간에 대한 모든 일치하는 데이터를 수집하려면, 다음 요청에 next&#95;token을 포함하고 since&#95;id 값은 이전 요청과 동일하게 사용하십시오.

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=12000&amp;next&#95;token=fnsih9chihsnkjbvkjbsc](https://api.x.com/2/tweets/search/recent?query=snow\&since\\_id=12000\&next\\_token=fnsih9chihsnkjbvkjbsc)

```
"meta": {
        "newest_id": "12300",
        "oldest_id": "12010",
        "result_count": 8
    }
```

두 번째 응답은 나머지 8개의 게시물을 반환하며, next&#95;token은 포함되지 않습니다. newest&#95;id 값(12300)은 업데이트하지 않고, 첫 번째 응답의 newest&#95;id 값을 기준으로 다음 since&#95;id 요청을 보냅니다:

[https://api.x.com/2/tweets/search/recent?query=snow&amp;since&#95;id=13800](https://api.x.com/2/tweets/search/recent?query=snow\&since_id=13800)
