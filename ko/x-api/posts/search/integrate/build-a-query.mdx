---
title: 쿼리 작성하기
sidebarTitle: 쿼리 작성하기
keywords: ["쿼리 작성하기", "검색 쿼리", "쿼리 빌더", "검색 연산자", "쿼리 구문", "검색 쿼리 작성하기", "쿼리 가이드"]
---

<div id="building-queries-for-search-posts">
  ## 검색 게시물용 쿼리 작성
</div>

검색 엔드포인트는 단일 쿼리를 포함한 GET 요청을 받아, 해당 쿼리와 일치하는 과거 게시물 집합을 반환합니다. 쿼리는 다양한 게시물 속성과 매칭하는 데 사용되는 연산자로 구성됩니다. 

<div id="table-of-contents">
  ### 목차
</div>

* [쿼리 작성하기](#build)
* [쿼리 제한](#limits)
* [연산자 사용 가능 여부](#availability)
* [연산자 유형: 단독 사용 및 결합 필수](#types)
* [불리언(논리) 연산자와 그룹화](#boolean)
* [연산 순서](#order-of-operations)
* [구두점, 발음 구별 부호, 대소문자 구분](#punctuation)
* [정확도와 효율성](#specificity)
* [인용 트윗 매칭 방식](#quote-tweets)
* [쿼리를 점진적으로 구성하기](#iterative)
* [요청에 쿼리 추가하기](#adding-a-query)
* [쿼리 예시](#examples)
* [연산자 목록](#list)

<div id="building-a-query">
  ### 쿼리 구성하기
</div>

<div id="query-limitations">
  #### 쿼리 제한 사항
</div>

사용 중인 [액세스 레벨](/ko/x-api/getting-started/about-x-api)에 따라 쿼리 길이에 제한이 있습니다. 

Basic 또는 Pro 액세스를 사용하는 경우, 최근 검색 엔드포인트에서는 쿼리 길이가 최대 512자로 제한됩니다. 

Pro 액세스를 사용하는 경우, 전체 아카이브 검색 엔드포인트에서는 쿼리 길이가 최대 1,024자로 제한됩니다. 

<div id="operator-availability">
  #### 연산자 사용 가능 여부
</div>

대부분의 연산자는 모든 개발자가 사용할 수 있지만, 일부 연산자는 특정 액세스 수준에서만 사용할 수 있습니다. 각 연산자가 어떤 액세스 수준에서 제공되는지는 [연산자 목록](/ko/x-api/posts/search/integrate/operators) 표에서 아래 레이블을 사용해 표시합니다:

* **핵심 연산자:** 어떤 [Project](/ko/resources/fundamentals/projects)를 사용하든 사용할 수 있습니다.
* **고급 연산자:** 특정 액세스 수준을 가진 Project에서 사용할 수 있습니다.

<div id="operator-types-standalone-and-conjunction-required">
  #### 연산자 유형: 단독 사용 가능 연산자와 연결 필수 연산자
</div>

**단독 사용 가능 연산자(standalone operators)**는 단독으로도, 또는 (연결 필수 연산자를 포함해) 다른 어떤 연산자와도 함께 사용할 수 있습니다.

예를 들어, 다음 쿼리는 단독 사용 가능 연산자인 `#hashtag` 연산자를 사용하기 때문에 유효합니다:

`#xapiv2`

**연결 필수(conjunction-required)** 연산자는 쿼리에서 단독으로 사용할 수 없습니다. 쿼리에 최소 한 개의 단독 사용 가능 연산자가 포함될 때에만 사용할 수 있습니다. 이러한 연산자를 단독으로 사용하면 조건이 지나치게 포괄적이 되어, 매우 많은 양의 게시물이 검색되기 때문입니다.

예를 들어, 다음 쿼리는 연결 필수 연산자만 포함하고 있기 때문에 지원되지 않습니다:

`has:media`

`has:links OR is:retweet`

여기에 `"X data"`와 같은 단독 사용 가능 연산자를 추가하면, 쿼리가 올바르게 동작합니다.

`"X data" has:mentions (has:media OR has:links)`

<div id="boolean-operators-and-grouping">
  #### 부울 연산자와 그룹화
</div>

단일 쿼리에서 여러 연산자를 함께 연결해서 사용하려면 다음과 같은 도구를 사용할 수 있습니다:

|     |     |
| :--- | :--- |
| **AND 논리** | 연속된 연산자 사이에 공백이 있을 경우 부울 &quot;AND&quot; 논리가 적용되며, 두 조건이 모두 충족될 때만 게시물이 일치합니다. 예를 들어, `snow day #NoSchool` 은 snow와 day라는 용어와 해시태그 #NoSchool이 모두 포함된 게시물과 일치합니다. |
| **OR 논리** | 연속된 연산자 사이에 OR이 있을 경우 OR 논리가 적용되며, 두 조건 중 하나만 충족되어도 게시물이 일치합니다. 예를 들어, `grumpy OR cat OR #meme` 을 지정하면 grumpy 또는 cat이라는 용어, 혹은 해시태그 #meme 중 적어도 하나를 포함하는 모든 게시물과 일치합니다. |
| **NOT 논리, 부정** | 키워드(또는 어떤 연산자든지) 앞에 대시(-)를 붙이면 이를 부정(NOT)합니다. 예를 들어, `cat #meme -grumpy` 는 해시태그 #meme와 cat이라는 용어를 포함하지만 grumpy라는 용어는 포함하지 않는 게시물과 일치합니다. 일반적으로 많이 사용하는 쿼리 절은 `-is:retweet`로, 리트윗에는 일치하지 않으므로 원본 게시물, 인용 트윗, 답글에만 일치합니다. 모든 연산자는 부정할 수 있지만, 부정된 연산자는 단독으로 사용할 수 없습니다. |
| **그룹화** | 괄호를 사용하여 연산자들을 함께 그룹화할 수 있습니다. 예를 들어, `(grumpy cat) OR (#meme has:images)` 는 grumpy와 cat이라는 용어를 모두 포함하는 게시물, 또는 이미지가 있고 해시태그 #meme를 포함하는 게시물을 반환합니다. AND가 먼저 적용되고, 그 다음에 OR가 적용된다는 점에 유의하세요. |

**부정에 대한 참고 사항**

연산자 `-is:nullcast` 는 항상 부정된 형태로 사용해야 합니다.

부정된 연산자는 단독으로 사용할 수 없습니다.

괄호 한 쌍으로 그룹화된 연산자 집합 전체를 한 번에 부정하지 마세요. 대신 각 개별 연산자를 부정해야 합니다. 예를 들어, `skiing -(snow OR day OR noschool)` 를 사용하는 대신 `skiing -snow -day -noschool` 를 사용할 것을 권장합니다. 

<div id="order-of-operations">
  #### 연산 순서
</div>

AND와 OR 기능을 함께 사용할 때는, 다음 연산 순서에 따라 쿼리가 평가됩니다.

1. AND 논리로 연결된 연산자가 먼저 처리됩니다.
2. 그다음 OR 논리로 연결된 연산자가 적용됩니다.

예를 들어:

* `apple OR iphone ipad`는 `apple OR (iphone ipad)`로 평가됩니다.
* `ipad iphone OR android`는 `(iphone ipad) OR android`로 평가됩니다.

불확실성을 줄이고 쿼리가 의도한 대로 평가되도록 하려면, 적절한 경우 괄호로 검색어를 묶어 주십시오. 

예를 들어:

* `(apple OR iphone) ipad`
* `iphone (ipad OR android)`

<div id="punctuation-diacritics-and-case-sensitivity">
  #### 문장 부호, 발음 구별 부호, 대소문자 구분
</div>

문자 액센트나 발음 구별 부호가 포함된 키워드 또는 해시태그 쿼리를 지정하면, 해당 용어가 액센트·발음 구별 부호를 포함한 경우와 일반 문자만 사용하는 경우를 모두 포함하는 게시물 텍스트와 일치합니다. 예를 들어 키워드 `Diacrítica` 또는 해시태그 `#cumpleaños`가 포함된 쿼리는 *Diacrítica* 또는 &#95;#cumpleaños&#95;뿐만 아니라, 물결표가 없는 í 또는 ñ를 사용한 *Diacritica* 또는 &#95;#cumpleanos&#95;와도 일치합니다.

액센트나 발음 구별 부호가 있는 문자는 일반 문자와 동일하게 취급되며, 단어 경계로 취급되지 않습니다. 예를 들어 키워드 `cumpleaños`를 사용하는 쿼리는 &#95;cumpleaños&#95;라는 단어를 포함하는 활동에만 일치하며, *cumplea*, *cumplean*, &#95;os&#95;를 포함하는 활동에는 일치하지 않습니다.

모든 연산자는 대소문자를 구분하지 않고 평가됩니다. 예를 들어 쿼리 `cat`은 다음 모두를 포함하는 게시물과 일치합니다: *cat*, *CAT*, *Cat*.

[filtered stream](/ko/x-api/posts/filtered-stream)의 일치 방식은 Search Posts와 다르게 작동합니다. [filtered stream 규칙을 구성](/ko/x-api/posts/filtered-stream#building-rules-for-filtered-stream)할 때, 액센트와 발음 구별 부호가 포함된 키워드와 해시태그는 해당 액센트와 발음 구별 부호를 포함하는 용어에만 일치하며, 대신 일반 문자를 사용하는 용어에는 일치하지 않는다는 점을 알아 두십시오. 

예를 들어, filtered stream 규칙에 키워드 `Diacrítica` 또는 해시태그 `#cumpleaños`가 포함된 경우, *Diacrítica* 및 *#cumpleaños* 용어에만 일치하며, 물결표가 없는 í 또는 ñ를 사용하는 *Diacritica* 또는 &#95;#cumpleanos&#95;에는 일치하지 않습니다.

<div id="specificity-and-efficiency">
  #### 구체성과 효율성
</div>

쿼리를 만들 때에는 몇 가지를 염두에 두는 것이 중요합니다.

* 단일 키워드나 #hashtag 같은 범용적인 연산자 하나만을 쿼리로 사용하는 것은 일반적으로 권장되지 않습니다. 이렇게 하면 엄청난 양의 게시물이 매칭될 가능성이 높습니다. 더 견고한 쿼리를 작성하면 더 구체적인 게시물 집합만을 매칭하게 되어, 페이로드에서 유의미한 인사이트를 찾기 위해 걸러내야 하는 노이즈의 양을 줄일 수 있습니다. 
  * 예를 들어, 쿼리가 `happy`라는 키워드 하나뿐이라면, 하루에 대략 200,000 ~ 300,000개의 게시물을 얻게 될 가능성이 높습니다.
  * 더 많은 조건 연산자를 추가하면 검색 결과 범위가 좁아집니다. 예를 들어 `(happy OR happiness) place_country:GB -birthday -is:retweet`
* 효율적인 쿼리를 작성하는 것은 쿼리 길이에 대한 문자 제한을 준수하는 데에도 도움이 됩니다. 문자 개수에는 공백과 연산자를 포함한 전체 쿼리 문자열이 모두 포함됩니다.
  * 예를 들어, 다음 쿼리의 길이는 59자입니다: `(happy OR happiness) place_country:GB -birthday -is:retweet`

<div id="quote-tweet-matching-behavior">
  #### 인용 트윗 매칭 방식
</div>

Search Posts 엔드포인트를 사용할 때, 연산자는 인용된 원본 게시물의 콘텐츠에는 매칭되지 않고 인용 트윗에 포함된 콘텐츠에만 매칭됩니다.

그러나 [filtered stream](/ko/x-api/posts/filtered-stream)은 인용된 원본 게시물의 콘텐츠와 인용 트윗의 콘텐츠 모두에 대해 매칭된다는 점에 유의하세요.

<div id="iteratively-building-a-query">
  #### 쿼리를 단계적으로 구성하기
</div>

<div id="test-your-query-early-and-often">
  ##### 쿼리는 가능한 한 이른 단계부터 자주 테스트하세요
</div>

처음부터 &quot;올바른&quot; 결과를 반환하는 쿼리를 만드는 경우는 드뭅니다. X에는 처음에는 명확하지 않을 수도 있는 많은 콘텐츠가 있고, 위에서 설명한 쿼리 구문을 원하는 검색 조건에 정확히 맞추기는 어려울 수 있습니다. 쿼리를 작성해 나갈 때는 주기적으로 쿼리를 테스트해 보는 것이 중요합니다.

이 섹션에서는 다음 쿼리로 시작한 뒤, 테스트에서 얻은 결과에 따라 이를 조정해 나가겠습니다: 

`happy OR happiness`

<div id="use-results-to-narrow-the-query">
  ##### 검색 결과를 사용해 쿼리 범위 좁히기
</div>

쿼리를 테스트할 때는 반환된 게시물을 훑어보며, 기대했던 데이터가 포함되어 있는지 확인해야 합니다. 처음에는 범위가 넓은 쿼리와 더 많은 게시물 일치 결과의 상위 집합으로 시작하면, 결과를 검토하면서 원하지 않는 결과를 걸러내도록 쿼리를 점점 더 좁혀갈 수 있습니다.  

예시 쿼리를 테스트했을 때, 다양한 언어의 게시물을 받고 있다는 점을 확인했습니다. 이런 상황에서는 영어로 작성된 게시물만 받고 싶으므로 `lang:` 연산자를 추가하겠습니다:

`(happy OR happiness) lang:en`

테스트 결과, 사람들에게 생일을 축하하는 게시물이 많이 포함되어 있었기 때문에 `-birthday`를 부정 키워드 연산자로 추가하겠습니다. 또한 원본 게시물만 받고 싶으므로, 부정 연산자인 `-is:retweet`도 추가했습니다:

`(happy OR happiness) lang:en -birthday -is:retweet`

<div id="adjust-for-inclusion-where-needed">
  ##### 필요한 경우 포함 범위 조정하기
</div>

예상했던 데이터가 들어오지 않고 실제로는 결과에 포함되어야 할 기존 게시물이 있다는 것을 알고 있다면, 원하는 데이터를 걸러내고 있을 수 있는 연산자를 제거해 쿼리 범위를 넓혀야 할 수 있습니다. 

예시에서는, 우리가 찾는 감정을 표현하고 있지만 테스트 결과에 포함되지 않은 다른 게시물들이 개인 타임라인에 있다는 것을 확인했습니다. 더 넓은 범위를 포착하기 위해 `excited`와 `elated` 키워드를 추가하겠습니다.

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet`

<div id="adjust-for-popular-trendsbursts-over-the-time-period">
  ##### 기간 내 인기 트렌드/급증 현상에 맞게 조정하기
</div>

X에서는 트렌드가 매우 빠르게 생기고 사라집니다. 따라서 쿼리를 유지·관리하는 것은 지속적인 작업이어야 합니다. 쿼리를 한동안 사용할 계획이라면, 정기적으로 수신 중인 데이터를 점검하여 조정이 필요한지 확인해 볼 것을 권장합니다.

이 예시에서 우리는 사람들에게 “happy holidays”를 기원하는 게시물들이 수신되기 시작한 것을 확인했습니다. 이러한 게시물이 결과에 포함되지 않도록, 부정 키워드 `-holidays`를 추가하겠습니다.

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet -holidays`

<div id="adding-a-query-to-your-request">
  ### 요청에 쿼리 추가하기
</div>

요청에 쿼리를 추가하려면 `query` 매개변수를 사용해야 합니다. 다른 쿼리 매개변수와 마찬가지로, 작성한 쿼리를 HTTP로 인코딩했는지 반드시 확인해야 합니다.

다음은 cURL 명령을 사용했을 때의 예시이며, 여기에 추가로 `tweet.fields` 및 `max_results` 매개변수가 포함되어 있습니다. 이 명령을 사용하려면 반드시 `$BEARER_TOKEN` 값을 본인의 [Bearer Token](/ko/resources/fundamentals/authentication#oauth-2-0)으로 교체해야 합니다:

```bash
curl https://api.x.com/2/tweets/search/recent?query=cat%20has%3Amedia%20-grumpy&tweet.fields=created_at&max_results=100 -H "Authorization: Bearer $BEARER_TOKEN"
```

<div id="query-examples">
  ### 쿼리 예제
</div>

<div id="tracking-a-natural-disaster">
  #### 자연 재해 추적하기
</div>

다음 쿼리는 2017년에 휴스턴을 강타한 허리케인 하비를 다루는 기상 기관 및 관측소 계정에서 온 원본 게시물에 일치합니다.

HTTP 인코딩을 적용하지 않았을 때의 쿼리는 다음과 같습니다:

`has:geo (from:NWSNHC OR from:NHC\_Atlantic OR from:NWSHouston OR from:NWSSanAntonio OR from:USGS\_TexasRain OR from:USGS_TexasFlood OR from:JeffLindner1) -is:retweet`

그리고 HTTP 인코딩, 쿼리 매개변수, 최근 검색 URI를 포함하면 쿼리는 다음과 같습니다:

`https://api.x.com/2/tweets/search/recent?query=-is%3Aretweet%20has%3Ageo%20(from%3ANWSNHC%20OR%20from%3ANHC\_Atlantic%20OR%20from%3ANWSHouston%20OR%20from%3ANWSSanAntonio%20OR%20from%3AUSGS\_TexasRain%20OR%20from%3AUSGS_TexasFlood%20OR%20from%3AJeffLindner1)`

<div id="reviewing-the-sentiment-of-a-conversation">
  #### 대화의 감성 검토
</div>

다음 규칙은 해시태그 &#95;#nowplaying&#95;을 중심으로 전개되는 대화의 감성을 더 잘 이해하기 위해 사용할 수 있으며, 범위를 북미 지역에서 게시된 게시물로만 제한합니다.

다음은 HTTP 인코딩을 적용하지 않았을 때, 하나는 긍정적 감성용이고 다른 하나는 부정적 감성용인 두 개의 서로 다른 쿼리가 어떻게 구성되는지 보여 주는 예시입니다.

`#nowplaying (happy OR exciting OR excited OR favorite OR fav OR amazing OR lovely OR incredible) (place\_country:US OR place\_country:MX OR place_country:CA) -horrible -worst -sucks -bad -disappointing`

`#nowplaying (horrible OR worst OR sucks OR bad OR disappointing) (place\_country:US OR place\_country:MX OR place_country:CA) -happy -exciting -excited -favorite -fav -amazing -lovely -incredible`

그리고 아래는 HTTP 인코딩, 쿼리 파라미터, recent search URI를 포함했을 때 쿼리가 어떻게 보이는지에 대한 예시입니다.

`https://api.x.com/2/tweets/search/recent?query=%23nowplaying%20(happy%20OR%20exciting%20OR%20excited%20OR%20favorite%20OR%20fav%20OR%20amazing%20OR%20lovely%20OR%20incredible)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place_country%3ACA)%20-horrible%20-worst%20-sucks%20-bad%20-disappointing`

`https://api.x.com/2/tweets/search/recent?query=%23nowplaying%20(horrible%20OR%20worst%20OR%20sucks%20OR%20bad%20OR%20disappointing)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place_country%3ACA)%20-happy%20-exciting%20-excited%20-favorite%20-fav%20-amazing%20-lovely%20-incredible`

<div id="find-posts-that-relate-to-a-specific-post-annotation">
  #### 특정 게시물 주석과 관련된 게시물 찾기
</div>

이 규칙은 게시물에서 식별된 언어가 일본어인 경우, 고양이가 아닌 반려동물 이미지를 포함한 원본 게시물을 검색하도록 설계되었습니다. 이를 위해 `context:` 연산자를 사용해 [Post annotation](/ko/x-api/fundamentals/post-annotations) 기능을 활용했습니다. 먼저 [Post lookup](/ko/x-api/posts/lookup/introduction) 엔드포인트와 `tweet.fields=context_annotations` 필드 매개변수를 사용해, 쿼리에서 사용해야 할 domain.entity ID를 식별했습니다:

* 고양이와 관련된 게시물은 `domain` 66(Interests and Hobbies 카테고리)과 entity 852262932607926273(Cats)을 반환합니다. 
* 반려동물과 관련된 게시물은 `domain` 65(Interests and Hobbies Vertical)와 entity 852262932607926273(Pets)을 반환합니다. 

다음은 HTTP 인코딩 없이 쿼리가 어떻게 보이는지에 대한 예시입니다:

`context:65.852262932607926273 -context:66.852262932607926273 -is:retweet has:images lang:ja`

다음은 HTTP 인코딩, query 매개변수, recent search URI를 포함했을 때 쿼리가 어떻게 보이는지에 대한 예시입니다:

`https://api.x.com/2/tweets/search/recent?query=context%3A65.852262932607926273%20-context%3A66.852262932607926273%20-is%3Aretweet%20has%3Aimages%20lang%3Aja`

추가적인 도움이 필요하다면 [query builder tool](https://developer.x.com/apitools/query?query=)을 사용해 보세요.