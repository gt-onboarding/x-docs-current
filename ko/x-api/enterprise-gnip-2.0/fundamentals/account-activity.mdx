---
title: "Account Activity API: Enterprise"
keywords: ["Enterprise Account Activity API", "Enterprise AAA", "Account Activity Enterprise", "Enterprise 웹훅", "Enterprise 활동"]
---

<Note>
  이 엔드포인트는 게시물 편집 메타데이터를 포함하도록 업데이트되었습니다. 이 메타데이터에 대해 더 알아보려면 [&quot;Edit Posts&quot; 기본 사항 페이지](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets)를 참고하세요. 

  이 엔드포인트는 Direct Messages 엔드포인트와 함께 자주 사용됩니다. 새로운 [v2 Direct Messages 엔드포인트](/ko/x-api/direct-messages/manage/introduction)를 출시했습니다. Enterprise 및 Premium Account Activity API는 v2 1:1 메시지는 지원하지만, 아직 그룹 대화는 지원하지 않습니다.   
</Note>

Overview

`Enterprise`

Account Activity API를 사용하면 웹훅을 통해 사용자 계정과 관련된 실시간 활동을 구독할 수 있습니다. 이를 통해 보유하거나 구독한 하나 이상의 계정에서 발생하는 실시간 게시물, Direct Message 및 기타 계정 이벤트를 단일 연결을 통해 수신할 수 있습니다.

웹훅 등록 시 각 사용자 구독에 대해 아래의 모든 관련 활동을 받게 됩니다:

| Activity types |     |
| :--- | :--- |
| * 게시물(사용자 작성)  <br />    <br />* 게시물 삭제(사용자 수행)<br />* @멘션(사용자에 대한 멘션)<br />* 답글(사용자에게 보내거나 사용자가 보낸 답글)<br />* 리트윗(사용자가 하거나 사용자에 대한 리트윗)<br />* 인용 트윗(사용자가 하거나 사용자에 대한 인용 트윗)<br />* 인용 트윗의 리트윗(사용자가 하거나 사용자에 대한 리트윗)<br />* 좋아요(사용자가 하거나 사용자에 대한 좋아요)<br />* 팔로우(사용자가 하거나 사용자에 대한 팔로우)  <br />    <br />* 언팔로우(사용자 수행) | * 차단(사용자 수행)<br />* 차단 해제(사용자 수행)<br />* 뮤트(사용자 수행)<br />* 뮤트 해제(사용자 수행)<br />* Direct Message 전송(사용자 발신)<br />* Direct Message 수신(사용자 수신)<br />* 입력 중 표시(사용자에게 표시됨)<br />* 읽음 확인(사용자에게 표시됨)<br />* 구독 해지(사용자 수행) |

**참고** - Account Activity API를 통해 홈 타임라인 데이터는 제공되지 않습니다. 이 데이터를 가져오려면 [GET statuses/home&#95;timeline](https://developer.x.com/en/docs/x-api/v1/tweets/timelines/overview)을 사용하세요.
 

<div id="video-series">
  #### 동영상 시리즈
</div>

Account Activity API를 빠르게 이해하는 데 도움이 되는 [4부작 동영상 시리즈](https://www.youtube.com/watch?v=otPxejFhyy8\&index=0\&list=PLFKjcMIU2WshGG6Yj940XM7Z6BFs1zfBg)를 시청해 보세요!

<iframe src="https://platform.x.com/embed/Tweet.html?dnt=false&embedId=twitter-widget-0&features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOltdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2ZvbGxvd2VyX2NvdW50X3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9iYWNrZW5kIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19yZWZzcmNfc2Vzc2lvbiI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfZm9zbnJfc29mdF9pbnRlcnZlbnRpb25zX2VuYWJsZWQiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X21peGVkX21lZGlhXzE1ODk3Ijp7ImJ1Y2tldCI6InRyZWF0bWVudCIsInZlcnNpb24iOm51bGx9LCJ0ZndfZXhwZXJpbWVudHNfY29va2llX2V4cGlyYXRpb24iOnsiYnVja2V0IjoxMjA5NjAwLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3Nob3dfYmlyZHdhdGNoX3Bpdm90c19lbmFibGVkIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19kdXBsaWNhdGVfc2NyaWJlc190b19zZXR0aW5ncyI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdXNlX3Byb2ZpbGVfaW1hZ2Vfc2hhcGVfZW5hYmxlZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdmlkZW9faGxzX2R5bmFtaWNfbWFuaWZlc3RzXzE1MDgyIjp7ImJ1Y2tldCI6InRydWVfYml0cmF0ZSIsInZlcnNpb24iOm51bGx9LCJ0ZndfbGVnYWN5X3RpbWVsaW5lX3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9mcm9udGVuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9fQ%3D%3D&frame=false&hideCard=false&hideThread=false&id=996790447048613888&lang=en&origin=https%3A%2F%2Fdeveloper.x.com%2Fen%2Fdocs%2Fx-api%2Fenterprise%2Faccount-activity-api%2Foverview&sessionId=81f4a0339cbd7bd77b669faa00bd3a7224bc4418&theme=light&widgetsVersion=2615f7e52b7e0%3A1702314776716&width=550px" height="400px" />

<div id="feature-summary">
  ### 기능 요약
</div>

| Tier | 가격 | 고유 구독 수 | 웹훅 수 | 신뢰성 및 활동 복구 |
| :--- | :--- | :--- | :--- | :--- |
| Enterprise | [영업팀 문의](/ko/x-api/enterprise-gnip-2.0/enterprise-gnip) | 최대 500개 이상 | 3개 이상 | [재시도](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries) 및 [Replay](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) |

* 질문이 있으신가요? 오류가 발생하나요?
  * [자주 묻는 질문](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions) 또는 [오류 해결 가이드](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions)를 읽어보세요.

* 샘플 코드를 살펴보세요:
  * [Enterprise Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard-enterprise)는 Enterprise 티어 Account Activity API를 사용하여 웹훅 이벤트를 표시하고 [Replay](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) 기능을 제공하는 Node.js 웹 앱입니다.
  * [SnowBot chatbot](https://github.com/xdevplatform/SnowBotDev)은 Enterprise Account Activity 및 Direct Message API를 기반으로 구축된 Ruby 웹 앱입니다.

<div id="manage-webhooks-and-subscribed-users">
  ## 웹훅과 구독된 사용자 관리
</div>

**⏱ 읽는 데 10분**

Enterprise Account Activity API는 여러분의 서비스에 구독된 X 계정에서 이벤트가 발생할 때마다 웹훅 기반 JSON 메시지를 제공합니다. X는 이러한 활동을 등록된 웹훅으로 전송합니다. 다음 단계에서는 웹훅과 구독된 사용자를 관리하는 방법을 알아봅니다.

웹훅과 구독된 사용자를 등록하고 조회하며 삭제하는 방법을 모두 알아보게 됩니다. 다양한 API 엔드포인트에 요청을 보내기 위해 간단한 cURL 명령을 사용할 것입니다. cURL은 URL 문법을 사용해 요청을 보내거나 가져오는 명령줄 도구입니다.

다음이 필요합니다:

* 등록된 X 앱 - *[여기에서 등록](https://developer.x.com/content/developer-twitter/en/apps)*
* Bearer Token - *[자세히 알아보기](/ko/resources/fundamentals/authentication#using-and-generating-an-app-only-bearer-token)*
* Challenge-Response Check (CRC)를 통과하는 웹훅 - *[자세히 알아보기](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks)*
* Enterprise 계정 - *[여기에서 신청]https://developer.x.com/en/products/x-api/enterprise*

*시작하기 전에, X의 Account Activity API를 시작하는 데 도움이 되는 샘플 웹 앱과 헬퍼 스크립트를 제공하는 [GitHub 리포지토리](https://github.com/xdevplatform/account-activity-dashboard)를 확인할 것을 권장합니다.*

<div id="managing-a-webhook">
  #### 웹후크 관리:
</div>

웹후크를 사용하면 단일 연결을 통해 특정 사용자 계정과 관련된 실시간 활동을 구독할 수 있습니다. 

<Tabs>
  <Tab title="웹후크 추가">
    해당 애플리케이션 컨텍스트에 대해 새로운 웹후크 URL을 등록하는 것부터 시작하겠습니다.

    이 URL은 저장되기 전에 CRC 요청을 통해 검증됩니다. 웹후크를 등록한 후에는 나중에 필요하므로 웹후크 ID를 반드시 기록해 두세요.

    아래 항목을 알맞게 수정한 뒤, 다음 cURL 요청을 명령줄에 복사해 실행하세요:

    * **URL** `<URL>` 예: `https://yourdomain.com/webhooks/twitter/`

    * **Consumer key** `<CONSUMER_KEY>` 예: `xvz1evFS4wEEPTGEFPHBog`

    * **Access token** `<ACCESS_TOKEN>` 예:  `370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```
      curl --request POST --url 'https://api.x.com/1.1/account_activity/webhooks.json?url=<URL>' --header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<ACCESS_TOKEN>", oauth_version="1.0"'
      ```
  </Tab>

  <Tab title="웹후크 조회">
    다음 명령을 실행하면 해당 애플리케이션에 대해 등록된 모든 웹후크 URL과 각 URL의 상태가 반환됩니다.

    아래 항목을 알맞게 수정한 뒤, 다음 cURL 요청을 명령줄에 복사해 실행하세요:

    * **Bearer token** `<BEARER_TOKEN>` 예: `AAAAAAAAAAAA0%2EUifi76ZC9Ub0wn...`

      ```curl --request GET --url https://api.x.com/1.1/account_activity/webhooks.json --header 'authorization: Bearer <BEARER_TOKEN>'
      ```
  </Tab>

  <Tab title="웹후크 제거">
    해당 애플리케이션 설정에서 웹후크를 제거하려면, 아래 항목을 알맞게 수정한 뒤 다음 cURL 요청을 명령줄에 복사해 실행하세요:

    * **Webhook ID** `<:WEBHOOK_ID>` 예: `1234567890`

    * **Consumer key** `<CONSUMER_KEY>` 예: `xvz1evFS4wEEPTGEFPHBog`

    * **Access token** `<ACCESS_TOKEN>` 예:  `370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```curl --request DELETE --url https://api.x.com/1.1/account_activity/webhooks/<:WEBHOOK_ID>.json --header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<ACCESS_TOKEN>", oauth_version="1.0"'
      ```
  </Tab>
</Tabs>

<div id="managing-subscribed-users">
  #### 구독된 사용자 관리:
</div>

Webhook을 등록한 후, 해당 계정의 활동을 수신하기 위해 Account Activity API에 구독된 사용자를 추가할 수 있습니다.

<Tabs>
  <Tab title="구독 추가">
    먼저 사용자를 구독하여 모든 이벤트 유형을 받을 수 있도록 설정하겠습니다.

    다음 항목을 변경한 후 아래 cURL 요청을 명령줄에 복사해 실행하세요.

    * **Webhook ID** `<:WEBHOOK_ID>` 예: `1234567890`

    * **Consumer key 이름** `<CONSUMER_KEY>` 예: `xvz1evFS4wEEPTGEFPHBog`

    * **구독된 사용자의 액세스 토큰** `<SUBSCRIBING_USER'S_ACCESS_TOKEN>` 예: `370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```
      curl --request POST --url https://api.x.com/1.1/account_activity/webhooks/<:WEBHOOK_ID>/subscriptions/all.json --header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<SUBSCRIBING_USER'S_ACCESS_TOKEN>", oauth_version="1.0"'
      ```
  </Tab>

  <Tab title="구독 조회">
    지정한 Webhook에 대한 모든 활동 유형 구독 목록을 확인하려면, 다음 항목을 변경한 후 아래 cURL 요청을 명령줄에 복사해 실행하세요.

    * **Webhook ID** `<:WEBHOOK_ID>` 예: `1234567890`

    * **Bearer token** `<BEARER_TOKEN>` 예: `AAAAAAAAAAAA0%2EUifi76ZC9Ub0wn...`

      ```
      curl --request GET --url https://api.x.com/1.1/account_activity/webhooks/<:WEBHOOK_ID>/subscriptions/all/list.json --header 'authorization: Bearer <BEARER_TOKEN>'
      ```
  </Tab>

  <Tab title="구독 제거">
    비활성화 후에는 요청한 사용자의 모든 이벤트가 더 이상 Webhook URL로 전송되지 않습니다.

    제공된 사용자 컨텍스트와 애플리케이션에서 구독을 비활성화하려면, 다음 항목을 변경한 후 아래 cURL 요청을 명령줄에 복사해 실행하세요.

    * **Webhook ID** `<:WEBHOOK_ID>` 예: `1234567890`

    * **Consumer key** `<CONSUMER_KEY>` 예: `xvz1evFS4wEEPTGEFPHBog`

    * **구독된 사용자의 액세스 토큰** `<SUBSCRIBING_USER'S_ACCESS_TOKEN>` 예: `370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb`

      ```
      curl --request DELETE --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all.json --header 'authorization: OAuth oauth_consumer_key="CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="SUBSCRIBED_USER'S_ACCESS_TOKEN", oauth_version="1.0"'
      ```
  </Tab>
</Tabs>

잘하셨습니다! 이제 Webhook과 구독된 사용자를 관리할 수 있습니다.

<div id="referenced-articles">
  #### 참고 문서
</div>

* [Challenge-Response Check (CRC) 개요](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks)
* [Account Activity 데이터 유형](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-data-object-structure)
* [웹훅 및 구독 관리](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#managing-webhooks-and-subscriptions)

<div id="a-video-walkthrough-of-the-account-activity-api">
  ## Account Activity API 비디오 안내
</div>

이 비디오 안내에서는 Account Activity API의 Premium 및 Enterprise 요금제에서 제공하는 기능을 살펴봅니다.

이 비디오를 다 보고 나면 다음과 같은 기능을 이해하게 됩니다.

* 웹훅 등록
* 사용자 구독 추가
* 사용자 구독 제거
* 계정 활동 수신
* 계정 활동 재생

<iframe src="https://platform.x.com/embed/Tweet.html?dnt=false&embedId=twitter-widget-0&features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOltdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2ZvbGxvd2VyX2NvdW50X3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9iYWNrZW5kIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19yZWZzcmNfc2Vzc2lvbiI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfZm9zbnJfc29mdF9pbnRlcnZlbnRpb25zX2VuYWJsZWQiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X21peGVkX21lZGlhXzE1ODk3Ijp7ImJ1Y2tldCI6InRyZWF0bWVudCIsInZlcnNpb24iOm51bGx9LCJ0ZndfZXhwZXJpbWVudHNfY29va2llX2V4cGlyYXRpb24iOnsiYnVja2V0IjoxMjA5NjAwLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3Nob3dfYmlyZHdhdGNoX3Bpdm90c19lbmFibGVkIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd19kdXBsaWNhdGVfc2NyaWJlc190b19zZXR0aW5ncyI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdXNlX3Byb2ZpbGVfaW1hZ2Vfc2hhcGVfZW5hYmxlZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfdmlkZW9faGxzX2R5bmFtaWNfbWFuaWZlc3RzXzE1MDgyIjp7ImJ1Y2tldCI6InRydWVfYml0cmF0ZSIsInZlcnNpb24iOm51bGx9LCJ0ZndfbGVnYWN5X3RpbWVsaW5lX3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfdHdlZXRfZWRpdF9mcm9udGVuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9fQ%3D%3D&frame=false&hideCard=false&hideThread=false&id=1204084171334832128&lang=en&origin=https%3A%2F%2Fdeveloper.x.com%2Fen%2Fdocs%2Fx-api%2Fenterprise%2Faccount-activity-api%2Fquick-start%2Fa-visual-walkthrough-of-the-account-activity-api&sessionId=b5b8e259a4c6287be2413de9059093170036fb30&theme=light&widgetsVersion=2615f7e52b7e0%3A1702314776716&width=550px" />

* 궁금한 점이 있나요? 오류가 발생하나요?
  * [자주 묻는 질문](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions) 또는 [오류 문제 해결 가이드](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#frequently-asked-questions)를 읽어보세요.

* 샘플 코드를 살펴보세요:
  * [Enterprise Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard-enterprise)는 Enterprise 티어의 Account Activity API를 사용해 웹훅 이벤트를 표시하고 [Replay](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) 기능을 포함하는 Node.js 기반 웹 앱입니다.
  * [SnowBot chatbot](https://github.com/xdevplatform/SnowBotDev)은 Enterprise Account Activity 및 다이렉트 메시지 API 위에 구축된 Ruby 웹 앱입니다.

**Enterprise**

<div id="getting-started-with-webhooks">
  ## 웹훅 시작하기
</div>

Account Activity API는 웹훅 기반 API로, 개발자가 직접 개발·배포·호스팅하는 웹 앱으로 계정 이벤트를 전송합니다. 

이벤트 소비 애플리케이션에서 웹훅 이벤트를 수신하기 시작하기 전에 신경 써야 할, 일종의 ‘배관(plumbing)’에 해당하는 몇 가지 세부 사항이 있습니다. 아래에 설명된 것처럼, X 앱을 생성하고 Account Activity API 액세스 권한을 받은 뒤, 웹훅 이벤트를 처리하는 웹 앱을 개발해야 합니다. 

<div id="1-create-a-x-app">
  ### 1. X 앱을 생성합니다.
</div>

* [developer portal](/ko/resources/fundamentals/developer-portal)에서 승인된 개발자 계정으로 [X app](/ko/resources/fundamentals/developer-apps)을 생성합니다. 회사 명의로 앱을 생성하는 경우, 회사용 X 계정으로 앱을 생성할 것을 권장합니다. 개발자 계정을 신청하려면 [여기를 클릭](/ko/resources/fundamentals/developer-apps)하세요.
* 앱 페이지의 [permissions](/ko/resources/fundamentals/developer-apps#oauth-1-0a-app-permissions) 탭에서 &quot;Read, Write and Access direct messages&quot;를 활성화합니다.
* &quot;Keys and Access Tokens&quot; 탭에서 앱의 Consumer Key (API Key)와 Consumer Token (API Secret)을 기록해 둡니다.
* 같은 탭에서 앱의 [Access Token and Access Token Secret](/ko/resources/fundamentals/authentication#obtaining-access-tokens-using-3-legged-oauth-flow)을 생성합니다. 이 액세스 토큰은 X가 계정 이벤트를 전송할 webhook URL을 등록할 때 필요합니다.
* [X Sign-in](/ko/resources/fundamentals/authentication#log-in-with-x)과 사용자 컨텍스트가 X API에서 어떻게 동작하는지 잘 모른다면 [Obtaining Access Tokens](https://dev.x.com/webhooks/access-tokens)를 확인하세요. 이벤트를 받을 계정을 추가할 때, 해당 계정의 액세스 토큰을 사용해 구독을 설정하게 됩니다.
* [developer portal](/ko/resources/fundamentals/developer-portal)의 [&quot;Apps&quot;](/ko/resources/fundamentals/developer-apps) 페이지에 표시된 앱의 숫자 ID를 기록해 둡니다. Account Activity API 액세스를 신청할 때 이 앱 ID가 필요합니다.
   

<div id="2-get-account-activity-api-access">
  ### 2. Account Activity API 액세스 받기
</div>

X 앱을 만든 후 다음 단계는 Account Activity API 액세스를 신청하는 것입니다. 

Account Activity API는 Enterprise에서만 제공되므로, 아래 링크를 통해 신청서를 제출해야 합니다.

<Button href="https://developer.x.com/en/enterprise-application.html">
  Enterprise 액세스 신청
</Button>

<div id="3-develop-webhook-consumer-app">
  ### 3. 웹훅 컨슈머 앱 개발
</div>

Account Activity API에 대한 액세스 권한을 받았다면, X 웹훅 이벤트를 수신할 웹 앱을 개발·배포·호스팅해야 합니다. 

* 이벤트를 수신하기 위한 웹훅으로 사용할 URL을 갖는 웹 앱을 만듭니다. 이는 서버에 배포되어 들어오는 X 웹훅 이벤트를 수신하는 엔드포인트입니다. 
  * URI *path&#95;는 자유롭게 정할 수 있습니다. 다음 예시는 유효한 예입니다: https://mydomain.com*/service/listen&#95;

  * 다양한 소스로부터 웹훅을 수신하는 경우, 일반적인 패턴은 다음과 같습니다: https://mydomain.com/webhook/twitter

  * 지정한 URL에는 포트 번호를 포함할 수 없습니다(https://mydomain.com:5000/NoWorkie).

* [Securing Webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks) 가이드에서 설명한 것처럼, 첫 단계는 X Challenge Response Check(CRC) GET 요청을 수신하고, 올바르게 형식화된 JSON 응답을 반환하는 코드를 작성하는 것입니다. 

* 웹훅 URL을 등록합니다. /webhooks.json?url= 엔드포인트로 POST 요청을 보내야 합니다. 이 요청을 보내면 X가 웹 앱으로 CRC 요청을 전송합니다. 웹훅이 성공적으로 등록되면 응답에 웹훅 id가 포함됩니다. 이 웹훅 id는 이후 Account Activity API에 일부 요청을 보낼 때 필요합니다. 

* X는 등록한 URL로 계정 웹훅 이벤트를 전송합니다. 웹 앱이 들어오는 이벤트에 대한 POST 요청을 지원하는지 확인하세요. 이러한 이벤트는 JSON으로 인코딩됩니다. 예시 웹훅 JSON 페이로드는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-data-object-structure)를 참고하세요.

* 웹 앱이 준비되면, 다음 단계는 활동을 수신할 계정을 추가하는 것입니다. 계정을 추가(또는 삭제)할 때는 계정 id를 참조하는 POST 요청을 보냅니다. 자세한 내용은 [구독 추가 가이드](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#managing-webhooks-and-subscriptions)를 참고하세요.

<div id="4-validate-setup">
  ### 4. 설정 확인
</div>

* 앱과 webhook이 올바르게 구성되었는지 확인하려면, 앱이 구독 중인 X 계정 중 하나가 게시한 게시물을 즐겨찾기(Favorite)하십시오. 각 즐겨찾기마다 webhook URL로 보내지는 POST 요청을 통해 `favorite_events` 를 수신해야 합니다.
* 구독이 추가된 후 이벤트가 전송되기 시작하기까지 최대 10초가 걸릴 수 있습니다.

**중요 참고 사항**

* webhook URL을 등록할 때, 웹 앱은 consumer 토큰과 시크릿, *그리고 앱 소유자의 사용자 액세스 토큰과 시크릿* 으로 인증해야 합니다. 

* 수신되는 모든 다이렉트 메시지는 webhook을 통해 전달됩니다. 또한 [POST direct&#95;messages/events/new (message&#95;create)](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event) 를 통해 전송된 모든 다이렉트 메시지도 webhook을 통해 전달됩니다. 이렇게 하면 다른 클라이언트를 통해 전송된 다이렉트 메시지도 웹 앱이 인지할 수 있습니다.

* 각 webhook 이벤트에는 어떤 구독으로 인해 이벤트가 전달되었는지를 나타내는 for&#95;user&#95;id 사용자 ID가 포함된다는 점에 유의하십시오.

* 동일한 대화에서 두 사용자가 다이렉트 메시지 용도로 웹 앱을 사용 중인 경우, webhook은 두 개의 중복 이벤트(각 사용자당 하나씩)를 받게 됩니다. 웹 앱은 이 점을 고려해야 합니다. 

* 동일한 webhook URL을 공유하고 동일한 사용자가 각 앱에 매핑된 둘 이상의 웹 앱이 있는 경우, 동일한 이벤트가 webhook으로 여러 번(웹 앱당 한 번씩) 전송됩니다.

* 일부 경우에는 webhook이 중복 이벤트를 수신할 수 있습니다. webhook 앱은 이에 내결함성을 가져야 하며, 이벤트 ID를 기준으로 중복 제거를 수행해야 합니다.

* Quick Reply 응답이 요청 직후에 바로 이어질 것이라고 기대하지 마십시오. 사용자는 Quick Reply 요청을 무시할 수 있으며, 대신 일반 다이렉트 메시지로 응답할 수 있습니다. 또한 사용자는 메시지 스레드에서 이전에 응답하지 않았던 요청에 대해 나중에 Quick Reply 응답을 보낼 수도 있습니다.

* 예제 코드를 참고하십시오:
  * [Enterprise Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard-enterprise): Account Activity API의 Enterprise 티어를 사용하여 webhook 이벤트를 표시하는 Node 웹 앱으로, [Replay](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api) 기능을 포함합니다.

  * [SnowBot chatbot](https://github.com/xdevplatform/SnowBotDev): Account Activity API와 Direct Message API를 기반으로 구축된 Ruby 웹 앱입니다. 이 코드베이스에는 Account Activity API webhook 설정을 도와주는 [스크립트](https://github.com/xdevplatform/SnowBotDev/wiki/Account-Activity-API-setup-script)가 포함되어 있습니다.

<div id="securing-webhooks">
  ## 웹훅 보안
</div>

X의 웹훅 기반 API는 웹훅 서버의 보안을 확인하기 위한 두 가지 방법을 제공합니다.

1. Challenge-Response 검사를 통해 X는 웹훅 이벤트를 수신하는 웹 앱의 소유권을 확인할 수 있습니다. 
2. 각 POST 요청의 서명 헤더를 사용하면 수신된 웹훅의 실제 발신자가 X인지 확인할 수 있습니다.
    

<div id="challenge-response-checks">
  ### Challenge-Response 체크
</div>

앱과 webhook URL 모두의 소유자임을 검증하기 위해, X는 Challenge-Response Check(CRC)를 수행합니다. 이는 순환 중복 검사(cyclic redundancy check)와 혼동하면 안 됩니다. CRC가 전송되면, X는 `crc_token` 파라미터를 포함해 웹 앱에 GET 요청을 보냅니다. 이 요청을 수신하면, 웹 앱은 *`crc_token`* 파라미터와 앱의 Consumer Secret(아래 상세 설명)을 기반으로 암호화된 `response_token`을 생성해야 합니다. `response_token`은 JSON 형식으로 인코딩되어야 하며(아래 예시 참고), 3초 이내에 반환되어야 합니다. 성공하면 webhook `id`가 반환됩니다. 

webhook URL을 등록할 때 CRC가 전송되므로, CRC 응답 코드를 구현하는 것은 가장 기본적인 첫 단계입니다. webhook이 설정된 이후에는, 마지막으로 성공적인 응답을 받은 시점으로부터 대략 24시간마다 X가 CRC를 트리거합니다. 또한 필요할 때는 webhook `id`로 PUT 요청을 보내 앱이 직접 CRC를 트리거할 수도 있습니다. 새로운 코드를 배포하고 서비스를 재시작한 후 등, webhook 애플리케이션을 개발·운영하는 동안 CRC를 트리거하는 것은 유용합니다. 

&#95;`crc_token`&#95;은 들어오는 각 CRC 요청마다 변경되며, Consumer Secret을 키로 사용한 계산에서 메시지로 사용해야 합니다.

응답이 3초 이내에 전송되지 않거나 유효하지 않은 경우, 등록된 webhook으로 이벤트가 더 이상 전송되지 않습니다.

<div id="the-crc-request-will-occur">
  #### CRC 요청은 다음과 같은 경우에 발생합니다:
</div>

* webhook URL이 등록될 때.
* webhook URL을 검증하기 위해 대략 *매시간* 한 번.
* PUT 요청으로 CRC를 수동으로 트리거할 수 있습니다. webhook 클라이언트를 개발할 때는 CRC 응답을 구현하는 동안 CRC를 수동으로 트리거하는 계획을 세워야 합니다. 
   

<div id="response-requirements">
  #### 응답 요구 사항:
</div>

* `crc_token`과 앱 Consumer Secret으로부터 생성된, base64로 인코딩된 HMAC SHA-256 해시
* 유효한 response&#95;token 값 및 JSON 형식.
* 3초 미만의 지연 시간.
* HTTP 200 응답 코드.
   

<div id="language-specific-hmac-libraries">
  #### 언어별 HMAC 라이브러리:
</div>

* [Java/Scala](https://docs.oracle.com/javase/8/docs/api/index.html?javax/crypto/Mac.html)
* [Ruby](http://ruby-doc.org/stdlib-2.1.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html)
* [Node.js](https://nodejs.org/api/crypto.html#crypto_class_hmac)
* [Python](https://docs.python.org/2/library/hmac.html)

<div id="example-response-token-generation-in-python">
  #### Python을 사용한 응답 토큰 생성 예시:
</div>

다음 예제는 Python 2.7 Flask 웹앱에서 challenge response check에 올바르게 응답하는 라우트를 정의합니다.

```
import base64
import hashlib
import hmac
import json


\# Defines a route for the GET request
@app.route('/webhooks/twitter', methods=\['GET'\])
def webhook_challenge():

  # 수신 토큰과 컨슈머 시크릿으로 HMAC SHA-256 해시를 생성합니다
  sha256\_hash\_digest = hmac.new(TWITTER\_CONSUMER\_SECRET, msg=request.args.get('crc_token'), digestmod=hashlib.sha256).digest()

  # base64 인코딩된 해시로 응답 데이터를 구성합니다
  response = {
    'response\_token': 'sha256=' + base64.b64encode(sha256\_hash_digest)
  }

  # 올바른 형식의 JSON 응답을 반환합니다
  return json.dumps(response)
```

<div id="example-json-response">
  #### 예시 JSON 응답:
</div>

위와 같이 라우트를 정의한 경우, 웹 브라우저에서 [https://your-app-domain/webhooks/twitter?crc&#95;token=foo](https://your-app-domain/webhooks/twitter?crc_token=foo) 주소로 이동하면 웹 앱은 아래와 비슷한 응답을 반환해야 합니다.

```
{
  "response_token": "sha256=x0mYd8hz2goCTfcNAaMqENy2BFgJJfJOb4PdvTffpwg="
}
```

<div id="other-examples">
  #### 다른 예시:
</div>

* [여기](https://github.com/xdevplatform/account-activity-dashboard/blob/master/helpers/security.js)는 Node/JS로 작성된 CRC 응답 메서드 예시입니다.
* [여기](https://github.com/xdevplatform/SnowBotDev/blob/master/app/controllers/snow_bot_dev_app.rb)는 Ruby로 작성된 CRC 응답 메서드 예시입니다 (*generate&#95;crc&#95;response* 메서드와 CRC 이벤트를 수신하는 /GET 라우트를 참고하세요).

<div id="optional-signature-header-validation">
  ### 선택적 서명 헤더 검증
</div>

X로부터 POST 요청을 받거나, 웹후크를 생성하기 위해 GET 요청을 보내거나, 수동 CRC를 수행하기 위해 GET 요청을 보낼 때, `x-twitter-webhooks-signature`라는 헤더에 해시 서명이 전달됩니다. 이 서명을 사용해 데이터의 출처가 X인지 검증할 수 있습니다. POST 해시 서명은 `sha256=`로 시작하며, 이는 HMAC SHA-256을 사용해 X 앱 Consumer Secret과 페이로드에 서명을 한다는 것을 나타냅니다. GET 해시는 쿼리 매개변수 문자열 `crc_token=$token&nonce=$nonce`에서 계산됩니다. 

**요청을 검증하는 단계**

1. Consumer secret과 수신한 페이로드 본문을 사용해 해시를 생성합니다.
2. 생성된 해시를 base64로 인코딩된 `x-twitter-webhooks-signature` 값과 비교합니다. 타이밍 공격에 대한 취약성을 줄이기 위해 [compare&#95;digest](https://docs.python.org/2/library/hmac.html)와 같은 함수를 사용하십시오.

<div id="additional-security-guidelines">
  ### 추가 보안 가이드라인
</div>

다음은 웹 애플리케이션에서 추가로 고려해야 할 보안 가이드라인입니다. 이 가이드라인을 구현하지 않더라도 webhook 기능이 동작하지 않는 것은 아니지만, X 정보 보안 팀에서 강력히 권장하는 사항입니다. 아래 권장 사항에 익숙하지 않다면 서버 관리자와 상의하십시오.

<div id="x-aggregate-network-blocks">
  #### X 집계 네트워크 블록
</div>

보안을 한층 강화하기 위해 다음 집계 네트워크 블록을 allowlist(허용 목록)에 추가하는 것을 권장합니다:

* 199.59.148.0/22

* 199.16.156.0/22

* 192.133.77.0/26

* 64.63.15.0/24

* 64.63.31.0/24

* 64.63.47.0/24

* 202.160.128.0/24

* 202.160.129.0/24

* 202.160.130.0/24

<div id="recommended-server-configurations">
  #### 권장 서버 구성
</div>

* [ssllabs.com](http://ssllabs.com/) 테스트에서 &quot;A&quot; 등급
* **TLS 1.2 활성화**
* Forward Secrecy 활성화
* SSLv2 비활성화
* SSLv3 비활성화 (POODLE 취약점으로 인해)
* TLS 1.0 비활성화
* TLS 1.1 비활성화
* TLS Compression 비활성화
* 세션 티켓 키를 주기적으로 교체하지 않는 한 Session Tickets 비활성화
* SSL 설정에서 “ssl&#95;prefer&#95;server&#95;ciphers” 또는 “SSLHonorCipherOrder” 옵션을 “on”으로 설정
* 암호 스위트 목록이 다음과 같은 최신 목록인지 확인:
  `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:DES-CBC3-SHA`

<div id="managing-webhooks-and-subscriptions">
  ## 웹훅 및 구독 관리
</div>

<div id="creating-changing-webhooks">
  ### Webhook 생성 및 변경
</div>

webhook URL을 변경하려면 기존 webhook을 삭제한 후 새 webhook을 생성해야 합니다. 이때 새 webhook에 사용자 구독을 다시 추가해야 한다는 점에 유의하십시오.

<div id="webhook-configuration-management-endpoints">
  #### Webhook 구성 관리 엔드포인트:
</div>

|     |     |
| :--- | :--- |
| **Method** | Enterprise |
| webhook URL 등록 / webhook&#95;id 생성 | [POST webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) |
| 모든 webhook URL 및 해당 상태 반환 | [GET webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |
| 앱의 현재 webhook 구성 삭제 | [DELETE webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) |
| CRC 요청 수동 트리거 | [PUT webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) |

<div id="why-cant-i-just-update-the-webhook-url">
  #### 왜 웹훅 URL만 바꾸면 안 되나요?
</div>

왜 웹훅 구성은 한 번 설정하면 수정할 수 없을까요? X는 보안을 매우 중요하게 생각합니다. 웹훅 URL이 변경되었다면 애플리케이션의 consumer key와 consumer secret이 유출되었을 가능성이 있습니다. 새 웹훅 구성을 생성하도록 하는 것은, 동시에 사용자 이벤트에 다시 구독하도록 요구하는 것이기도 합니다. 이 과정에는 악의적인 제3자가 가지고 있을 가능성이 낮은 액세스 토큰을 사용해야 합니다. 그 결과, 다른 사람이 사용자의 비공개 정보를 수신할 가능성이 줄어듭니다.
 

<div id="adding-removing-user-subscriptions">
  ### 사용자 구독 추가 및 제거
</div>

수천 개의 구독을 지원하는 기능은 Enterprise 티어에서 제공됩니다. 이미 전담 담당자가 있는 경우, 궁금한 점이 있으면 담당자에게 문의해 주십시오. Enterprise API 액세스를 신청하려면 [여기를 클릭](https://developer.x.com/en/products/x-api/enterprise)하십시오. 

<div id="subscription-management-endpoints">
  #### 구독 관리 엔드포인트
</div>

|     |     |
| :--- | :--- |
| 메서드 | Enterprise |
| 새 사용자 구독 추가 | [POST webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) |
| 사용자 구독 조회 | [GET webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) |
| 모든 활성 구독 목록 반환 | [GET webhooks/:webhook&#95;id/subscriptions/all/list](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |
| 앱 전용 OAuth 를 사용하여 사용자 구독 비활성화 | [DELETE webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |

Account Activity API: Enterprise

<Note>
  **유의해 주세요**: 

  X가 Account Activity API 사용을 시작하기 전에, 먼저 개발자 앱에 대해 Account Activity API 액세스를 활성화해야 합니다. 이를 위해, 인증에 사용할 앱 ID를 계정 관리자 또는 기술 지원 팀과 반드시 공유해 주세요.
</Note>

[Account Activity API](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity)는 단일 연결을 통해 구독한 모든 계정에 대한 실시간 계정 활동을 수신할 수 있도록, 사용자 구독을 생성하고 관리할 수 있게 해 주는 일련의 엔드포인트로 구성되어 있습니다. 

Account Activity API에서는 두 가지 인증 방법([OAuth 1.0a](/ko/resources/fundamentals/authentication#oauth-1-0a-2) 및 [OAuth 2.0 Bearer Token](/ko/resources/fundamentals/authentication#bearer-token-also-known-as-app-only))을 사용할 수 있습니다. 어떤 인증 방법을 사용할지는 사용하는 엔드포인트에 따라 달라집니다.

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| **Description** | **Endpoint ** | OAuth 1.0a  <br />(user context) | OAuth 2.0 Bearer Token (application-only) |
| 지정된 애플리케이션 컨텍스트에 대해 새로운 webhook URL을 등록 | [POST account&#95;activity/webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks) | ✓   |     |
| 지정된 애플리케이션의 모든 URL과 해당 상태를 반환 | [GET account&#95;activity/webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |     | ✓   |
| 특정 webhook URL에 대해 challenge response check(CRC)를 트리거 | [PUT account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) | ✓   |     |
| 애플리케이션을 사용자의 계정 이벤트에 구독 | [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 현재 활성 구독의 개수를 반환 | [GET account&#95;activity/subscriptions/count](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |     | ✓   |
| webhook 구성이 사용자의 이벤트를 구독 중인지 확인 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 현재 활성 구독의 목록을 반환 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all-list) |     | ✓   |
| webhook 삭제 | [DELETE account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) | ✓   |     |
| [DEPRECATED] 제공된 사용자 컨텍스트 및 애플리케이션에 대한 구독 비활성화 | [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) | ✓ * |     |
| application-only OAuth를 사용하여 구독을 비활성화 | [DELETE /account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |     | ✓   |
| 활동을 webhook으로 다시 전송 | [POST /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#replay-api) |     | ✓   |

*&#95; 인증에는 구독하는 사용자의 액세스 토큰이 필요합니다. &#95;

OAuth 1.0a 사용자 컨텍스트 인증이 필요한 엔드포인트의 경우, 요청을 인증하려면 다음 자격 증명을 제공해야 합니다: 

* Consumer Keys(API Key 및 Secret)
* Access Tokens(Access Token 및 Secret)

다음 세 엔드포인트에서는 X 사용자가 관여하지 않고 애플리케이션 컨텍스트 내에서 쓰기 작업을 수행합니다. 따라서 제공해야 하는 액세스 토큰은 개발자 앱에 속한 토큰입니다. 이 토큰은 [developer portal](https://developer.x.com/en/portal/projects-and-apps)에서 해당 앱의 “키와 토큰(Keys and tokens)” 탭을 통해 직접 생성할 수 있습니다.  

* [POST account&#95;activity/webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks): 지정된 애플리케이션 컨텍스트에 대해 새로운 웹훅 URL을 등록합니다
* [PUT account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id): 지정된 웹훅 URL에 대해 CRC(Challenge Response Check)를 트리거합니다
* [DELETE account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id): 웹훅을 삭제합니다

반면, 다음 세 가지 엔드포인트의 경우에는 애플리케이션이 X 사용자를 대신해 보호된 데이터(예: 다이렉트 메시지)에 액세스할 수 있도록 요청을 보내게 됩니다. 따라서 해당 구독 대상 사용자에 속한 액세스 토큰을 제공해야 합니다. 필요한 액세스 토큰은 3-legged OAuth 플로우를 사용하여 얻을 수 있습니다(참고: [OAuth 1.0a: how to obtain a user’s Access Tokens](/ko/resources/fundamentals/authentication#obtaining-access-tokens-using-3-legged-oauth-flow)). 이러한 엔드포인트는 위 표에서 별표(*)로 표시되어 있습니다.

* [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all): 애플리케이션이 사용자의 계정 이벤트를 구독하도록 설정합니다
* [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all): 웹훅 구성이 사용자의 이벤트를 구독 중인지 확인합니다
* [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated): 제공된 사용자 컨텍스트 및 애플리케이션에 대한 구독을 비활성화합니다 [더 이상 사용되지 않음(DEPRECATED)]

<Note>
  **Please note**: 

  개발자 앱이 &quot;Read, Write, and Direct Messages&quot;에 대해 활성화되어 있는지 확인하세요. 이 설정은 개발자 계정의 [Projects &amp; Apps section](https://developer.x.com/en/portal/projects-and-apps)에서, 선택한 개발자 앱의 &quot;App permissions&quot; 아래에서 변경할 수 있습니다. 권한 설정을 변경한 후에는 앱 자격 증명을 다시 생성해야 합니다.
</Note>

Account Activity API에서 사용 가능한 모든 엔드포인트 목록(관련 설명 및 인증 구현 예제가 포함된 예시 cURL 요청 포함)은 [API reference documentation](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index)에서 확인할 수 있습니다.

추가 정보가 필요하다면 Enterprise Account Activity API를 시작하는 데 도움이 되는 XDev의 [sample web app and helper scripts](https://github.com/xdevplatform/account-activity-dashboard-enterprise)를 확인하세요.

<Note>
  **Please note**: 

  Account Activity API를 사용하기 전에, X가 개발자 앱에 대해 Account Activity API 액세스를 활성화해야 합니다. 이를 위해 인증 용도로 사용할 예정인 App ID를 계정 매니저 또는 기술 지원 팀과 반드시 공유하세요.
</Note>

[Account Activity API](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity)는 단일 연결을 통해 구독된 모든 계정에 대한 실시간 계정 활동을 받을 수 있도록, 사용자 구독을 생성하고 관리할 수 있는 일련의 엔드포인트로 구성됩니다. 

Account Activity API에서는 두 가지 인증 방법([OAuth 1.0a](/ko/resources/fundamentals/authentication#oauth-1-0a-2) 및 [OAuth 2.0 Bearer Token](/ko/resources/fundamentals/authentication#oauth-2-0))을 사용할 수 있습니다. 어떤 인증 방법을 사용할지는 사용하는 엔드포인트에 따라 달라집니다.

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| **Description** | **Endpoint ** | OAuth 1.0a  <br />(user context) | OAuth 2.0 Bearer Token (application-only) |
| 지정된 애플리케이션 컨텍스트에 대해 새 webhook URL을 등록합니다 | [POST account&#95;activity/webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks) | ✓   |     |
| 지정된 애플리케이션에 대한 모든 URL과 해당 상태를 반환합니다 | [GET account&#95;activity/webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |     | ✓   |
| 지정된 webhook의 URL에 대해 CRC(challenge response check)를 트리거합니다 | [PUT account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) | ✓   |     |
| 애플리케이션을 사용자의 계정 이벤트에 구독하도록 설정합니다 | [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 현재 활성 구독의 개수를 반환합니다 | [GET account&#95;activity/subscriptions/count](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |     | ✓   |
| webhook 구성이 사용자의 이벤트를 구독 중인지 확인합니다 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) | ✓ * |     |
| 현재 활성 구독의 목록을 반환합니다 | [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all-list) |     | ✓   |
| webhook을 삭제합니다 | [DELETE account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) | ✓   |     |
| [사용 중단됨] 제공된 사용자 컨텍스트와 애플리케이션에 대한 구독을 비활성화합니다 | [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) | ✓ * |     |
| application-only OAuth를 사용하여 구독을 비활성화합니다 | [DELETE /account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |     | ✓   |
| 활동을 webhook으로 다시 전송합니다 | [POST /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#replay-api) |     | ✓   |

*&#95; 인증에는 구독하는 사용자의 액세스 토큰이 필요합니다. &#95;

OAuth 1.0a 사용자 컨텍스트 인증이 필요한 엔드포인트의 경우, 요청을 인증하려면 다음 자격 증명을 제공해야 합니다: 

* Consumer Key(API Key 및 Secret)
* Access Token(Access Token 및 Secret)

다음 세 엔드포인트의 경우 애플리케이션 컨텍스트 내에서 쓰기 작업을 수행합니다(X 사용자는 관여하지 않습니다). 따라서 제공해야 하는 액세스 토큰은 개발자 앱에 속한 토큰입니다. 이는 [developer portal](https://developer.x.com/en/portal/projects-and-apps)의 앱 “Keys and tokens” 탭에서 직접 생성할 수 있습니다.  

* [POST account&#95;activity/webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks): 지정된 앱 컨텍스트에 대해 새로운 webhook URL을 등록합니다.
* [PUT account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id): 지정된 webhook의 URL에 대해 CRC(Challenge Response Check)를 트리거합니다.
* [DELETE account&#95;activity/webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id): webhook을 삭제합니다.

반면, 다음 세 개의 엔드포인트는 애플리케이션이 X 사용자를 대신하여 보호된 데이터(예: 다이렉트 메시지)에 접근할 수 있도록 요청을 보내는 경우입니다. 따라서 해당 구독을 소유한 사용자에게 속한 액세스 토큰을 제공해야 합니다. 필요한 액세스 토큰은 3-legged OAuth 플로우를 사용하여 얻을 수 있습니다([OAuth 1.0a: how to obtain a user’s Access Tokens](/ko/resources/fundamentals/authentication#obtaining-access-tokens-using-3-legged-oauth-flow) 참조). 이 엔드포인트들은 위 표에서 별표(*)로 표시되어 있습니다.

* [POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all): 애플리케이션을 사용자의 계정 이벤트에 구독시킵니다.
* [GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all): webhook 구성이 사용자의 이벤트에 구독되어 있는지 확인합니다.
* [DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated): 제공된 사용자 컨텍스트 및 애플리케이션에 대한 구독을 비활성화합니다 [사용 중단됨(DEPRECATED)]

<Note>
  **주의**: 

  개발자 앱이 &quot;Read, Write, and Direct Messages&quot;로 활성화되어 있는지 확인하세요. 이 설정은 개발자 계정의 [Projects &amp; Apps 섹션](https://developer.x.com/en/portal/projects-and-apps)에서 선택한 개발자 앱의 &quot;App permissions&quot; 아래에서 변경할 수 있습니다. 권한 설정을 변경한 후에는 앱 자격 증명을 다시 생성해야 합니다.
</Note>

Account Activity API에서 사용 가능한 모든 엔드포인트 목록과 관련 설명, 그리고 인증 구현 예제가 포함된 예시 cURL 요청은 [API 레퍼런스 문서](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index)에서 확인할 수 있습니다.

추가 정보가 필요하다면 Enterprise Account Activity API를 시작하는 데 도움이 되는 XDev의 [샘플 웹 앱과 헬퍼 스크립트](https://github.com/xdevplatform/account-activity-dashboard-enterprise)를 확인하세요.

<div id="retries">
  ## 재시도
</div>

`Enterprise`

Account Activity API의 Enterprise 티어가 제공하는 이점 중 하나는 웹훅 이벤트에 대한 재시도 메커니즘입니다. 성공을 나타내는 200 HTTP 응답 코드를 받지 못하면 X 서버는 재시도 메커니즘을 시작하여 5분 이내에 최대 세 번까지 웹훅 이벤트를 다시 전송합니다. 이 웹훅 이벤트 재시도 서비스는 네트워크 문제가 발생했을 때와 클라이언트 측 서비스 중단 및 배포 작업 중에도 신뢰성과 이벤트 복구를 향상하는 데 도움이 됩니다.
 

<div id="what-are-retries">
  ### 재시도란 무엇인가요?
</div>

Account Activity API는 클라이언트의 웹 앱이 계정 활동 웹훅 이벤트에 대해 `200 success` 응답을 반환하지 않을 때 재시도 기능을 제공합니다. 클라이언트 측에서 이벤트를 성공적으로 수신했다는 것을 확인해 주지 않으면 X는 해당 이벤트가 수신되지 않은 것으로 간주합니다. 200이 아닌 응답을 받았거나, 3초 이내에 응답을 받지 못했거나, 아예 응답을 받지 못한 경우, 요청을 재시도하고 그 요청을 3초 동안 열린 상태로 둡니다. 이는 두 번의 시도 동안, 웹훅 URL로 전송하려는 활동에 응답하여 수신을 확인할 수 있는 시간이 대략 5초 정도 주어진다는 의미입니다. 서버가 응답하지 않거나 일시적인 오류를 반환하는 경우, 5분 동안 재시도를 진행합니다. 유효성을 확인하기 위한 재시도는 총 세 번 수행됩니다. 이를 통해 모든 웹훅 이벤트를 수신할 수 있도록 이중화 및 안전장치를 제공합니다. 재시도가 설정된 구독의 경우, 해당 웹훅에 구독된 모든 사용자의 모든 활동에 대해 재시도된 이벤트가 전달됩니다.

이 여덟 번의 시도 안에 유효성을 확인하지 못하면, 해당 활동은 더 이상 Account Activity API를 통해 사용할 수 없습니다. 

<div id="retry-timeline">
  ### 재시도 타임라인
</div>

Account Activity API는 200 응답을 받을 때까지 약 5분에 걸쳐 최대 세 번까지 재시도합니다. 자세한 내용은 아래 표를 참고하세요. 약 5분이 지나면 해당 액티비티는 Account Activity API를 통해 다시 전송할 수 없습니다. 누락된 데이터를 수집하려면 다른 X 엔드포인트를 사용해야 합니다. 예를 들어, [검색 API](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api)를 사용하여 관련 게시물, 리포스트, 인용 트윗, 멘션 및 답글을 조회할 수 있습니다. 누락된 다이렉트 메시지는 [이 엔드포인트](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events)를 통해 조회할 수 있습니다.

<div id="retries-timeline">
  #### 재시도 타임라인
</div>

|     |
| :--- |
| Activity가 생성되면 Account Activity API에서 웹훅 URL로 POST를 시도하며, 3초 후 타임아웃됩니다. |
| 이전 타임아웃이 끝난 후 3초를 기다린 다음 Account Activity API에서 웹훅 URL로 POST를 시도하며, 3초 후 타임아웃됩니다. |
| 이전 타임아웃이 끝난 후 27초를 기다린 다음 Account Activity API에서 웹훅 URL로 POST를 시도하며, 3초 후 타임아웃됩니다. |
| 이전 타임아웃이 끝난 후 242초를 기다린 다음 Account Activity API에서 웹훅 URL로 POST를 시도하며, 3초 후 타임아웃됩니다. |
| 이 이후에는 Account Activity API가 더 이상 POST를 시도하지 않습니다. Client는 다른 X 엔드포인트를 사용하여 데이터를 복구해야 합니다. |

<div id="account-activity-data-object-structure">
  ## Account Activity 데이터 객체 구조
</div>

| Object | Details |
| :--- | :--- |
| for&#95;user&#95;id | 이벤트와 관련된, 구독이 설정된 사용자를 식별합니다. |
| is&#95;blocked&#95;by | (조건부) 다른 사용자가 구독된 사용자를 멘션했을 때만 표시됩니다. 게시물 멘션 이벤트에서만 값이 true인 경우 포함됩니다. |
| source | 활동을 수행하는 사용자입니다. 예를 들어, 팔로우, 차단, 음소거를 수행하는 사용자가 source 사용자입니다. |
| target | 활동의 대상이 되는 사용자입니다. 예를 들어, 팔로우되거나, 차단되거나, 음소거되는 사용자가 target 사용자입니다. |

**사용 가능한 활동**

| Message Type | Details |
| :--- | :--- |
| [tweet&#95;create&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#tweet-create-events-posts-retweets-replies-quotetweets) | 구독 사용자에 의해 또는 구독 사용자에게 다음 중 하나의 작업이 수행될 때의 게시물 상태 페이로드입니다: 게시물, 리트윗, 답글, @멘션, QuoteTweets, Quote Tweet의 리트윗. |
| [favorite&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#favorite-events) | 사용자와 target이 포함된 즐겨찾기(좋아요) 이벤트 상태입니다. |
| [follow&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#follow-events) | 사용자와 target이 포함된 팔로우 이벤트입니다. |
| [unfollow&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#unfollow-events) | 사용자와 target이 포함된 언팔로우 이벤트입니다. |
| [block&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#block-events) | 사용자와 target이 포함된 차단 이벤트입니다. |
| [unblock&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#unblock-events) | 사용자와 target이 포함된 차단 해제 이벤트입니다. |
| [mute&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#mute-events) | 사용자와 target이 포함된 음소거 이벤트입니다. |
| [unmute&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#unmute-events) | 사용자와 target이 포함된 음소거 해제 이벤트입니다. |
| [user&#95;event](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#user-event) | 사용자가 애플리케이션 권한을 제거하여 구독이 자동으로 삭제될 때 전송되는 취소(revoke) 이벤트입니다. |
| [direct&#95;message&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-events) | 다이렉트 메시지가 발신 또는 수신될 때, 사용자와 target이 포함된 다이렉트 메시지 상태입니다. |
| [direct&#95;message&#95;indicate&#95;typing&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-indicate-typing-events) | 사용자와 target이 포함된 다이렉트 메시지 입력 중 표시 이벤트입니다. |
| [direct&#95;message&#95;mark&#95;read&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-mark-read-events) | 사용자와 target이 포함된 다이렉트 메시지 읽음 표시 이벤트입니다. |
| [tweet&#95;delete&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#tweet-delete-events) | 규정 준수를 더 쉽게 유지할 수 있도록 삭제된 게시물에 대한 알림입니다. |

**페이로드 예시**

위 표에서 설명한 각 Account Activity 이벤트에 대한 페이로드 예시는 아래를 참조하세요.

<div id="tweet_create_events-posts-retweets-replies-quotetweets">
  #### tweet&#95;create&#95;events (게시물, 리트윗, 답글, 인용 트윗)
</div>

```
{
	"for_user_id": "2244994945",
	"tweet_create_events": [
	  {
		<Tweet Object>
	  }
	]
}
```

<div id="tweet_create_events-mentions">
  #### tweet&#95;create&#95;events (@멘션)
</div>

```
{
	"for_user_id": "2244994945",
	"user_has_blocked": "false",
	"tweet_create_events": [
	  {
		<Tweet Object>
	  }
	]
}
```

<div id="favorite_events">
  #### favorite&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"favorite_events": [{
		"id": "a7ba59eab0bfcba386f7acedac279542",
		"created_at": "Mon Mar 26 16:33:26 +0000 2018",
		"timestamp_ms": 1522082006140,
		"favorited_status": {
			<Tweet Object>
		},
		"user": {
			<User Object>
		}
	}]
}
```

<div id="follow_events">
  #### follow&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"follow_events": [{
			"type": "follow",
			"created_timestamp": "1517588749178",
			"target": {
				<User Object >
			},
			"source": {
				< User Object >
			}
		]
	}
}
```

<div id="unfollow_events">
  #### unfollow&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"follow_events": [{
			"type": "unfollow",
			"created_timestamp": "1517588749178",
			"target": {
				<User Object >
			},
			"source": {
				< User Object >
			}
		]
	}
}
```

<div id="block_events">
  #### block&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"block_events": [{
		"type": "block",
		"created_timestamp": "1518127020304",
		"source": {
			<User Object>
		},
		"target": {
			<User Object>
		}
	}]
}
```

<div id="unblock_events">
  #### unblock&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"block_events": [{
		"type": "unblock",
		"created_timestamp": "1518127020304",
		"source": {
			<User Object>
		},
		"target": {
			<User Object>
		}
	}]
}
```

<div id="mute_events">
  #### mute&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"mute_events": [
		{
			"type": "mute",
		  	"created_timestamp": "1518127020304",
			"source": {
				<User Object>
			},
			"target": {
				<User Object>
			}
		}
	]
}
```

<div id="unmute_events">
  #### unmute&#95;events
</div>

```
{
	"for_user_id": "2244994945",
	"mute_events": [
		{
			"type": "unmute",
		  	"created_timestamp": "1518127020304",
			"source": {
				<User Object>
			},
			"target": {
				<User Object>
			}
		}
	]
}
```

<div id="user_event">
  #### user&#95;event
</div>

```
{
	"user_event": {
		"revoke": {
			"date_time": "2018-05-24T09:48:12+00:00",
			"target": {
				"app_id": "13090192"
			},
			"source": {
				"user_id": "63046977"
			}
		}
	}
}
```

<div id="direct_message_events">
  #### direct&#95;message&#95;events
</div>

```
{
  	"for_user_id": "4337869213",
	"direct_message_events": [{
		"type": "message_create",
		"id": "954491830116155396",
		"created_timestamp": "1516403560557",
		"message_create": {
			"target": {
				"recipient_id": "4337869213"
			},
			"sender_id": "3001969357",
			"source_app_id": "13090192",
			"message_data": {
				"text": "안녕하세요!",
				"entities": {
					"hashtags": [],
					"symbols": [],
					"user_mentions": [],
					"urls": []
				}
			}
		}
	}],
	"apps": {
		"13090192": {
			"id": "13090192",
			"name": "FuriousCamperTestApp1",
			"url": "https://x.com/furiouscamper"
		},
		"users": {},
		"3001969357": {
			"id": "3001969357",
			"created_timestamp": "1422556069340",
			"name": "Jordan Brinks",
			"screen_name": "furiouscamper",
			"location": "Boulder, CO",
			"description": "Alter Ego - X PE opinions-are-my-own",
			"url": "https://t.co/SnxaA15ZuY",
			"protected": false,
			"verified": false,
			"followers_count": 22,
			"friends_count": 45,
			"statuses_count": 494,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
		},
		"4337869213": {
			"id": "4337869213",
			"created_timestamp": "1448312972328",
			"name": "Harrison Test",
			"screen_name": "Harris_0ff",
			"location": "Burlington, MA",
			"protected": false,
			"verified": false,
			"followers_count": 8,
			"friends_count": 8,
			"profile_image_url": "null",
			"statuses_count": 240,
			"profile_image_url_https": "https://abs.twimg.com/sticky/default_profile_images/default_profile_normal.png"
		}
	}
}
```

<div id="direct_message_indicate_typing_events">
  #### direct&#95;message&#95;indicate&#95;typing&#95;events
</div>

```
{
	"for_user_id": "4337869213",
	"direct_message_indicate_typing_events": [{
		"created_timestamp": "1518127183443",
		"sender_id": "3284025577",
		"target": {
			"recipient_id": "3001969357"
		}
	}],
	"users": {
		"3001969357": {
			"id": "3001969357",
			"created_timestamp": "1422556069340",
			"name": "Jordan Brinks",
			"screen_name": "furiouscamper",
			"location": "Boulder, CO",
			"description": "Alter Ego - X PE opinions-are-my-own",
			"url": "https://t.co/SnxaA15ZuY",
			"protected": false,
			"verified": false,
			"followers_count": 23,
			"friends_count": 47,
			"statuses_count": 509,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
		},
		"3284025577": {
			"id": "3284025577",
			"created_timestamp": "1437281176085",
			"name": "Bogus Bogart",
			"screen_name": "bogusbogart",
			"protected": true,
			"verified": false,
			"followers_count": 1,
			"friends_count": 4,
			"statuses_count": 35,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/763383202857779200/ndvZ96mE_normal.jpg"
		}
	}
}
```

<div id="direct_message_mark_read_events">
  #### direct&#95;message&#95;mark&#95;read&#95;events
</div>

```
{
	"for_user_id": "4337869213",
	"direct_message_mark_read_events": [{
		"created_timestamp": "1518452444662",
		"sender_id": "199566737",
		"target": {
			"recipient_id": "3001969357"
		},
		"last_read_event_id": "963085315333238788"
	}],
	"users": {
		"199566737": {
			"id": "199566737",
			"created_timestamp": "1286429788000",
			"name": "Le Braat",
			"screen_name": "LeBraat",
			"location": "Denver, CO",
			"description": "data by day @X, design by dusk",
			"protected": false,
			"verified": false,
			"followers_count": 299,
			"friends_count": 336,
			"statuses_count": 752,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/936652894371119105/YHEozVAg_normal.jpg"
		},
		"3001969357": {
			"id": "3001969357",
			"created_timestamp": "1422556069340",
			"name": "Jordan Brinks",
			"screen_name": "furiouscamper",
			"location": "Boulder, CO",
			"description": "Alter Ego - X PE opinions-are-my-own",
			"url": "https://t.co/SnxaA15ZuY",
			"protected": false,
			"verified": false,
			"followers_count": 23,
			"friends_count": 48,
			"statuses_count": 510,
			"profile_image_url": "null",
			"profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
		}
	}
}
```

<div id="tweet_delete_events">
  #### tweet&#95;delete&#95;events
</div>

```
{
    "for_user_id": "930524282358325248",
    "tweet_delete_events": [
{
        "status": {
            "id": "1045405559317569537",
            "user_id": "930524282358325248"
        },
        "timestamp_ms": "1432228155593"
    }
   ]
}
```

<div id="account-activity-replay-api">
  ## Account Activity Replay API
</div>

`Enterprise`

Account Activity Replay API는 최대 5일 전까지의 이벤트를 복구할 수 있는 데이터 복구 도구입니다. 이는 [webhook](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) 서버가 이벤트를 놓친 상황에서 데이터 복구를 위해 사용해야 합니다. 예를 들어 [retry window](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries)보다 더 긴 시간 동안 연결이 끊긴 경우나, 시스템을 정상 상태로 복구하는 데 며칠이 필요한 재해 복구 시나리오에서 사용할 수 있습니다.

Account Activity Replay API는 일정 기간 동안 [activities](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity)를 수집하지 못한 모든 시나리오를 위해 개발되었습니다. 이 API는 원래 활동을 실시간으로 전달하던 것과 동일한 webhook으로 activities를 전달합니다. 이 제품은 복구 도구이며 백필(backfill) 도구가 아니므로, 이전에 전달 시도가 있었던 이벤트만 재생됩니다. Account Activity Replay API는 구독이 생성되기 이전 기간의 이벤트를 전달할 수 없습니다.

<div id="using-account-activity-replay-api">
  ### Account Activity Replay API 사용
</div>

계정에 Replay 기능이 구성되어 있다면, Account Activity API에 요청을 보내는 방식과 유사한 방식으로 요청할 수 있습니다. 이때 요청에는 어떤 webhook의 activity를 재생(replay)할지 지정하기 위해 반드시 webhook id 파라미터를 포함해야 합니다. 다시 말해, Replay 요청은 Account Activity Replay API에 webhook id 및 application id를 기준으로, 지정한 시작 일시부터 종료 일시까지의 이벤트를 가져오도록 요청하는 것입니다.

시간은 UTC 기준이어야 합니다. 이러한 activity는 해당 id와 연결된 등록된 webhook을 통해 초당 최대 2,500개의 이벤트 속도로 전달됩니다. 또한 하나의 webhook당 동시에 실행될 수 있는 Replay 작업은 하나뿐이지만, 해당 webhook에 대해 지정된 날짜/시간 동안 활성 상태였던 모든 subscription은 재생된다는 점을 기억해 두시기 바랍니다.

이벤트는 지정된 기간 중 첫 번째(가장 오래된) 분부터 전달되기 시작하며, 가능한 한 시간 순서대로 진행되어 마지막 분이 전달될 때까지 계속됩니다. 그 시점에 Replay는 webhook으로 [작업 완료 이벤트](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#job-completed-successfully-message)를 전달합니다. 활동을 시간 순서대로 전달하기 때문에, 시작 시점 근처에 해당하는 이벤트가 거의 없거나 전혀 없는 경우, 첫 번째 결과가 전달되기 전까지 일정 시간 지연이 발생할 수 있습니다.

<div id="limitations">
  ### 제한 사항
</div>

Replay는 최대 5일 전까지의 활동을 쉽게 복구하기 위한 도구이지만, 구독이 생성되기 이전에 발생한 이벤트는 제공하지 않습니다. 예를 들어, 3일 전에 새 구독을 추가한 뒤 오늘을 기준으로 5일 전까지의 기간을 지정해 Replay 작업을 실행하더라도, 해당 새 구독이 활성 상태였던 3일 동안의 데이터만 받을 수 있습니다.

<div id="data-availability-and-types">
  ### 데이터 가용성 및 유형
</div>

Account Activity Replay API에서 제공하는 활동은 요청을 시작한 시점으로부터 5일 동안 사용할 수 있으며, 새 데이터는 해당 활동이 생성된 후 대략 10분 뒤에 사용 가능해집니다. 이 5일 이내의 기간에 대해 from&#95;date 및 to&#95;date 파라미터를 사용하여 요청에 시간 범위를 지정할 수 있습니다. Replay에 대한 액세스 권한이 부여되기 전에 원래 전달된 이벤트는 재생할 수 없습니다. 예를 들어, 2019년 6월 1일 UTC 기준 오후 3시 30분에 계정에 Account Activity Replay API 액세스 권한이 활성화되었다면, 그 이전 날짜와 시간의 이벤트는 Replay를 사용해 조회할 수 없습니다.

[Account Activity Replay API reference](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated)로 계속 진행하세요.

<div id="migration-introduction">
  ## 마이그레이션 소개
</div>

**Site Streams, User Streams, 그리고 Account Activity API - DM Only 표준 베타 버전 제품은 2018년에 사용이 중단되었습니다. 이러한 제품을 사용하고 있었다면 반드시 Account Activity API의 premium 또는 Enterprise 버전으로 마이그레이션해 주시기 바랍니다.**

**레거시 Direct Message 엔드포인트도 사용이 중단되었습니다. 이러한 엔드포인트를 사용하고 있었다면 반드시 새로운 DM 엔드포인트 또는 Account Activity API의 premium이나 Enterprise 버전으로 마이그레이션해 주시기 바랍니다. **

**자세한 내용은 [이 공지](https://devcommunity.x.com/t/details-and-what-to-expect-from-the-api-deprecations-this-week-on-august-16-2018/110746)를 확인해 주십시오.**

다음은 이 변경으로 영향을 받는 엔드포인트입니다:

* User Streams
* Site Streams
* GET direct&#95;messages
* GET direct&#95;messages/sent
* GET direct&#95;messages/show
* POST direct&#95;messages/new
* POST direct&#95;messages/destroy
   

유사한 방식의 액세스를 제공하고, Direct Message의 경우 일부 추가 기능도 제공하는 새로운 엔드포인트와 서비스가 제공되고 있습니다:

* Account Activity API [enterprise](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) 및 [premium](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index)
* [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events)
* [GET direct&#95;messages/events/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event)
* [POST direct&#95;messages/events/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event)
* [POST direct&#95;messages/events/destroy](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/delete-message-event)

이 새로운 엔드포인트와 서비스로 원활하게 마이그레이션할 수 있도록 두 개의 마이그레이션 가이드를 제공합니다:

* User Streams 및 Site Streams에서 새로운 웹훅 기반 서비스로 이전하는 사용자를 위한 [Account Activity API 마이그레이션 가이드](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#migration-guide-moving-from-user-streams-site-streams-to-account-activity-api)
* Direct Message REST 엔드포인트 간에 마이그레이션하는 사용자를 위한 [Direct Message 마이그레이션 가이드](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/guides/direct-message-migration)
   

또한, Account Activity API와 시작 방법을 설명하는 [동영상 시리즈](https://www.youtube.com/playlist?list=PLFKjcMIU2WshGG6Yj940XM7Z6BFs1zfBg)도 제공하고 있습니다.

마지막으로, 이해를 돕고 빠르게 시작할 수 있도록 코드 샘플도 제공합니다:

* [Account Activity Dashboard](https://github.com/xdevplatform/Account-Activity-dashboard)는 Account Activity API를 시작하는 데 도움이 되는 헬퍼 스크립트를 포함한 샘플 Node.js 웹 앱입니다.
* [SnowBot](https://github.com/xdevplatform/SnowBotDev)은 Account Activity API와 REST Direct Message 엔드포인트를 사용하는 샘플 챗봇입니다. Ruby로 작성되었으며, Sinatra 웹 앱 프레임워크를 사용하고 Heroku에 배포됩니다.

<div id="migration-guide-moving-from-user-streamssite-streams-to-account-activity-api">
  ## 마이그레이션 가이드: User Streams/Site Streams에서 Account Activity API로 이동하기
</div>

**2018년 8월 23일부로 Site Streams와 User Streams는 모두 서비스 종료되었습니다. 반드시 Account Activity API로 마이그레이션해 주시기 바랍니다.**

**자세한 내용은 [이 공지](https://devcommunity.x.com/t/details-and-what-to-expect-from-the-api-deprecations-this-week-on-august-16-2018/110746)를 참고해 주시기 바랍니다.**

이 가이드는 기존 User Streams 및 Site Streams API에서 이를 대체하는 Account Activity API로 마이그레이션하는 데 도움이 되도록 작성되었습니다. 아래에서 변경 사항 요약, 신규 기능 목록, 전환을 돕기 위한 주요 차이점 및 고려 사항을 확인할 수 있습니다. 기본 DM 엔드포인트에서의 마이그레이션에 대한 안내는 [Direct Message 마이그레이션 가이드](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/guides/direct-message-migration)를 참조하십시오.

<div id="summary-of-changes">
  ### 변경 사항 요약
</div>

Account Activity API는 User Streams 및 Site Streams와 같은 스트리밍 연결 대신 웹훅을 통해 인증 및 구독된 계정의 이벤트를 제공합니다.

<div id="deprecated-apis">
  #### 사용 중단된 API
</div>

GET user

GET site (컨트롤 스트림 포함: GET site/c/:stream&#95;id, GET site/c/:stream&#95;id/info.json, GET site/c/:stream&#95;id/friends/ids.json, POST site/c/:stream&#95;id/add&#95;user.json, POST /site/c/:stream&#95;id/remove&#95;user.json)

<div id="replacement-apis">
  #### 대체 API
</div>

[Enterprise Account Activity API - 전체 활동](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api)

### 차이점 및 마이그레이션 시 고려사항

**API 형식:** 새로운 Account Activity API는 User Streams 및 Site Streams와는 다르게 동작합니다. 웹훅을 통해 데이터를 수신할 수 있도록 웹 앱을 변경해야 합니다. 웹훅에 대한 자세한 정보는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks)에서 확인할 수 있습니다.

**사용 가능한 데이터:** 또 다른 주요 차이점은 전달되는 데이터 측면에서 확인할 수 있습니다. X는 더 이상 X에서 사용자가 팔로우하는 사람들(즉, 홈 타임라인)에 대한 이벤트를 전송하지 않습니다. 이는 의도적인 변경 사항이며, 앞으로도 바꿀 계획이 없습니다.

**신뢰성:** 스트리밍과 달리 웹훅은 전달 확인을 지원하며, 웹훅 URL에 도달하지 못한 POST된 활동을 재시도할 수 있는 옵션을 제공합니다. 이를 통해 짧은 시간의 연결 끊김이나 다운타임이 있더라도 앱이 관련된 모든 활동을 수신하고 있다는 점에 대해 더 높은 수준의 신뢰성을 확보할 수 있습니다.

<div id="new-features">
  ### 새로운 기능
</div>

Account Activity API는 여러 새로운 기능을 제공합니다. 가장 두드러진 변화는 스트리밍 방식이 아니라 웹훅(webhook)을 통해 데이터가 전달된다는 점입니다. 웹훅은 스트리밍과 비교했을 때 여러 이점이 있지만, 그중 가장 중요한 것은 속도와 안정성입니다. API는 데이터가 생성되는 즉시 JSON 이벤트 형식으로 전송하므로, 더 이상 활성 연결을 유지하거나 엔드포인트를 폴링할 필요가 없습니다. 이는 이중화 기능의 필요성을 줄이고 전반적인 효율성을 높여 줍니다. 웹훅에 대한 자세한 내용은 [기술 문서](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks)에서 확인할 수 있습니다.

<div id="managing-user-subscriptions">
  ### 사용자 구독 관리
</div>

Account Activity API는 하나의 등록된 webhook에 대해 여러 개의 구독을 허용합니다. 이렇게 하면 Site Streams 아키텍처와 유사하게, webhook을 통해 여러 사용자 구독의 활동을 동일한 위치로 전달할 수 있습니다. 이는 구독 한도와 관련하여 구독을 webhook 연결과는 독립적으로 추적할 수 있다는 의미입니다. 또한 단일 webhook에 대해 소수의 구독에서 시작해 수천 개의 구독까지 확장할 수 있도록 해줍니다.

<div id="how-to-migrate">
  ### **마이그레이션 방법**
</div>

<div id="follow-the-steps-below-to-easily-migrate-from-the-site-streams-api-to-the-account-activity-api">
  ### **Site Streams API에서 Account Activity API로 손쉽게 마이그레이션하려면 아래 단계를 따르세요**
</div>

**Step 1:  패키지 결정하기**

현재 User Streams 또는 Site Streams를 어떻게 운영하고 있는지에 따라 Account Activity API의 Enterprise 또는 Premium 버전으로 전환하는 것을 고려해야 합니다. 현재 지원 중인 애플리케이션 수와 승인된 사용자 수를 고려하여, 필요한 트래픽 규모와 안정성 수준에 맞게 확장해야 합니다. 어떤 패키지가 요구 사항에 가장 잘 맞는지 결정할 때 고려해야 할 사항은 다음과 같습니다:

* 필요한 웹훅 개수
* 애플리케이션에서 관리 중인 현재/예상 구독 수 및 승인된 사용자 수
* 현재 X 클라이언트 애플리케이션 수
* X로부터 원하는 지원 수준(포럼 지원 또는 관리형 Enterprise 1:1 지원)
* 각 패키지의 가격

**Step 2:** **developer portal에서 X 앱 설정 확인**

현재 User Streams 또는 Site Streams에 사용 중인 [X app](/ko/resources/fundamentals/developer-apps)은 [developer portal](/ko/resources/fundamentals/developer-portal) 내에서 소유 사용자 계정에 연결된 상태로 표시됩니다. 이 X 앱은 해당 애플리케이션의 승인된 사용자를 유지하기 위해 Account Activity API에서도 그대로 사용할 수 있습니다. 새 앱을 생성한 뒤 필요하다면 사용자가 이 새 앱을 다시 승인하도록 할 수도 있습니다. 기업을 대신해 새 앱을 만드는 경우, 기업용 X @handle 계정으로 앱을 생성하는 것을 권장합니다.

* X 앱 페이지의 [permissions](/ko/resources/fundamentals/developer-apps#app-permissions) 탭에서 “Read, Write and Access direct messages”를 활성화합니다.\
  *이 설정을 변경해도 소급 적용되지는 않으며, 이미 승인된 사용자는 승인 시점의 권한 설정을 그대로 유지합니다. 사용자가 아직 읽기, 쓰기 및 다이렉트 메시지 액세스를 허용하지 않았다면, 해당 사용자가 애플리케이션을 다시 승인하도록 해야 합니다.
* [X Sign-in](/ko/resources/fundamentals/authentication#log-in-with-x)과 X API에서 사용자 컨텍스트가 어떻게 동작하는지 잘 모른다면 [Obtaining Access Tokens](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks)를 검토하세요.
* “Keys and Tokens” 탭 하단에서 X 앱 소유자에 대한 액세스 토큰을 생성합니다. 같은 탭에서 Consumer Key, Consumer Secret, Access Token, Access Token Secret을 기록해 두세요. API를 사용할 때 필요합니다.
* [application-only](/ko/resources/fundamentals/authentication#bearer-token-also-known-as-app-only) API 메서드용으로 Consumer Key와 Consumer Secret을 사용해 bearer token을 생성합니다.

**Step 3: 웹훅 설정 및 구성**

* 이벤트를 수신할 웹훅으로 사용할 엔드포인트가 있는 웹 앱을 생성합니다(예: https://your&#95;domain.com/webhook/twitter 또는 https://webhooks.your&#95;domain.com).

* 웹훅을 생성할 때 Consumer Key, Consumer Secret, Access Token, Access Token Secret을 사용합니다. 이때 엔드포인트는 JSON 응답을 반환해야 하며, 응답에는 crc&#95;token과 앱 Consumer Secret으로 생성한 base64 인코딩 HMAC SHA-256 해시인 response&#95;token이 포함되어야 합니다.

* [Securing Webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks) 문서를 검토하고, 특히 Challenge Response Check(CRC) 요구 사항을 주의 깊게 확인합니다.

* 웹훅이 이벤트 수신용 POST 요청과 CRC용 GET 요청을 모두 지원하는지 확인합니다.

* 웹훅의 지연 시간이 낮도록 합니다(POST 요청에 대한 응답 시간 &lt;3초).

**Step 4: 웹훅 설정 검증**

* Webhook API는 다음 두 가지 방식으로 웹훅을 보호합니다:

               - 웹훅 소유자가 웹 앱 소유자인지 검증하기 위해 Challenge Response Check를 요구합니다.

               - 각 POST 요청에 시그니처 헤더를 포함해 웹 앱이 요청 소스를 검증할 수 있도록 합니다.

* X는 웹 앱과 웹훅 URL의 소유자가 모두 동일한지 확인하기 위해 CRC(Challenge Response Check)를 수행합니다. 이는 cyclic redundancy check와 혼동해서는 안 됩니다.
* crc&#95;token이라는 이름의 파라미터를 포함한 GET 요청이 웹훅 URL로 전송됩니다. 엔드포인트는 crc&#95;token과 앱 Consumer Secret으로 생성된 base64 인코딩 HMAC SHA-256 해시인 response&#95;token을 포함한 JSON 응답을 반환해야 합니다.
* crc&#95;token은 각 CRC 요청마다 변경된다고 예상해야 합니다. 계산 시 crc&#95;token은 메시지로 사용하고, Consumer Secret은 키로 사용해야 합니다.
* 응답이 유효하지 않은 경우, 등록된 웹훅으로 이벤트 전송이 중단됩니다.

**Step 5: 각 User Stream 또는 Site Streams 승인 사용자에 대한 구독 생성**

User Streams에서 Account Activity API로 전환:

* User Streams에서 현재 사용자 구독 목록을 조회합니다.
* 다음 요청을 사용해 새로운 Account Activity API 구독을 설정합니다:  *POST account&#95;activity/all/:env&#95;name/subscriptions*
* 다음 요청을 사용해 Account Activity API 구독을 확인합니다:  &#95;GET account&#95;activity/all/:env&#95;name/subscriptions/list
   &#95;

Site Streams에서 Account Activity API로 전환하기: (컨트롤 스트림 사용):

* 다음 요청을 사용해 Site Streams에서 현재 구독 목록을 조회합니다:  *GET /1.1/site/c/:stream&#95;id/info.json*
* 다음 요청을 사용해 새로운 Account Activity API 구독을 설정합니다:  *POST account&#95;activity/all/:env&#95;name/subscriptions*
* 다음 요청을 사용해 Account Activity API 구독을 확인합니다:  &#95;GET account&#95;activity/all/:env&#95;name/subscriptions/list
   &#95;

Webhook 등록 및 구독 생성 (Site Streams 또는 User Streams에서 마이그레이션하지 않는 경우)

* [POST webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api)를 사용하여 앱에 webhook URL을 등록하고 webhook&#95;id를 받습니다.
* 반환된 webhook&#95;id를 사용하여 [POST webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all)로 사용자 구독을 추가합니다.

<div id="the-account-activity-dashboard-sample-account-activity-api-application">
  ### Account Activity 대시보드(샘플 Account Activity API 애플리케이션)
</div>

Account Activity API를 더 빠르게 테스트할 수 있도록 샘플 앱을 준비해 두었습니다:   

* Account Activity 대시보드 샘플 애플리케이션을 [여기](https://github.com/xdevplatform/Account-Activity-dashboard)에서 다운로드합니다. (Node.js를 사용합니다)
* README의 지침에 따라 앱을 설치하고 실행합니다
* 애플리케이션이 실행되면 UI를 사용해 웹훅을 쉽게 설정하고 새 구독을 생성할 수 있습니다

<div id="available-activities">
  ### 사용 가능한 활동
</div>

| Message Type | 세부 정보 |
| :--- | :--- |
| [tweet&#95;create&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#tweet-create-events-posts-retweets-replies-quotetweets) | 구독 사용자가 게시물을 작성하거나, 리트윗, 답글, @멘션, 인용 트윗(QuoteTweet)을 하는 등, 아래 작업이 구독 사용자에 의해 또는 구독 사용자에게 발생할 때의 게시물 상태 페이로드입니다. |
| [favorite&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#favorite-events) | 사용자와 대상이 포함된 즐겨찾기(좋아요) 이벤트의 상태입니다. |
| [follow&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#follow-events) | 사용자와 대상이 포함된 팔로우 이벤트입니다. |
| [block&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#block-events) | 사용자와 대상이 포함된 차단 이벤트입니다. |
| [mute&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#mute-events) | 사용자와 대상이 포함된 뮤트 이벤트입니다. |
| [direct&#95;message&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-events) | 사용자와 대상이 포함된 다이렉트 메시지 상태입니다. |
| [direct&#95;message&#95;indicate&#95;typing&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-indicate-typing-events) | 사용자와 대상이 포함된 다이렉트 메시지 입력 중(indicate typing) 이벤트입니다. |
| [direct&#95;message&#95;mark&#95;read&#95;events](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#direct-message-mark-read-events) | 사용자와 대상이 포함된 다이렉트 메시지 읽음(mark read) 이벤트입니다. |

<div id="deprecated-streaming-message-types">
  ### 사용 중단된 스트리밍 메시지 유형
</div>

|     |     |
| :--- | :--- |
| 빈 줄 | 빈 줄은 User Streams 및 Site Streams에서 keep-alive 메시지로 사용되었기 때문에, Account Activity API에서는 더 이상 전달되지 않습니다. |
| 제한 알림 | 제한 알림은 더 이상 특정 webhook으로 전송되지 않습니다. 대신 사용자는 API를 호출하여 사용 가능한 핸들의 현재 사용량을 조회할 수 있습니다. 이는 향후 developer portal에도 표시될 예정입니다. |
| 연결 해제 메시지 | webhook은 활성 연결에 의존하지 않으므로, 연결 해제 알림은 더 이상 필요하지 않습니다. |
| 정체 경고 | webhook은 대량의 수신 메시지를 처리할 수 있는 활성 연결에 의존하지 않으므로, 정체 경고는 더 이상 필요하지 않습니다. |
| 친구 목록 | 친구 목록은 더 이상 사전 제공(proactive) 방식으로 전송되지 않습니다. 이제 이 정보를 조회하기 위한 REST endpoint가 제공됩니다. |

<div id="deprecated-event-types">
  ### 더 이상 사용되지 않는 이벤트 유형
</div>

|     |     |     |     |     |
| :--- | :--- | :--- | :--- | :--- |
| **설명** | **이벤트 이름** | **Source** | **Target** | **Target Object** |
| 사용자가 게시물을 삭제함 | delete | 현재 사용자 | 현재 사용자 | Post |
| 팔로우 중인 사용자가 게시물을 삭제함 | delete | 팔로우 중인 사용자 | 팔로우 중인 사용자 | Post |
| 사용자가 게시물에 대한 마음에 들어요를 취소함 | unfavorite | 현재 사용자 | 게시물 작성자 | Post |
| 사용자의 게시물에 대한 마음에 들어요가 취소됨 | unfavorite | 마음에 들어요를 취소한 사용자 | 현재 사용자 | Post |
| 사용자가 다른 사용자를 언팔로우함 | unfollow | 현재 사용자 | 팔로우하던 사용자 | Null |
| 사용자가 리스트를 생성함 | list&#95;created | 현재 사용자 | 현재 사용자 | List |
| 사용자가 리스트를 삭제함 | list&#95;destroyed | 현재 사용자 | 현재 사용자 | List |
| 사용자가 리스트를 수정함 | list&#95;updated | 현재 사용자 | 현재 사용자 | List |
| 사용자가 누군가를 리스트에 추가함 | list&#95;member&#95;added | 현재 사용자 | 추가된 사용자 | List |
| 사용자가 리스트에 추가됨 | list&#95;member&#95;added | 추가한 사용자 | 현재 사용자 | List |
| 사용자가 누군가를 리스트에서 제거함 | list&#95;member&#95;removed | 현재 사용자 | 제거된 사용자 | List |
| 사용자가 리스트에서 제거됨 | list&#95;member&#95;removed | 제거한 사용자 | 현재 사용자 | List |
| 사용자가 리스트를 구독함 | list&#95;user&#95;subscribed | 현재 사용자 | 리스트 소유자 | List |
| 사용자의 리스트가 구독됨 | list&#95;user&#95;subscribed | 구독한 사용자 | 현재 사용자 | List |
| 사용자가 리스트 구독을 취소함 | list&#95;user&#95;unsubscribed | 현재 사용자 | 리스트 소유자 | List |
| 사용자의 리스트 구독이 취소됨 | list&#95;user&#95;unsubscribed | 구독을 취소한 사용자 | 현재 사용자 | List |
| 사용자가 프로필을 업데이트함 | user&#95;update | 현재 사용자 | 현재 사용자 | Null |
| 사용자가 보호 상태를 업데이트함 | user&#95;update | 현재 사용자 | 현재 사용자 | Null |

<div id="direct-message-migration-guide">
  ## 다이렉트 메시지 마이그레이션 가이드
</div>

**2018년 9월 17일부로 레거시 다이렉트 메시지 엔드포인트는 지원이 종료되었습니다.
해당 엔드포인트를 사용 중이었다면, 새로운 다이렉트 메시지 엔드포인트 또는 Account Activity API로 반드시 마이그레이션해 주시기 바랍니다.**

**자세한 내용은 [이 공지](https://devcommunity.x.com//t/details-and-what-to-expect-from-the-api-deprecations-this-week-on-august-16-2018/110746)를 참고해 주세요.**

이 가이드는 레거시 다이렉트 메시지 REST API에서 베타 단계를 마치고 정식으로 제공되는 향상된 대체 API로 마이그레이션하는 데 도움을 드리기 위해 작성되었습니다. 아래에서 변경 사항 요약, 새로운 기능 목록, 전환 시 도움이 되는 주요 차이점과 고려 사항을 확인하실 수 있습니다. 새로운 다이렉트 메시지 엔드포인트는 현재 모든 개발자가 사용할 수 있습니다. User Streams 또는 Site Streams에서 마이그레이션하는 방법은 [Account Activity API 마이그레이션 가이드](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#migration-guide-moving-from-user-streams-site-streams-to-account-activity-api)를 참고하세요.

* [변경 사항 요약](#summary)
* [새로운 기능](#features)
* [다이렉트 메시지 보내기](#sending)
* [다이렉트 메시지 수신](#receiving)
* [다이렉트 메시지 삭제](#deleting)

<div id="summary-of-changes">
  ### 변경 사항 요약
</div>

아직 다음 DM 엔드포인트를 사용 중이라면, 새로운 엔드포인트로 마이그레이션해야 합니다. 

| 사용 중단된 엔드포인트 | 마이그레이션 대상 신규 엔드포인트 |
| :--- | :--- |
| [POST direct&#95;messages/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event) | [POST direct&#95;messages/events/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event) |
| [GET direct&#95;messages/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event) | [GET direct&#95;messages/events/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event) |
| [GET direct&#95;messages](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events) | [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events) |
| [GET direct&#95;messages/sent](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event) | [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events) |
| [POST direct&#95;messages/destroy](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/delete-message-event) | [DELETE direct&#95;messages/events/destroy](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/delete-message-event "GET direct_messages/events/list") |

<div id="new-features">
  ### 새로운 기능
</div>

새로운 Direct Message API 엔드포인트는 여러 가지 새로운 기능을 지원하며, 기존 Direct Message에 더 나은 접근을 제공합니다. 새로운 기능은 다음과 같습니다.

* 미디어 첨부(이미지, GIF, 비디오) 지원
* 미리 정의된 옵션 목록으로 사용자가 구조화된 응답을 하도록 요청하는 기능
* 최대 30일 전까지의 Direct Message에 접근할 수 있는 기능

새로운 Direct Message 기능 전체 목록과 추가 신규 API 엔드포인트에 대해서는 [기술 문서](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/overview)를 참조하세요.
 

<div id="differences-migration-considerations">
  ### 차이점 및 마이그레이션 시 고려 사항
</div>

새로운 API 엔드포인트는 이전 엔드포인트와 동작 방식이 크게 다릅니다. 단순히 엔드포인트 URL만 변경하면 애플리케이션에서 오류가 발생합니다. 마이그레이션을 위해 애플리케이션을 업데이트할 때는 다음 사항을 고려하십시오.

<div id="new-direct-message-object">
  #### 새로운 Direct Message 객체
</div>

가장 먼저 눈에 띌 점은 Direct Message의 새로운 객체 구조입니다. 이 새로운 Message Create 객체 구조는 [Quick Replies](https://developer.x.com/en/docs/x-api/v1/direct-messages/quick-replies/overview) 및 [Attachments](https://developer.x.com/en/docs/x-api/v1/direct-messages/message-attachments/overview)와 같은 새로운 기능을 지원하기 위해 도입되었습니다. 이 새 객체에는 더 작고 축약된 사용자 객체도 포함됩니다. 애플리케이션은 파싱 시뿐만 아니라 데이터 모델이나 저장소 측면에서도 이 새로운 객체 구조를 반영하도록 업데이트해야 합니다. 각 속성에 대한 설명은 [Message Create Object에 대한 전체 문서](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/guides/message-create-object)를 참조하십시오.

**Message Create 객체 예시**

```json
{
      "type": "message_create",
      "id": "1234858592",
      "created_timestamp": "1392078023603",
      "initiated_via": {
        "tweet_id": "123456",
        "welcome_message_id": "456789"
      },
      "message_create": {
        "target": {
          "recipient_id": "1234858592"
        },
        "sender_id": "3805104374",
        "source_app_id": "268278",
        "message_data": {
          "text": "Blue Bird",
          "entities": {
            "hashtags": [],
            "symbols": [],
            "urls": [],
            "user_mentions": [],
          },
          "quick_reply_response": {
            "type": "options",
            "metadata": "external_id_2"
          },
          "attachment": {
            "type": "media",
            "media": {
             ...
            }
          }
        }
      }
```

<div id="summary">
  #### 요약
</div>

* Direct Message 객체 구조 전면 개편.
* 사용자 객체 간소화.
* 새로운 정보 제공(빠른 답장 응답, 첨부 파일 등).

<div id="sending-direct-messages">
  ### 다이렉트 메시지 보내기
</div>

[POST direct&#95;messages/events/new](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/new-event)은 다이렉트 메시지를 보내기 위한 직접적인 대체 엔드포인트입니다. 이 엔드포인트의 가장 큰 차이점은, 모든 정보가 이제 개별 POST 파라미터가 아니라 POST 요청 본문에 JSON 형식으로 전송된다는 점입니다.

**Twurl 요청 예시**

```bash
twurl -A 'Content-type: application/json' -X POST /1.1/direct\_messages/events/new.json -d '{"event": {"type": "message\_create", "message\_create": {"target": {"recipient\_id": "4534871"}, "message_data": {"text": "Hello World!"}}}}'
```

위 요청에서 Content-Type이 application/x-www-form-urlencoded가 아니라 application/json으로 설정되어 있다는 점에 유의하십시오. 또한 OAuth 1.0a 서명을 생성하는 경우 JSON 요청 본문은 서명 생성에 포함되지 않는다는 점에 유의하십시오. 대부분의 OAuth 라이브러리는 이미 이를 고려하고 있습니다. [twurl](https://github.com/twitter/twurl)을 사용하는 경우 최소 0.9.3 버전을 사용하고 있는지 확인하십시오.

<div id="summary">
  #### 요약
</div>

* 메시지는 JSON POST 요청 본문에서 정의됩니다.
* Content-Type 헤더는 application/json으로 설정해야 합니다.
* JSON 본문은 OAuth 서명 생성에 포함되지 않습니다.
   

<div id="retrieving-direct-messages">
  ### 다이렉트 메시지 가져오기
</div>

기존 다이렉트 메시지 조회는 이제 단일 API 엔드포인트인 [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events)로 수행합니다. 이 새로운 엔드포인트의 중요한 차이점은 전송 및 수신 메시지 모두를 시간 내림차순(최신순)으로 반환한다는 점입니다. 이는 대화를 다시 구성하는 데 더 수월할 수 있습니다. 다만 전송 또는 수신된 메시지만 필요하다면 `sender_id` 속성을 참고하여 응답을 후처리해야 합니다.

페이지네이션은 이제 다이렉트 메시지 ID가 아니라 커서 값에 기반합니다. 각 응답에는 커서 속성이 함께 반환됩니다. [GET direct&#95;messages/events/list](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/list-events)는 과거 30일 이내의 메시지 개수와 관계없이 최대 30일 치의 과거 메시지를 반환합니다. 커서가 반환되지 않는 경우, 더 이상 반환할 메시지가 없다는 의미입니다. [GET direct&#95;messages/events/show](https://developer.x.com/en/docs/x-api/v1/direct-messages/sending-and-receiving/api-reference/get-event)를 사용하여 개별 다이렉트 메시지에 접근하는 방법은 동일하지만, 반환되는 다이렉트 메시지 객체의 구조는 앞에서 설명한 것처럼 변경되었습니다.

마지막으로, 다이렉트 메시지에 대한 실시간 액세스는 이제 [Account Activity API](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity)의 웹훅을 통해 이루어집니다. User Streams 또는 Site Streams에서 마이그레이션하는 방법에 대한 안내는 Account Activity API 마이그레이션 가이드를 참고하십시오.

<div id="summary">
  #### 요약
</div>

* 발신 및 수신 메시지가 이제 동일한 엔드포인트에서 반환됩니다.
* 최대 30일치 메시지를 반환합니다.
* 커서 기반 페이지네이션을 사용합니다.
* 웹훅을 통해 Direct Message에 실시간으로 액세스할 수 있습니다.

<div id="deleting-direct-messages">
  ### 다이렉트 메시지 삭제
</div>

이제 DELETE direct&#95;messages/events/destroy를 사용해 다이렉트 메시지를 삭제할 수 있습니다. 삭제할 메시지의 ID가 필요하다는 점 등 인터페이스는 대부분 동일합니다. 주요 차이점은 이제 이 엔드포인트가 POST 요청이 아니라 DELETE 요청을 요구한다는 것입니다.

삭제된 다이렉트 메시지가 공식 X 클라이언트에 반영되는 방식은 그대로입니다. 다이렉트 메시지는 지정된 사용자 컨텍스트의 인터페이스에서만 제거됩니다. 대화의 다른 참여자는 여전히 해당 다이렉트 메시지에 접근할 수 있습니다.

<div id="summary">
  #### 요약
</div>

* 다이렉트 메시지를 삭제하려면 ID가 필요합니다.
* 새 엔드포인트에서는 DELETE 요청을 사용해야 합니다.
* 삭제된 다이렉트 메시지가 공식 X 클라이언트에 반영되는 방식은 변경되지 않았습니다.

**새로운 Direct Message 엔드포인트로 마이그레이션하는 것에 대해 궁금한 점이 있으신가요?
**질문이 있다면 [devcommunity.com](https://devcommunity.x.com/)의 개발자 커뮤니티 포럼에 남겨 주세요.

<div id="frequently-asked-questions">
  ## 자주 묻는 질문
</div>

<div id="general">
  ### 일반
</div>

**Account Activity API를 사용하면 어떤 장점이 있나요?**

Account Activity API는 webhook을 사용합니다. 이는 스트리밍 API와 달리, 정보를 보내기 위해 항상 열린 연결을 유지할 필요가 없다는 의미입니다. 또한 webhook은 REST API와도 다릅니다. 원하는 데이터를 얻기 위해 15분마다 수백 번씩 요청을 보내서 끌어올 필요가 없습니다. 이 방식은 이벤트가 발생할 때 데이터를 바로 전달하므로, 사용자와 여러분의 앱 간의 효율성을 높여 줍니다.

Account Activity API에는 다음과 같은 장점이 있습니다:

1. **속도**: X의 속도로 데이터를 전달합니다.
2. **단순성**: 단일 webhook 연결을 통해 하나의 계정에서 발생하는 모든 이벤트를 전달합니다. API를 통해 전달되는 활동에는 게시물, @멘션, 답글, 리트윗, 인용 트윗, 인용 트윗의 리트윗, 좋아요, 발신 다이렉트 메시지, 수신 다이렉트 메시지, 팔로우, 차단, 뮤트가 포함됩니다. 
3. **확장성**: 이벤트 상한에 따른 어떤 요청 한도 제약도 없이, 여러분이 관리하는 계정의 모든 활동을 받을 수 있습니다.

Account Activity API는 프리미엄 샌드박스, 유료 프리미엄, Enterprise 상품으로 제공되며, 규정 준수 기능이나 추가 기능을 위해 더 많은 계정이 필요해질 때 요구 사항에 맞게 확장할 수 있습니다.

시작하려면 [GitHub](https://github.com/xdevplatform/account-activity-dashboard)에서 샘플 코드 스니펫을 다운로드하세요.
 

**어떤 제품 티어(tier)가 나에게 가장 적합한지 어떻게 알 수 있나요?**

Premium 옵션과 Enterprise 옵션 간의 차이에 대해 더 알아보려면 [Account Activity API 개요](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity) 페이지를 읽어 보세요. 
 

**Premium 환경과 Enterprise webhook의 차이는 무엇인가요?**

차이는 없습니다. 각 Premium 환경은 고유한 webhook&#95;id를 갖게 됩니다.
 

**Account Activity API용 개발, 스테이징, 프로덕션 환경이 필요합니다. 가능한가요?**

가능합니다! Account Activity API의 유료 등급(Paid Premium 및 Enterprise)에서는 여러 webhook URL을 등록하고, API 메서드를 통해 각 URL에 대한 구독을 개별적으로 관리할 수 있습니다. 추가로, 여러 클라이언트 앱을 allowlist에 추가하여 현재 인가된 사용자들에 대한 권한을 유지할 수 있습니다.
 

**Account Activity API 설정을 단계별로 안내하는 가이드가 있나요?**

있습니다!

* 처음 시작하는 경우, [webhook 시작하기](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks) 가이드를 살펴보는 것을 권장합니다.

* X Dev에서 지원하는 스크립트를 따라 해 보세요: 
  * [Account Activity API dashboard](https://github.com/xdevplatform/account-activity-dashboard): webhook 이벤트를 표시하는 Node 웹 앱입니다.
  * [SnowBot chatbot](https://github.com/xdevplatform/SnowBotDev): Account Activity API와 Direct Message API를 기반으로 구축된 Ruby 웹 앱입니다. 이 코드 베이스에는 Account Activity API webhook 설정을 도와주는 [스크립트](https://github.com/xdevplatform/SnowBotDev/wiki/Account-Activity-API-setup-script)가 포함되어 있습니다.
     

**시스템이 일정 시간 동안 다운되었을 때, 데이터를 복구할 수 있는 방법이 있나요?**

Account Activity API의 유료 등급(Paid Premium 및 Enterprise)에서는, 우리 시스템이 4시간 동안 여러 차례에 걸쳐 활동을 여러분에게 [재시도하여](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries) 전송합니다. 여러분의 시스템이 그 4시간 이내에 응답하지 않으면 해당 활동은 유실되며, 7일 이내의 데이터를 복구하려면 다른 REST endpoint를 사용해야 합니다.

하나의 시스템이 다운되더라도 활동을 놓치지 않도록, 서로 다른 webhook 또는 환경을 [Account Activity Replay API](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-replay-api)와 같은 중복 도구로 사용하는 것을 권장합니다.
 

**Account Activity API에는 어떤 인증 방식을 사용해야 하나요?**

Account Activity API에 필요한 인가 방식은 [API 레퍼런스 페이지](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#account-activity-api-reference-index)의 각 메서드별 설명에 나와 있습니다. X 인증을 처음 사용하는 경우, [이 섹션](/ko/resources/fundamentals/authentication)을 읽어 보실 것을 권장합니다.

**challenge-response check(CRC)란 무엇인가요?**

Account Activity API 챌린지 응답 검사는 Account Activity API의 활동이 올바른 개발자에게 전송되고 있는지 확인하기 위해 도입된 보안 기능입니다. 또한 개발자가 자신이 수신하는 데이터가 X로부터 온 것인지 확인하는 데 사용할 수도 있습니다. X는 웹훅 URL이 마지막으로 검증된 시점을 기준으로 24시간마다 한 번씩 자동으로 CRC를 웹훅 URL로 전송합니다. 시스템은 검증 상태를 유지하기 위해 3초 이내에 유효한 응답을 반환해야 합니다. 

자세한 내용은 [Securing webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#securing-webhooks) 페이지를 방문해 주세요.
 

**웹훅 URL이 즉시 무효화되는 경우가 있나요?**

다음 중 하나라도 발생하면, 웹훅은 즉시 무효로 표시됩니다.

* 서버가 CRC에 잘못된 토큰으로 응답한 경우. 이 경우, 시스템은 활동을 전송하기 위해 [재시도](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries)를 수행하지 않습니다.
* 웹훅 URL에 잘못된 인증서가 구성된 경우. 이 경우에도 시스템은 활동을 전송하기 위해 [재시도](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#retries)를 수행하지 않습니다.
* 서버가 2XX, 4XXX, 5XXX가 아닌 응답 코드를 반환하는 경우.
* gzip 사용을 지정했으나 실제로는 gzip으로 전송하지 않는 경우.
* gzip 사용을 지정하지 않았는데 실제 응답을 gzip으로 전송하는 경우.
   

**서로 상호작용하는 사용자들을 구독하면 중복된 활동을 받게 되나요?**

예. 웹 앱이 사용자 A와 사용자 B에 대해 활성 구독을 가지고 있고, 사용자 A가 게시물에서 사용자 B를 멘션하면, 등록된 웹훅으로 두 개의 POST 활동이 전송됩니다. 각 활동에는 해당 활동이 어떤 구독에 속하는지 나타내기 위해 &quot;for&#95;user&#95;id&quot; 표시가 포함됩니다.
 

**웹훅에 대한 구독을 생성할 때, 다음 엔드포인트의 `/all/` 부분을 다른 account activity 데이터 객체로 대체해서 API가 전달하는 활동을 제한할 수 있나요? **`POST https://api.x.com/1.1/account_activity/all/:env_name/subscriptions.json`

아니요, 이는 불가능합니다. 현재로서는 `/all/` 제품만 제공합니다.
 

**사용자로부터 Direct Messages 권한을 요청하지 않고 Account Activity API를 사용할 수 있는 방법이 있나요? **

현재로서는 이 API에서 Direct Messages 활동만 선택적으로 &#39;필터링&#39;하는 방법이 없기 때문에 Direct Messages 권한이 필요합니다. 
 

**Account Activity API의 무료 버전이 있나요?**

예, 무료 티어로 sandbox 버전을 제공합니다. sandbox 옵션은 단일 웹훅과 최대 15개의 구독으로 제한됩니다. sandbox 옵션에 대해 더 자세한 내용은 [문서](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity)를 참고하세요. 

**구독된 사용자를 멘션하는 게시물의 리트윗을 Account Activity API로 받을 수 있나요? **

안타깝게도, 이는 이 API에서 전달되는 활동에 포함되지 않습니다. 이 경우에는 Streaming API 사용을 권장합니다. 
 

**tweet&#95;create&#95;event가 표현할 수 있는 가능한 활동 유형은 무엇인가요?**

tweet&#95;create&#95;event 페이로드는 다음과 같은 경우 전송됩니다.

구독된 사용자가 다음 작업 중 하나를 수행하면:

* 게시물을 생성할 때
* 리트윗할 때
* 게시물에 답글을 달 때

다른 사용자가 다음을 수행하면:

* 구독 사용자를 @멘션*할 때
* 구독 사용자가 생성한 트윗을 인용할 때 

*참고: Account Activity API는 구독 사용자가 X에서 알림을 받고 해당 이벤트를 공개적으로 볼 수 있는 경우에만 이벤트를 전달합니다. 이는 멘션된 계정(@userA)이 보호된 계정(@userB)을 팔로우하고 있다면 UserA는 UserB가 자신을 멘션했다는 알림을 받는다는 의미입니다. UserA가 UserB를 팔로우(그리고 UserB의 승인을 받는 것)를 하지 않았다면 UserA는 알림을 받지 못하고, 따라서 @userA가 구독을 가지고 있더라도 tweet&#95;create&#95;event는 AAA를 통해 전송되지 않습니다.

**차단한 사용자가 내 구독 사용자에게 멘션을 보낸 경우, 이를 어떻게 식별할 수 있나요?**

JSON 응답의 최상위 수준에서 `user&#95;has&#95;blocked`라는 boolean 필드를 확인할 수 있으며, 이 값은 “true” 또는 “false&quot;로 설정됩니다. 이 필드는 게시물 멘션에 대해서만 노출됩니다. 

Enterprise

**내 앱을 allowlist에 추가하거나 이미 allowlist에 있는지 확인하려면 어떻게 해야 하나요?**

Enterprise API를 통한 액세스를 위해 허용 목록(allowlist)에 추가한 [X 앱](/ko/resources/fundamentals/developer-apps)을 관리하려면, 앱 ID와 함께 담당 계정 관리자에게 문의하십시오. 앱 ID는 [developer portal](/ko/resources/fundamentals/developer-portal)의 [&quot;Apps&quot;](/ko/resources/fundamentals/developer-apps) 페이지로 이동하여 확인할 수 있습니다.
 

**웹훅 3개에 대한 액세스 권한이 있는 경우, Enterprise 용도로 등록한 각 앱에서 웹훅 3개를 각각 사용할 수 있나요?**

웹훅 한도는 앱 수준이 아니라 계정 수준에서 설정됩니다. 웹훅 3개에 대한 액세스 권한이 있고 Enterprise 용도로 등록된 앱이 2개인 경우, 한 앱에서 웹훅 2개를 사용하고 다른 앱에서 나머지 1개를 사용할 수는 있지만, 각 앱에서 3개씩 사용할 수는 없습니다. 

**Account Activity Replay API를 사용할 때, 재전달될 이벤트 유형을 지정할 수 있나요?**

재생할 이벤트 유형은 지정할 수 없습니다. 지정한 날짜 및 시간 범위 동안 전달된 모든 이벤트가 재생됩니다. 

**내 애플리케이션이 Account Activity Replay API 이벤트 수집에 실패한 경우, 재시도가 이루어지나요?**

아니요, 재시도는 수행되지 않습니다. 애플리케이션이 Account Activity Replay API에서 전송된 이벤트를 수집하는 데 실패한 경우, 동일한 기간에 대해 다른 Replay 작업을 제출하여 누락된 Replay 이벤트의 재전달을 시도할 수 있습니다. 

**부분 성공(partial success) 완료 이벤트를 수신하면 무엇을 해야 하나요?**

수신한 이벤트의 타임스탬프를 기록해 두고, 누락된 이벤트에 대해 또 다른 Replay 작업을 요청하는 것을 권장합니다. 

**동시에 실행할 수 있는 Account Activity Replay API 작업은 몇 개까지인가요?**

웹훅당 동시에 실행할 수 있는 Account Activity Replay API 작업은 하나뿐입니다. 

**Account Activity Replay API 이벤트가 내 웹훅으로 전달될 때, 실시간 프로덕션 이벤트와 어떻게 구분할 수 있나요?**

Account Activity Replay API는 항상 과거의 이벤트만 전달하므로, 이벤트의 타임스탬프를 기준으로 실시간 프로덕션 이벤트와 구분할 수 있습니다. 

**내 애플리케이션이 누락하거나 드롭한 활동을 재전달하기 위해 Account Activity Replay API를 얼마나 빨리 사용할 수 있나요?**

활동은 생성된 후 약 10분이 지나면 재전달이 가능해집니다. 

<div id="error-troubleshooting-guide">
  ### 오류 해결 가이드
</div>

<div id="code-32">
  #### Code 32
</div>

이 오류는 일반적으로 요청, 헤더, 인증 정보 또는 지정한 URL 중 하나의 형식이 잘못되었음을 의미합니다. 이는 Account Activity API 오류가 아니라 인증 오류이며, X가 올바른 OAuth 설정이나 URL을 전달받지 못하고 있는 상황입니다.

* **Enterprise** - 사용 중인 consumer 키와 액세스 토큰이 Enterprise 제품 사용을 위해 등록된 [X app](/ko/resources/fundamentals/developer-apps)에 속해 있는지 확인하십시오. consumer 키와 액세스 토큰이 없거나 X app을 allowlist에 추가해야 하는 경우, 계정 담당자에게 문의하십시오. 

* 사용자 컨텍스트로 인증하는 경우, `oauth nonce`, `oauth_signature`, `oauth_timestamp`를 올바르게 포함하여 [요청을 적절히 인가](/ko/resources/fundamentals/authentication#authorizing-a-request)했는지 확인하십시오.

* 액세스 토큰에 올바른 권한 수준이 있는지 확인하십시오.
  * [앱 대시보드](/ko/resources/fundamentals/developer-apps)의 &quot;Keys and tokens&quot; 탭에서 액세스 토큰의 [permission level](/ko/resources/fundamentals/developer-apps#app-permissions)이 &quot;Read, write, and direct messages&quot;로 설정되어 있는지 확인하십시오. 
  * 토큰의 permission level이 이보다 낮게 설정되어 있다면 &quot;Permissions&quot; 탭으로 이동하여 액세스 권한을 &quot;Read, write, and direct messages&quot;로 변경한 후, &quot;Keys and tokens&quot; 탭에서 액세스 토큰과 시크릿 키를 다시 생성하십시오.

* URL이 올바르게 구성되어 있는지 확인하십시오.
  * `:env_name`은 대소문자를 구분한다는 점에 유의하십시오.
     

<div id="code-200-forbidden">
  #### Code 200 - Forbidden
</div>

* **Premium** - API에 요청을 보내기 전에 승인된 [개발자 계정](/ko/resources/fundamentals/developer-portal)이 있는지 확인하세요. 또한 요청에 올바른 :env&#95;name을 사용해야 하며, 이는 [dev environments](/ko/resources/fundamentals/developer-portal) 페이지에서 설정할 수 있습니다.

* **Enterprise** - 담당 계정 관리자가 Account Activity API에 대한 액세스 권한을 부여했는지 확인하세요.

* URI를 올바르게 설정했는지 확인하세요. 요청에 잘못된 URI를 입력하면 이 오류가 발생할 수 있습니다.
   

<div id="code-214-webhook-url-does-not-meet-the-requirements">
  #### 코드 214 - 웹훅 URL이 요구 사항을 충족하지 않습니다.
</div>

* HTTPS를 사용하고 있는지 확인하세요.
* 웹훅 URL 형식이 올바르지 않을 수 있습니다.
* 웹훅 URL을 설정하는 방법은 [Getting started with webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#getting-started-with-webhooks) 페이지의 [Develop webhook consumer app](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#3-develop-webhook-consumer-app) 섹션을 참조하세요.
   

<div id="code-214-high-latency-on-crc-get-request-your-webhook-should-respond-in-less-than-3-seconds">
  #### Code 214 - CRC GET 요청의 지연 시간이 너무 깁니다. 웹훅은 3초 이내에 응답해야 합니다.
</div>

* 이는 서버가 응답하는 데 시간이 너무 오래 걸린다는 의미입니다. CRC에 3초 이내에 응답하고 있는지 확인하세요.
   

<div id="code-214-non-200-response-code-during-crc-get-request-ie-404-500-etc">
  #### Code 214 - CRC GET 요청 중 200이 아닌 응답 코드가 반환됨(예: 404, 500 등).
</div>

* 서버가 다운된 상태입니다. 서버가 정상적으로 실행 중인지 확인하세요.
   

<div id="code-214-too-many-resources-already-created">
  #### 코드 214 - 이미 너무 많은 리소스가 생성되었습니다.
</div>

* **Enterprise** - 사용 가능한 웹훅을 모두 소진했습니다. 각 등록된 앱에 대해 [GET webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) 엔드포인트를 사용해 웹훅이 어디에 설정되어 있는지 확인하세요. 

<div id="code-261-application-cannot-perform-write-actions">
  #### 코드 261 - 애플리케이션이 쓰기 작업을 수행할 수 없습니다.
</div>

* API와 함께 사용 중인 앱의 액세스 토큰과 액세스 토큰 시크릿에 올바른 [permission level](/ko/resources/fundamentals/developer-apps#app-permissions)이 설정되어 있지 않습니다. [X apps](/ko/resources/fundamentals/developer-apps) 대시보드의 &#39;Keys and tokens&#39; 탭으로 이동하여 액세스 토큰과 액세스 토큰 시크릿에 할당된 permission level을 확인하세요. &#39;Read, write and Direct Messages&#39;가 아닌 다른 값으로 설정되어 있다면, &#39;Permission&#39; 탭에서 설정을 변경한 뒤 새 설정이 적용되도록 액세스 토큰과 액세스 토큰 시크릿을 다시 생성해야 합니다.
* 또는 지원되지 않는 app-only authentication을 사용하여 웹훅을 등록하려고 시도하고 있을 수 있습니다. [Enterprise Account Activity API](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks)의 웹훅 등록 관련 API reference 섹션에 명시된 대로, 대신 사용자 컨텍스트로 인증을 수행해야 합니다.

<div id="account-activity-api-reference-index">
  ## Account Activity API 레퍼런스 인덱스
</div>

|     |     |
| :--- | :--- |
| **용도** | Enterprise |
| webhook URL을 등록하거나 webhook&#95;id를 생성합니다 | [POST  <br />webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#enterprise-account-activity-api) |
| 모든 webhook URL과 해당 상태를 반환합니다 | [GET  <br />webhooks](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks) |
| 챌린지 응답 검사를 수동으로 실행합니다 | [PUT  <br />webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#put-account-activity-webhooks-webhook-id) |
| 애플리케이션을 계정의 이벤트에 구독합니다 | [POST  <br />webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#post-account-activity-webhooks-webhook-id-subscriptions-all) |
| 현재 활성 구독의 개수를 반환합니다 | [GET  <br />subscriptions/count](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |
| 특정 webhook이 계정에 대해 구독되어 있는지 확인합니다 | [GET  <br />webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-webhooks-webhook-id-subscriptions-all) |
| 현재 활성 구독 목록을 반환합니다 | [GET  <br />webhooks/:webhook&#95;id/subscriptions/all/list](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#get-account-activity-subscriptions-count) |
| webhook을 삭제합니다 | [DELETE  <br />webhooks/:webhook&#95;id](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id) |
| 3-legged OAuth를 사용해 구독을 비활성화합니다(사용 중단됨) | [DELETE  <br />webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) |
| application-only OAuth를 사용해 구독을 비활성화합니다 | [DELETE  <br />webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json) |
| 활동을 webhook으로 다시 전송합니다 | [POST  <br />replay/webhooks/:webhook&#95;id/subscriptions/all](/ko/x-api/enterprise-gnip-2.0/fundamentals/account-activity#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated) |

<div id="enterprise-account-activity-api">
  ### Enterprise Account Activity API
</div>

<div id="post-account_activitywebhooks">
  #### POST account&#95;activity/webhooks[](#post-account-activity-webhooks "Permalink to this headline")
</div>

주어진 애플리케이션 컨텍스트에 대해 새로운 webhook URL을 등록합니다. URL은 저장되기 전에 CRC 요청을 통해 검증됩니다. 검증에 실패한 경우 요청자에게 자세한 오류 메시지를 반환합니다.

허용되는 webhook의 개수는 요금제에 따라 결정됩니다.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks.json`

<div id="resource-information">
  ### Resource Information[](#resource-information "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 | 예 (user context - 모든 consumer 및 액세스 토큰) |
| 요청 한도 적용 여부 | 예 |
| 요청 수 / 15분 윈도우 (user auth) | 15  |
| 트윗 편집 지원 | 모든 트윗 객체에는 트윗의 편집 내역을 설명하는 트윗 편집 메타데이터가 포함됩니다. 자세한 내용은 [&quot;Tweet edits&quot; 기본 사항](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets) 페이지를 참조하세요. |

<div id="parameters">
  ### Parameters[](#parameters "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| url (required) | 콜백 엔드포인트용 인코딩된 URL입니다. |

### 예시 요청[](#example-request "이 제목의 퍼머링크")

$ curl --request POST
--url &#39;https://api.x.com/1.1/account&#95;activity/webhooks.json?url=https%3A%2F%2Fyour&#95;domain.com%2Fwebhooks%2Ftwitter%2F0&#39;
--header &#39;authorization: OAuth oauth&#95;consumer&#95;key=&quot;CONSUMER&#95;KEY&quot;, oauth&#95;nonce=&quot;GENERATED&quot;, oauth&#95;signature=&quot;GENERATED&quot;, oauth&#95;signature&#95;method=&quot;HMAC-SHA1&quot;, oauth&#95;timestamp=&quot;GENERATED&quot;, oauth&#95;token=&quot;ACCESS&#95;TOKEN&quot;, oauth&#95;version=&quot;1.0&quot;&#39;

<div id="http-responses">
  ### HTTP 응답[](#http-responses "Permalink to this headline")
</div>

| HTTP 코드 | 메시지 |
| :--- | :--- |
| 200 | Webhook URL이 제공된 앱에 등록되어 있습니다 |
| 403 | 요청에 오류가 있습니다. 아래 오류 메시지 섹션을 참조하세요. |

### 성공 예시 응답[](#example-response-success "Permalink to this headline")

```json
_HTTP 200_

    {
      "id": "1234567890",
      "url": "https://your_domain.com/webhook/twitter/0",
      "valid": true,
      "created_at": "2016-06-02T23:54:02Z"
    }
```

<div id="error-messages">
  ### 오류 메시지[](#error-messages "Permalink to this headline")
</div>

| Code | Message                                                             |
| :--- | :------------------------------------------------------------------ |
| 214  | Webhook URL이 요구사항을 충족하지 않습니다.                                       |
| 214  | 이미 생성된 리소스가 너무 많습니다.                                                |
| 214  | Webhook URL이 요구사항을 충족하지 않습니다. CRC 토큰이 잘못되었거나 JSON 응답 형식이 유효하지 않습니다. |
| 214  | CRC GET 요청의 지연 시간이 너무 깁니다. webhook은 3초 이내에 응답해야 합니다.                |
| 214  | CRC GET 요청 중 200이 아닌 응답 코드가 반환되었습니다(예: 404, 500 등).                 |

*HTTP 403*

```json
    {
      "errors": [
        {
          "code": 214,
          "message": "이미 너무 많은 리소스가 생성되었습니다."
        }
      ]
    }
```

<div id="get-account_activitywebhooks">
  #### GET account&#95;activity/webhooks[](#get-account-activity-webhooks "이 헤드라인의 퍼마링크")
</div>

지정된 앱에 대해 모든 URL과 해당 상태를 반환합니다.

URL이 일일 유효성 검사에서 실패하면 해당 URL을 무효로 표시합니다. URL을 다시 활성화하려면 update 엔드포인트를 호출하세요.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks.json`

### 리소스 정보[](#resource-information "Permalink to this headline")

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 | 예 (앱 전용 - Bearer Token) |
| 요청 제한 | 예 |
| 15분당 요청 수 (앱 인증) | 15  |

<div id="example-request">
  ### 요청 예시[](#example-request "Permalink to this headline")
</div>

```bash
    $ curl --request GET
     --url https://api.x.com/1.1/account_activity/webhooks.json
     --header 'authorization: Bearer TOKEN'
```

<div id="example-response">
  ### 예시 응답[](#example-response "Permalink to this headline")
</div>

*HTTP 200 OK*

```json
    [
      {
        "id": "1234567890",
        "url": "https://your_domain.com/webhook/twitter/0",
        "valid": true,
        "created_at": "2016-06-02T23:54:02Z"
      }
      {
        "id": "2468013579",
        "url": "https://your_domain2.com/webhook/twitter/0",
        "valid": true,
        "created_at": "2016-06-04T22:31:29Z"
      }
    ]
```

<div id="error-messages">
  ### 오류 메시지[](#error-messages "Permalink to this headline")
</div>

| Code | Message |
| :--- | :--- |
| 99  | 이 리소스에 접근할 수 있는 권한이 없습니다. |

<div id="put-account_activitywebhookswebhook_id">
  #### PUT account&#95;activity/webhooks/:webhook&#95;id[](#put-account-activity-webhooks-webhook-id "Permalink to this headline")
</div>

지정된 webhook의 URL에 대해 challenge-response 검사(CRC)를 트리거합니다. 검사가 성공하면 204를 반환하고, 상태를 `valid`로 설정하여 webhook을 다시 활성화합니다.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id.json`

### 리소스 정보[](#resource-information "Permalink to this headline")

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 여부 | 예 (사용자 컨텍스트 - 모든 consumer 토큰 및 액세스 토큰) |
| 요청 한도 적용 여부 | 예 |
| 15분당 요청 수(사용자 인증) | 15  |

<div id="parameters">
  ### Parameters[](#parameters "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | Webhook ID. 리소스 경로에 정의됩니다. |

### 예제 요청[](#example-request "Permalink to this headline")

```json
    $ curl --request PUT
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID.json
     --header 'authorization: OAuth oauth_consumer_key="CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="ACCESS_TOKEN", oauth_version="1.0"'
```

<div id="response">
  ### 응답[](#response "Permalink to this headline")
</div>

*HTTP 204 OK*

```
    { }
```

### 오류 메시지[](#error-messages "이 제목에 대한 고유 링크")

| 코드 | 메시지 |
| :--- | :--- |
| 34  | 웹훅이 존재하지 않거나 다른 X 앱에 연결되어 있습니다. |
| 214 | 웹훅 URL이 요구 사항을 충족하지 않습니다. |
| 214 | 웹훅 URL이 요구 사항을 충족하지 않습니다. CRC 토큰이 잘못되었거나 JSON 응답 형식이 올바르지 않습니다. |
| 214 | CRC GET 요청의 지연 시간이 큽니다. 웹훅은 3초 이내에 응답해야 합니다. |
| 214 | CRC GET 요청 중 200이 아닌 응답 코드(예: 404, 500 등)를 반환했습니다. |

<div id="post-account_activitywebhookswebhook_idsubscriptionsall">
  #### POST account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all[](#post-account-activity-webhooks-webhook-id-subscriptions-all "Permalink to this headline")
</div>

지정된 사용자 컨텍스트에 대해 모든 메시지 유형의 모든 이벤트를 지정된 앱이 수신하도록 구독을 생성합니다. 활성화되면 요청한 사용자에 대한 모든 이벤트가 POST 요청을 통해 앱의 webhook 엔드포인트로 전송됩니다.

현재 구독 수는 계정 구성에 따라 제한됩니다. 더 많은 구독이 필요하면 계정 담당자에게 문의하세요.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all.json`

### 리소스 정보[](#resource-information "Permalink to this headline")

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 | 예 (3-legged OAuth - 화이트리스트에 등록된 consumer key와 구독 중인 사용자의 액세스 토큰) |
| 요청 한도 적용 여부 | 예 |
| 요청 수 / 15분(사용자 인증) | 500 |

<div id="parameters">
  ### Parameters[](#parameters "Permalink to this headline")
</div>

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | 리소스 경로에 정의된 Webhook ID입니다. |

<div id="example-request">
  ### 요청 예시[](#example-request "Permalink to this headline")
</div>

```bash
    $ curl --request POST
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all.json
     --header 'authorization: OAuth oauth_consumer_key="WHITELISTED_CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="SUBSCRIBING_USER'S_ACCESS_TOKEN", oauth_version="1.0"'
```

<div id="example-response-success">
  ### 성공 시 예시 응답[](#example-response-success "Permalink to this headline")
</div>

*HTTP 204 NO CONTENT*

```
    {}
```

<div id="error-messages">
  ### 오류 메시지[](#error-messages "Permalink to this headline")
</div>

| 코드 | 메시지 |
| :--- | :--- |
| 34  | 웹훅이 존재하지 않거나 다른 X 앱에 연결되어 있습니다. |
| 348 | 클라이언트 앱은 이 사용자의 웹훅 구독에 액세스할 수 있는 권한이 없습니다. |

<div id="get-account_activitysubscriptionscount">
  #### GET account&#95;activity/subscriptions/count[](#get-account-activity-subscriptions-count "이 제목의 퍼머링크")
</div>

현재 계정에서 활성화되어 있는 구독(subscription)의 개수를 반환합니다. `/count` endpoint에는 앱 전용 OAuth가 필요하므로, 사용자 컨텍스트 대신 Bearer Token을 사용해 요청해야 합니다.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/subscriptions/count.json`

### 리소스 정보[](#resource-information "Permalink to this headline")

|     |     |
| :--- | :--- |
| 응답 형식 | HTTP response code |
| 인증 필요 | 예 (앱 전용 - Bearer Token) |
| 레이트 제한 | 예 |
| 요청 수 / 15분 단위(앱 인증) | 15  |

<div id="http-response-codes">
  ### HTTP 응답 코드[](#http-response-codes "이 제목에 대한 퍼머링크")
</div>

|     |     |
| :--- | :--- |
| Code | Message |
| 200 | 성공. 요청된 webhook에 대한 구독 수가 반환됩니다. |
| 401 | 지정된 webhook의 구독을 조회할 수 있는 권한이 앱에 없습니다. |

<div id="example-request">
  ### 요청 예시[](#example-request "Permalink to this headline")
</div>

```bash
    $ curl --request GET
     --url https://api.x.com/1.1/account_activity/subscriptions/count.json
     --header 'authorization: Bearer TOKEN'
```

### 예시 응답 - 성공[](#example-response-success "Permalink to this headline")

*HTTP 200*

```bash
    {
      "account_name":"my-account",
      "subscriptions_count_all":"1",
      "subscriptions_count_direct_messages":"0",
      "provisioned_count":"50"
    }
```

<div id="error-messages">
  ### 오류 메시지[](#error-messages "Permalink to this headline")
</div>

| 코드 | 메시지         |
| :- | :---------- |
| 32 | 인증에 실패했습니다. |

*HTTP 401*

```abash
    {
      "errors": [
        {
           "code": 32,
          "message": "Could not authenticate you."
        }
      ]
    }
```

<div id="get-account_activitywebhookswebhook_idsubscriptionsall">
  #### GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all[](#get-account-activity-webhooks-webhook-id-subscriptions-all "Permalink to this headline")
</div>

지정한 사용자의 이벤트에 대해 웹훅 구성이 구독되어 있는지 확인할 수 있습니다. 지정한 사용자 컨텍스트가 지정한 애플리케이션과 활성 구독 관계인 경우 204 OK를 반환합니다. 응답 코드가 204가 아니면 해당 사용자는 활성 구독이 없습니다. 자세한 내용은 아래의 HTTP 응답 코드 및 오류 메시지를 참조하세요.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all.json`

### 리소스 정보[](#resource-information "이 헤드라인에 대한 퍼마링크")

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 | 예 (3-legged OAuth - 화이트리스트에 포함된 consumer key 및 구독 중인 사용자의 액세스 토큰) |
| 요청 제한 | 예 |
| 요청 수 / 15분(사용자 인증) | 500 |

### 매개변수[](#parameters "이 제목에 대한 퍼머링크")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | Webhook ID. 리소스 경로에 정의됩니다. |

### 요청 예시[](#example-request "이 제목에 대한 영구 링크")

$ curl --request GET
--url https://api.x.com/1.1/account&#95;activity/webhooks/:WEBHOOK&#95;ID/subscriptions/all.json
--header &#39;authorization: OAuth oauth&#95;consumer&#95;key=&quot;WHITELISTED&#95;CONSUMER&#95;KEY&quot;, oauth&#95;nonce=&quot;GENERATED&quot;, oauth&#95;signature=&quot;GENERATED&quot;, oauth&#95;signature&#95;method=&quot;HMAC-SHA1&quot;, oauth&#95;timestamp=&quot;GENERATED&quot;, oauth&#95;token=&quot;SUBSCRIBING&#95;USER&#39;S&#95;ACCESS&#95;TOKEN&quot;, oauth&#95;version=&quot;1.0&quot;&#39;

### 예시 응답 - 성공[](#example-response-success "Permalink to this headline")

*HTTP 204 NO CONTENT*

```
    { }
```

<div id="get-account_activitywebhookswebhook_idsubscriptionsalllist">
  #### GET account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list[](#get-account-activity-webhooks-webhook-id-subscriptions-all-list "Permalink to this headline")
</div>

지정된 webhook에 대해 현재 All Activity 유형의 구독 목록을 반환합니다. /list 엔드포인트는 애플리케이션 전용 OAuth 인증이 필요하므로, 요청은 사용자 컨텍스트 대신 Bearer Token을 사용하여 보내야 합니다.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all/list.json`

### 리소스 정보[](#resource-information "Permalink to this headline")

|     |     |
| :--- | :--- |
| 응답 형식 | HTTP 응답 코드 |
| 인증 필요 | 예 (앱 전용 - Bearer Token) |
| 요청 한도 적용 | 예 |
| 15분 시간 창당 요청 수 (앱 인증) | 50  |

### 매개변수[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | Webhook ID로, 리소스 경로에서 정의됩니다. |

### HTTP 응답 코드[](#http-response-codes "이 제목에 대한 고유 링크")

| 코드 | 메시지 |
| :--- | :--- |
| 200 | 성공. 요청한 webhook에 대한 구독 목록이 반환됩니다. |
| 401 | 앱이 해당 webhook의 구독을 조회할 수 있는 권한이 없습니다. |

### 예시 요청[](#example-request "이 제목의 퍼머링크")

$ curl --request GET
--url https://api.x.com/1.1/account&#95;activity/webhooks/:WEBHOOK&#95;ID/subscriptions/all/list.json
--header &#39;authorization: Bearer TOKEN&#39;

### 예시 응답 - 성공[](#example-response-success "Permalink to this headline")

*HTTP 200*

```bash
    {
      "webhook_id": "1234567890",
      "webhook_url": "https://your_domain.com/webhook/twitter/0",
      "application_id": "11231812",
      "subscriptions": [{
        "user_id": "20212306"
      }]
    }
```

<div id="error-messages">
  ### 오류 메시지[](#error-messages "Permalink to this headline")
</div>

| Code | Message     |
| :--- | :---------- |
| 32   | 인증에 실패했습니다. |

*HTTP 401*

```bash
    {
      "errors": [
        {
           "code": 32,
          "message": "Could not authenticate you."
        }
      ]
    }
```

<div id="delete-account_activitywebhookswebhook_id">
  #### DELETE account&#95;activity/webhooks/:webhook&#95;id[](#delete-account-activity-webhooks-webhook-id "Permalink to this headline")
</div>

제공된 앱의 구성에서 webhook을 제거합니다. webhook ID는 GET /1.1/account&#95;activity/webhooks 엔드포인트를 호출하여 확인할 수 있습니다.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id.json`

### 리소스 정보[](#resource-information "이 제목에 대한 고유 링크")

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 | 예 (사용자 컨텍스트 - 모든 consumer 및 액세스 토큰) |
| 요청 한도 적용 | 예 |
| 요청 수 / 15분 단위 (사용자 인증) | 15  |

### 매개변수[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | Webhook ID입니다. 리소스 경로에서 정의됩니다. |

<div id="example-request">
  ### 요청 예시[](#example-request "Permalink to this headline")
</div>

```bash
    $ curl --request DELETE
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID.json
     --header 'authorization: OAuth oauth_consumer_key="CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="ACCESS_TOKEN", oauth_version="1.0"'
```

### 응답[](#response "이 제목으로 연결되는 고유 링크")

*HTTP 204 OK*

```
    { }
```

<div id="delete-account_activitywebhookswebhook_idsubscriptionsall-deprecated">
  #### DELETE account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all (사용 중단됨)[](#delete-account-activity-webhooks-webhook-id-subscriptions-all-deprecated- "Permalink to this headline")
</div>

제공된 사용자 컨텍스트와 애플리케이션에 대한 구독을 비활성화합니다. 비활성화 후에는 요청한 사용자의 모든 이벤트가 더 이상 webhook URL로 전송되지 않습니다.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/all.json`

### 리소스 정보[](#resource-information "Permalink to this headline")

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 | 예 (3-legged OAuth - 화이트리스트에 등록된 consumer key 및 구독한 사용자의 액세스 토큰) |
| 요청 한도 적용 | 예 |
| 요청 수 / 15분(사용자 인증) | 500 |

### 매개변수[](#parameters "Permalink to this headline")

|     |     |
| :--- | :--- |
| webhook&#95;id (required) | 리소스 경로에 정의된 Webhook ID입니다. |

<div id="example-request">
  ### 요청 예시[](#example-request "Permalink to this headline")
</div>

```bash
    $ curl --request DELETE
     --url https://api.x.com/1.1/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all.json
     --header 'authorization: OAuth oauth_consumer_key="WHITELISTED_CONSUMER_KEY", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="SUBSCRIBED_USER'S_ACCESS_TOKEN", oauth_version="1.0"'
```

요청 예시

```
    { }
```

<div id="delete-account_activitywebhookswebhook_idsubscriptionsuser_idalljson">
  #### DELETE /account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all.json[](#delete-account-activity-webhooks-webhook-id-subscriptions-user-id-all-json "Permalink to this headline")
</div>

지정된 webhook 및 사용자 id에 대한 구독을 비활성화합니다. 비활성화 후에는 요청하는 사용자에 대한 모든 이벤트가 더 이상 webhook URL로 전송되지 않습니다. 이 엔드포인트에는 애플리케이션 전용 OAuth가 필요하므로, 요청은 사용자 컨텍스트 대신 Bearer Token을 사용해 보내야 합니다.

<div id="resource-url">
  ### 리소스 URL[](#resource-url "Permalink to this headline")
</div>

`https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/:user_id/all.json`

### 리소스 정보[](#resource-information "Permalink to this headline")

|     |     |
| :--- | :--- |
| 응답 형식 | JSON |
| 인증 필요 | 예 (앱 전용 - Bearer Token) |
| 요청 한도 적용 | 예 |
| 15분당 요청 한도 | 500 |

### 예시 요청[](#example-request "Permalink to this headline")

```bash
    $ curl --request DELETE
     --url https://api.x.com/1.1/account_activity/webhooks/:webhook_id/subscriptions/:user_id/all.json
     --header 'authorization: Bearer TOKEN'
```

### 응답[](#response "이 제목에 대한 고유 링크")

*HTTP 204 NO CONTENT*

<div id="error-messages">
  ### 오류 메시지[](#error-messages "Permalink to this headline")
</div>

| 코드 | 메시지 |
| :--- | :--- |
| 404 | 죄송합니다. 해당 페이지는 존재하지 않습니다. - 지정한 사용자 id가 실제로 구독된 상태가 아닐 때 자주 발생합니다. |

<div id="replay-api">
  ### Replay API
</div>

**POST /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json [¶](#post-1-1-account-activity-replay-webhooks-webhook-id-subscriptions-all-json- "Permalink to this headline")**

요청에 지정된 날짜 및 시간 구간 동안 존재했던 모든 구독으로부터, 최대 지난 5일치 활동을 조회하도록 요청합니다. 웹후크에 활성 사용자 구독이 있는 경우, 해당 이벤트도 동시에 수신하게 됩니다. 참고: 리플레이 이벤트를 전달하기 전에 CRC를 수행합니다.

|     |     |
| :--- | :--- |
| **Request Method** | HTTP POST |
| **URL** | /1.1/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all.json?from&#95;date=yyyymmddhhmm&amp;to&#95;date=yyyymmddhhmm |
| **Response Format** | JSON |
| **Requires Authentication** | 예 (애플리케이션 전용 - Bearer Token) |
| **Rate Limit** | 15분당 5회 요청. 현재 요청할 수 있는 리플레이 작업 수에는 최대값이 없습니다. |
| **from&#95;date** | 이벤트가 제공될 가장 오래된(시작) UTC 타임스탬프이며, &#39;yyyymmddhhmm&#39; 형식이어야 합니다. 타임스탬프는 분 단위 정밀도를 가지며, 포함 범위입니다(예: 12:00은 00분을 포함). 유효한 시간은 최근 5일 이내여야 하고, UTC 기준이며, 현재 시점으로부터 최소 31분 이전이어야 합니다. from&#95;date와 to&#95;date는 약 2시간 이내 범위가 되도록 설정할 것을 권장합니다. |
| **to&#95;date** | 이벤트가 제공될 가장 최신(종료) UTC 타임스탬프이며, &#39;yyyymmddhhmm&#39; 형식이어야 합니다. 타임스탬프는 분 단위 정밀도를 가지며, 제외 범위입니다(예: 12:30은 해당 시각의 30분을 포함하지 않음). 유효한 시간은 최근 5일 이내여야 하고, UTC 기준이며, 현재 시점으로부터 최소 10분 이전이어야 합니다. |

<div id="responses">
  #### 응답
</div>

다음 응답은 API에서 반환될 수 있습니다. 대부분의 오류 코드는 본문에 추가 세부 정보가 포함된 문자열과 함께 반환됩니다. 200이 아닌 상태 코드의 응답인 경우, 오류를 해결한 후 다시 시도해야 합니다.

| Status | Text | Error Code | Description | Message |
| :--- | :--- | :--- | :--- | :--- |
| 202 | Accepted | N/A | 요청이 성공적으로 처리되었으며 activity 데이터가 전송됩니다. | N/A |
| 400 | Bad Request | 214 | Webhook이 유효하지 않은 것으로 표시되었습니다. | Webhook is marked invalid and requires a CRC check. |
| 400 | Bad Request | 357 | 쿼리 매개변수가 누락되었습니다. | : queryParam is required. |
| 400 | Bad Request | 358 | 라우트 또는 쿼리 매개변수의 형식이 올바르지 않습니다. | Unable to parse parameter. |
| 400 | Bad Request | 360 | 라우트 매개변수가 음수입니다. | webhook&#95;id: [] is not greater than or equal to 0. |
| 400 | Bad Request | 368 | from&#95;date 또는 to&#95;date가 과거 시간이 아닙니다. | : [&lt;field&#95;value&gt;] is not in the past. |
| 400 | Bad Request | 356 | from&#95;date는 to&#95;date보다 이전이어야 합니다. | from&#95;date must be before to&#95;date. |
| 400 | Bad Request | 356 | from&#95;date는 과거 5일 이내여야 합니다. | from&#95;date must be within the past 5 days. |
| 401 | Unauthorized | 32  | 3-legged 인증이 사용되어 HTTP 인증에 실패했습니다. | Invalid authentication method. Please use application-only authentication. |
| 401 | Unauthorized | 61  | Client가 이 메서드를 요청할 권한이 없습니다. | Client is not permitted to request this method. |
| 403 | Forbidden | 200 | Client에 Replay가 활성화된 Enterprise 계정이 없습니다. | Account Activity API enterprise account with replay is required. Please confirm you have an enterprise account and replay is enabled. |
| 404 | Not Found | 34  | webhook&#95;id가 존재하지 않거나 webhook&#95;id와 application&#95;id가 일치하지 않습니다. | Webhook does not exist or is associated with a different X application. |
| 409 | Conflict | 355 | 현재 처리 중인 요청이 있으며, 다른 요청을 보내기 전에 처리가 완료되어야 합니다. | A replay job is already in progress for this webhook. |
| 429 | Too Many Requests | 88  | 요청 개수 한도(지정된 기간당 허용된 요청 수)를 초과했습니다. | Too many requests. Please back off your API request rate. |
| 500 | Internal Server Error | 0   | 내부 서버 오류입니다. | Internal server error. |
| 503 | Service Unavailable | 67  | X의 하나 이상의 종속 서비스를 사용할 수 없습니다. | X server error. Retry using an exponential backoff pattern. |

<div id="job-completed-successfully-message">
  #### &quot;Job completed successfully” message
</div>

작업이 성공적으로 완료되면 Account Activity Replay API가 다음과 같은 작업 완료 이벤트를 전송합니다. 이 이벤트를 수신하면 해당 작업이 완료된 것이며, 다른 작업을 제출할 수 있습니다.

```json
{
  "replay\_job\_status": {
    "webhook_id": "1234577122340233217",
    "job_state": "Complete",
    "job\_state\_description": "작업이 성공적으로 완료되었습니다"
    "job_id": "1095098195724558337"
  }
}
```

<div id="job-failed-to-complete-message">
  #### &quot;Job failed to complete&quot; 메시지
</div>

작업이 성공적으로 완료되지 않은 경우, Replay 작업을 다시 시도하라는 안내와 함께 다음 메시지가 반환됩니다. 이 이벤트를 수신했다면 해당 작업은 실행이 완료된 상태이며, 새 작업을 제출할 수 있습니다.

```json
{
  "replay\_job\_status": {
    "webhook_id": "123451374207332352",
    "job_state": "Incomplete",
    "job\_state\_description": "모든 이벤트 전달에 실패했습니다. 재생 작업을 다시 시도해 주세요",
    "job_id": "1093226942650736640"
  }
}
```

<div id="example-curl-request">
  #### 예시 cURL 요청
</div>

```bash
    curl --request POST  --url 'https://api.x.com/1.1/account_activity/replay/webhooks/:webhook_id/subscriptions/all.json?from_date=yyyymmddhhmm&to_date=yyyymmddhhmm'
    --header 'authorization: Bearer TOKEN'
```

#### 예시 응답

HTTP 202

```bash
{
  "job_id": "1234567890",
  "created_at": "2016-06-02T23:54:02Z"
}
```
