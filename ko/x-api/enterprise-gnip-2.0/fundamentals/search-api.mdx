---
title: "검색 API: Enterprise"
sidebarTitle: Search API
keywords: ["Enterprise 검색", "GNIP 검색", "Enterprise 검색 API", "검색 API Enterprise", "Enterprise 검색 엔드포인트"]
---

> **참고:**
>
> [게시물 검색](/ko/x-api/posts/search/introduction)과 [게시물 개수](/ko/x-api/posts/counts/introduction)의 새로운 버전이 [X API v2](/ko/x-api/getting-started/about-x-api)로 제공됩니다. X API v2의 [새로운 사항](/ko/x-api/migrate/overview)을 확인해 보시기 바랍니다. 
>
> 이 엔드포인트는 게시물 편집 메타데이터를 포함하도록 업데이트되었습니다. 이러한 메타데이터에 대해 더 알아보려면 [&quot;게시물 수정&quot; 기본 사항 페이지](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets)를 참조하세요. 

<div id="overview">
  ## Overview
</div>

`Enterprise`

*Enterprise API는 관리형 액세스 레벨에서만 사용할 수 있습니다. 이 API를 사용하려면 먼저 Enterprise 영업 팀을 통해 계정을 설정해야 합니다. 자세한 내용은 [여기](https://developer.x.com/en/products/x-api/enterprise)를 참조하세요.*

*모든 X API 검색 게시물 제공 항목은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api)에서 확인할 수 있습니다.*

Enterprise 검색 API에는 두 가지 유형이 있습니다:

1. 30-Day Search API는 최근 30일 동안의 데이터를 제공합니다.
2. Full-Archive Search API는 2006년 3월 첫 번째 게시물까지 거슬러 올라가는 전체 X 데이터 코퍼스에 대해 완전하고 즉각적인 액세스를 제공합니다.

이 RESTful API들은 요청당 최대 2,048자까지 단일 쿼리를 지원합니다. 쿼리는 PowerTrack 규칙 구문으로 작성됩니다. 자세한 내용은 [Rules and filtering](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#getting-started-with-enterprise-rules-and-queries)를 참조하세요. 사용자는 분 단위까지의 정밀도로 어떤 시간 구간이든 지정할 수 있습니다. 다만, 응답은 지정한 `maxResults` 또는 31일 중 더 작은 값으로 제한되며, 다음 결과 집합으로 페이지네이션하기 위한 next 토큰을 포함합니다. 시간 파라미터를 지정하지 않으면, API는 가장 최근 30일간의 일치하는 데이터를 반환합니다.

Enterprise 검색 API는 분 단위 정밀도로 게시물 아카이브에 대한 지연 시간이 짧고 손실 없는 쿼리 기반 액세스를 제공합니다. 게시물 데이터는 쿼리와 일치하는 가장 최근 게시물부터 시작하여, 시간 역순으로 제공됩니다. 게시물은 발행 후 약 30초가 지나면 검색 API에서 사용할 수 있습니다.

이 검색 엔드포인트는 편집된 게시물 메타데이터를 제공합니다. 2022년 9월 29일 이후에 생성된 모든 게시물 객체에는, 게시물이 한 번도 편집되지 않았더라도 게시물 편집 메타데이터가 포함됩니다. 게시물이 편집될 때마다 새로운 Post ID가 생성됩니다. 게시물의 편집 이력은 원본 ID부터 시작하는 Post ID 배열로 기록됩니다.

이 엔드포인트는 항상 가장 최근 편집본과 모든 편집 이력을 함께 반환합니다. 게시물의 30분 편집 가능 시간 이후에 수집된 게시물은 최종 버전을 나타냅니다. Edit Post 메타데이터에 대해 더 알아보려면 [Edit Posts fundamentals](/ko/x-api/fundamentals/edit-posts) 페이지를 참고하세요.

요청에는 API 응답당 반환할 게시물의 최대 개수를 지정하는 `maxResults` 파라미터가 포함됩니다. 쿼리와 연관된 게시물 수가 응답당 이 최대 결과 수를 초과하는 경우, 응답에는 next 토큰이 포함됩니다. 이러한 next 토큰은 후속 요청에서 사용되어, 쿼리와 연관된 전체 게시물 집합을 페이지 단위로 조회할 수 있게 합니다.

이 Enterprise 검색 API는 쿼리와 연관된 데이터량을 요청할 수 있도록 하는 *counts* 엔드포인트를 제공합니다. 

<div id="request-types">
  ### 요청 유형
</div>

Enterprise 검색 API에서는 두 가지 유형의 요청을 지원합니다:

<div id="search-requests-data">
  #### Search requests (data)
</div>

Enterprise 검색 API에 대한 검색 요청을 사용하면, 지정한 기간에 대해 응답 하나당 최대 500개의 결과를 조회할 수 있으며, 페이지네이션을 통해 추가 데이터에 접근할 수 있습니다. `maxResults` 파라미터를 사용하면, 화면 표시용(use case)을 위해 더 작은 페이지 크기를 지정하여(사용자가 필요에 따라 더 많은 결과를 요청할 수 있도록) 또는 대량 데이터 수집을 위해 더 큰 페이지 크기(최대 500까지)를 지정할 수 있습니다. 데이터는 최신순(시간 역순)으로 전달되며, 전달 시점에 컴플라이언스가 반영된 상태로 제공됩니다.

<div id="counts-requests-post-count">
  #### Counts 요청 (게시물 개수)
</div>

Counts 요청은 지정된 기간 동안 특정 쿼리와 일치하는 활동이 얼마나 발생했는지를 나타내는 과거 활동 개수를 조회할 수 있게 해줍니다. 응답은 기본적으로 일(day), 시(hour), 또는 분(minute) 단위로 버킷화된 개수 히스토그램을 제공합니다(기본 버킷 단위는 *hour* 입니다). Counts 결과는 게시물이 게시된 후 상당히 오랜 시간(7일 이상)이 지난 뒤 발생하는 컴플라이언스 이벤트(예: 게시물 삭제)를 항상 반영하지는 않는다는 점이 중요합니다. 따라서 동일한 쿼리에 대한 데이터 요청에서 얻는 지표와 counts 지표가 항상 일치하지 않을 수 있습니다.

**과금 참고:** 데이터 및 counts 엔드포인트에 대해 수행되는 각 요청 – *페이지네이션 요청을 포함하여* – 은 모두 과금되는 요청으로 집계됩니다. 따라서 단일 쿼리에 대해 결과 페이지가 여러 개일 경우, 결과 X 페이지를 순회(paging)하는 것은 과금 기준으로 X개의 요청에 해당합니다.

<div id="available-operators">
  ### 사용 가능한 연산자
</div>

Enterprise 검색 API는 최대 2,048자 길이의 규칙을 지원합니다. Enterprise 검색 API는 아래에 나열된 연산자를 지원합니다. 자세한 설명은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)를 참조하세요. 

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| **게시물 콘텐츠에 대한 매칭:** | **관심 있는 계정에 대한 매칭:** | **게시물 속성:** | **지리공간 연산자:** |
| * keyword<br />* “quoted phrase”<br />* “keyword1 keyword2”~N<br />* #<br />* @<br />* $<br />* url:<br />* lang: | * from:<br />* to:<br />* retweets&#95;of: | * is:retweet  <br />    <br />* has:mentions<br />* has:hashtags<br />* has:media<br />* has:videos<br />* has:images<br />* has:links<br />* has:symbols<br />* is:verified  <br />    <br />* -is:nullcast (부정 전용 연산자) | * bounding&#95;box:[west&#95;long south&#95;lat east&#95;long north&#95;lat]<br />* point&#95;radius:[lon lat radius]<br />* has:geo<br />* place:<br />* place&#95;country:<br />* has:profile&#95;geo<br />* profile&#95;country:<br />* profile&#95;region:<br />* profile&#95;locality: |

참고: 연산자를 서로 포함하거나 중첩해서 사용하지 마세요. &quot;#cats&quot;는 검색 API에서 cats로 해석됩니다.   `lang:` 연산자와 모든 `is:` 및 `has:` 연산자는 단독 연산자로 사용할 수 없으며, 반드시 다른 절과 함께 결합해서 사용해야 합니다(예: @XDevelopers has:links).    

검색 API는 토큰화/매칭 기능으로 인해 제한된 연산자 집합만 사용합니다. Enterprise 실시간 API 및 배치형 과거(historical) API는 추가 연산자를 제공합니다. 자세한 내용은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#operators-by-product)를 참조하세요.

자세한 내용은 [연산자 시작하기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#building-rules-and-queries) 가이드를 참조하세요.

<div id="data-availability-important-date">
  ### 데이터 가용성 / 중요 일자
</div>

Full-Archive Search API를 사용할 때 X 플랫폼은 2006년부터 계속 발전해 왔다는 점을 유념해야 합니다. 새로운 기능이 추가되면서 기본 JSON 객체에 새로운 메타데이터가 추가되었습니다. 따라서 검색 연산자가 매칭하는 게시물 속성이 언제 추가되었는지 이해하는 것이 중요합니다. 아래는 중요한 메타데이터 그룹이 처음 도입된 핵심 날짜입니다. 게시물 속성이 처음 도입된 시점에 대해 더 알아보려면 [이 가이드](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#full-archive-search-metadata-timeline)를 참조하십시오.

* 최초 게시물: 3/21/2006
* 최초 네이티브 리트윗(Native Retweets): 11/6/2009
* 최초 지오태그된 게시물: 11/19/2009
* 필터링을 위해 URL이 처음 인덱싱된 날짜: 8/27/2011
* 강화된 URL 확장 메타데이터(웹사이트 제목 및 설명): 12/1/2014
* 프로필 Geo 보강 메타데이터 및 필터링: 2/17/2015

<div id="data-updates-and-mutability">
  ### 데이터 업데이트와 변경 가능성(Mutability)
</div>

Enterprise 검색 API에서는 게시물 내 일부 데이터가 변경 가능하며, 즉 최초 보관 이후에도 업데이트되거나 변경될 수 있습니다.

이러한 변경 가능한 데이터는 두 가지 범주로 나뉩니다.

* 사용자 객체 메타데이터:
  * 사용자의 @handle (숫자형 id는 변경되지 않음)
  * 프로필 소개(Bio) 설명
  * 개수: statuses, followers, friends, favorites, lists
  * 프로필 위치
  * 시간대 및 언어와 같은 기타 세부 정보
* 게시물 통계 - 즉, 사용자 동작에 의해 플랫폼에서 변경될 수 있는 항목(예시는 아래 참조):
  * favorites 개수
  * retweet 개수

대부분의 경우 검색 API는 게시물 생성 시점이 아니라 *쿼리 시점(query-time)* 에 플랫폼에 존재하는 그대로의 데이터를 반환합니다. 그러나 select 연산자(예: from, to, @, is:verified)를 사용하는 쿼리의 경우에는 그렇지 않을 수 있습니다. 데이터는 당사 인덱스에서 정기적으로 업데이트되며, 최신 구간일수록 업데이트 빈도가 더 높습니다. 그 결과, 일부 경우에는 반환된 데이터가 X.com에 현재 표시되는 데이터와 완전히 일치하지 않을 수 있지만, 마지막으로 인덱싱되었을 당시의 데이터와는 일치합니다.

이러한 불일치 문제는 연산자가 변경 가능한 데이터에 적용되는 쿼리에만 해당됩니다. 한 가지 예는 사용자 이름으로 필터링하는 경우이며, 가장 좋은 우회 방법은 이러한 쿼리에서 @handle 대신 사용자 숫자형 id를 사용하는 것입니다.

<div id="single-vs-multi-threaded-requests">
  ### 단일 스레드 vs. 다중 스레드 요청
</div>

각 고객은 검색 엔드포인트에 대해 사전에 정의된 레이트 리밋을 가지고 있습니다. Full-Archive 검색의 기본 분당 레이트 리밋은 분당 120개의 요청이며, 이는 초당 평균 2개의 쿼리(QPS)에 해당합니다. 이 평균 QPS는 이론적으로 매초 API에 2개의 요청을 보낼 수 있음을 의미합니다. 제품의 페이지네이션 기능을 고려하면, 1년 기간의 쿼리에 연관된 게시물이 100만 개 있고 이 게시물들이 1년 동안 균등하게 분포되어 있다고 가정할 때, 모든 데이터를 받기 위해서는 2,000개가 넘는 요청이 필요합니다(‘maxResults’가 500이라고 가정). 응답당 2초가 걸린다고 가정하면, 단일 스레드(이전 응답의 &quot;next&quot; 토큰을 사용해 초당 1개의 요청)를 통해 모든 데이터를 직렬/순차적으로 가져오는 데 4,000초(혹은 1시간을 조금 넘는 시간)가 걸립니다. 나쁘지 않습니다!

이제 데이터를 수신하기 위해 12개의 병렬 스레드를 사용하는 상황을 고려해 보겠습니다. 1년 기간 동안 100만 개의 게시물이 균등하게 분포되어 있다고 가정하면, 요청을 12개의 병렬 스레드(다중 스레드)로 분할하여 단일 “job”에 대한 초당 레이트 리밋을 더 많이 활용할 수 있습니다. 다시 말해, 관심 있는 각 월(month)마다 한 개의 스레드를 실행할 수 있고, 이렇게 하면 데이터를 12배 더 빠르게(~6분) 가져올 수 있습니다.

이 다중 스레드 예시는 counts 엔드포인트에도 동일하게 적용됩니다. 예를 들어, 2년 기간에 대한 게시물 개수(counts)를 받고 싶다면, 단일 스레드 요청을 보내고 31일 단위로 페이지네이션을 수행하며 개수를 조회할 수 있습니다. 응답당 2초가 걸린다고 가정하면, 24개의 API 요청을 보내고 전체 개수 결과를 조회하는 데 약 48초가 걸립니다. 그러나 한 번에 여러 개의 한 달 단위 요청을 보낼 수도 있습니다. 초당 12개의 요청을 보내면, 전체 개수 결과를 약 2초 만에 조회할 수 있습니다.

<div id="retry-logic">
  ### 재시도 로직
</div>

Enterprise search API에서 503 오류가 발생하는 경우, 일시적인 오류일 가능성이 높으며 짧은 시간 후 요청을 다시 시도하면 해결될 수 있습니다.

요청이 연속으로 4번 실패했고 각 실패 사이에 최소 10분을 기다렸다면, 다음 단계를 따라 문제를 해결해 보세요:

* 요청이 포함하는 시간 범위를 줄인 후 다시 시도합니다. 실패할 경우 시간 범위를 점진적으로 줄여, 최소 6시간 단위의 시간 창까지 반복합니다.
* 많은 수의 term을 OR 연산으로 함께 사용하고 있다면, 이를 여러 개의 개별 rule로 분리한 뒤 각 rule을 개별적으로 다시 시도합니다.
* rule에서 많은 수의 제외 조건을 사용하고 있다면, rule에 포함된 부정 term의 수를 줄인 후 다시 시도합니다.

<div id="quick-start">
  ## 빠른 시작
</div>

<div id="getting-started-with-enterprise-search-posts-30-day-api">
  ### Enterprise Search Posts: 30-Day API 시작하기
</div>

Enterprise Search Posts: 30-Day API는 최근 30일 이내에 게시된 게시물을 제공합니다. 게시물은 요청에서 지정한 쿼리를 기준으로 매칭되어 반환됩니다. 쿼리는 반환받을 게시물이 어떤 내용을 포함해야 하는지를 정의하는 규칙입니다. 이 튜토리얼에서는 X 계정 @XDevelopers가 영어로 게시한 게시물을 검색해 보겠습니다.

페이로드에 포함되어 반환되는 게시물은 전체 게시물 페이로드를 제공하는 data 형식이거나, 매칭된 게시물 수에 대한 수치 데이터를 제공하는 counts 형식일 수 있습니다. 이 튜토리얼에서는 cURL을 사용하여 data 및 counts 엔드포인트에 요청을 보낼 것입니다.

다음이 필요합니다:

* [Enterprise 계정](https://developer.x.com/en/products/x-api/enterprise)
* 사용자 이름, 비밀번호, 계정 이름
* console.gnip.com에 표시되는, 검색 엔드포인트와 연결된 레이블

<div id="accessing-the-data-endpoint">
  #### 데이터 endpoint에 액세스하기
</div>

데이터 endpoint는 조건에 맞는 게시물의 전체 게시물 페이로드를 제공합니다. `from:` 및 `lang:` 연산자를 사용하여 @XDevelopers 계정에서 작성된 영어 게시물을 찾겠습니다. *더 많은 연산자에 대해서는 [여기를 클릭](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)하세요.*

<Tabs>
  <Tab title="cURL">
    *cURL은 URL 구문을 사용하여 파일을 가져오거나 전송하는 명령줄 도구입니다.*

    다음 항목을 변경한 뒤, 아래 cURL 요청을 명령줄에 복사해 실행하세요:

    * **Username** `<USERNAME>` 예: `email@domain.com`

    * **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    * **Label** `<LABEL>` 예: `prod`

    * **fromDate and toDate** 예: `"fromDate":"201811010000", "toDate":"201811122359"`

    *요청을 전송하면 비밀번호 입력을 요구하는 프롬프트가 표시됩니다.*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/30day/accounts/<ACCOUNT-NAME>/<LABEL>.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>"}'
    ```
  </Tab>

  <Tab title="cURL example">
    *이것은 예시 cURL 요청입니다. 그대로 실행해도 동작하지 않습니다.*

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/30day/accounts/john-doe/prod.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"201811100000","toDate":"201812012359"}'
    ```
  </Tab>
</Tabs>

#### 데이터 엔드포인트 응답 페이로드

API 요청에 대한 응답은 아래와 같이 JSON 형식으로 반환됩니다.

```json
{
	"results": [
		{
			"created_at": "Fri Nov 02 17:18:31 +0000 2018",
			"id": 1058408022936977409,
			"id_str": "1058408022936977409",
			"text": "RT @harmophone: \"Tagboard, Twitter, TEGNA의 협업을 통해 가능해진 이 혁신적인 크라우드소싱은 지역 관련 대화를 실시간으로 포착해 보여주고 있습니…",
			"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter Web Client<\/a>",
			"truncated": false,
			"in_reply_to_status_id": null,
			"in_reply_to_status_id_str": null,
			"in_reply_to_user_id": null,
			"in_reply_to_user_id_str": null,
			"in_reply_to_screen_name": null,
			"user": {
				"id": 2244994945,
				"id_str": "2244994945",
				"name": "Twitter Dev",
				"screen_name": "TwitterDev",
				"location": "인터넷",
				"url": "https:\/\/developer.x.com\/",
				"description": "Twitter 플랫폼 관련 소식, 업데이트 및 이벤트를 전하는 공식 채널입니다. 기술 지원이 필요하신가요? https:\/\/devcommunity.com\/ 에 방문하세요 ⌨️ #TapIntoTwitter",
				"translator_type": "null",
				"protected": false,
				"verified": true,
				"followers_count": 503828,
				"friends_count": 1477,
				"listed_count": 1437,
				"favourites_count": 2199,
				"statuses_count": 3380,
				"created_at": "Sat Dec 14 04:35:55 +0000 2013",
				"utc_offset": null,
				"time_zone": null,
				"geo_enabled": true,
				"lang": "en",
				"contributors_enabled": false,
				"is_translator": false,
				"profile_background_color": "null",
				"profile_background_image_url": "null",
				"profile_background_image_url_https": "null",
				"profile_background_tile": null,
				"profile_link_color": "null",
				"profile_sidebar_border_color": "null",
				"profile_sidebar_fill_color": "null",
				"profile_text_color": "null",
				"profile_use_background_image": null,
				"profile_image_url": "null",
				"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/880136122604507136\/xHrnqf1T_normal.jpg",
				"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/2244994945\/1498675817",
				"default_profile": false,
				"default_profile_image": false,
				"following": null,
				"follow_request_sent": null,
				"notifications": null
			},
			"geo": null,
			"coordinates": null,
			"place": null,
			"contributors": null,
			"retweeted_status": {
				"created_at": "Tue Oct 30 21:30:25 +0000 2018",
				"id": 1057384253116289025,
				"id_str": "1057384253116289025",
				"text": "\"The innovative crowdsourcing that the Tagboard, Twitter and TEGNA collaboration enables is surfacing locally relev… https:\/\/t.co\/w46U5TRTzQ",
				"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter Web Client<\/a>",
				"truncated": true,
				"in_reply_to_status_id": null,
				"in_reply_to_status_id_str": null,
				"in_reply_to_user_id": null,
				"in_reply_to_user_id_str": null,
				"in_reply_to_screen_name": null,
				"user": {
					"id": 175187944,
					"id_str": "175187944",
					"name": "Tyler Singletary",
					"screen_name": "harmophone",
					"location": "San Francisco, CA",
					"url": "http:\/\/medium.com\/@harmophone",
					"description": "@Tagboard 제품 담당 SVP. 예전에 @Klout 및 @LithiumTech에서 데이터, 비즈니스, 제품 관련 업무를 했습니다. @BBI 이사회 멤버이자 @Insightpool 고문입니다. 세계에서 화이트보드를 가장 못 쓰는 사람입니다.",
					"translator_type": "null",
					"protected": false,
					"verified": false,
					"followers_count": 1982,
					"friends_count": 1877,
					"listed_count": 245,
					"favourites_count": 23743,
					"statuses_count": 12708,
					"created_at": "Thu Aug 05 22:59:29 +0000 2010",
					"utc_offset": null,
					"time_zone": null,
					"geo_enabled": false,
					"lang": "en",
					"contributors_enabled": false,
					"is_translator": false,
					"profile_background_color": "null",
					"profile_background_image_url": "null",
					"profile_background_image_url_https": "null",
					"profile_background_tile": null,
					"profile_link_color": "null",
					"profile_sidebar_border_color": "null",
					"profile_sidebar_fill_color": "null",
					"profile_text_color": "null",
					"profile_use_background_image": null,
					"profile_image_url": "null",
					"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/719985428632240128\/WYFHcK-m_normal.jpg",
					"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/175187944\/1398653841",
					"default_profile": false,
					"default_profile_image": false,
					"following": null,
					"follow_request_sent": null,
					"notifications": null
				},
				"geo": null,
				"coordinates": null,
				"place": null,
				"contributors": null,
				"is_quote_status": false,
				"extended_tweet": {
					"full_text": "\"Tagboard, Twitter, TEGNA의 협업을 통해 가능해진 이 혁신적인 크라우드소싱은 지역 관련 대화를 실시간으로 포착해 보여주고, 토론 중 유권자들이 질문을 할 수 있도록 돕고 있습니다.”  -- @adamostrow, @TEGNA\n자세히 알아보기: https:\/\/t.co\/ivAFtanfje",
					"display_text_range": [
						0,
						259
					],
					"entities": {
						"hashtags": [],
						"urls": [
							{
								"url": "https:\/\/t.co\/ivAFtanfje",
								"expanded_url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
								"display_url": "blog.tagboard.com\/twitter-and-ta…",
								"unwound": {
									"url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
									"status": 200,
									"title": "Twitter와 Tagboard, 최고의 선거 콘텐츠를 Tagboard를 통해 뉴스 매체에 제공하기 위해 협업…",
									"description": "작성자: Tyler Singletary, Tagboard 제품 책임자"
								},
								"indices": [
									236,
									259
								]
							}
						],
						"user_mentions": [
							{
								"screen_name": "adamostrow",
								"name": "Adam Ostrow",
								"id": 5695942,
								"id_str": "5695942",
								"indices": [
									204,
									215
								]
							},
							{
								"screen_name": "TEGNA",
								"name": "TEGNA",
								"id": 34123003,
								"id_str": "34123003",
								"indices": [
									217,
									223
								]
							}
						],
						"symbols": []
					}
				},
				"quote_count": 0,
				"reply_count": 1,
				"retweet_count": 6,
				"favorite_count": 19,
				"entities": {
					"hashtags": [],
					"urls": [
						{
							"url": "https:\/\/t.co\/w46U5TRTzQ",
							"expanded_url": "https:\/\/twitter.com\/i\/web\/status\/1057384253116289025",
							"display_url": "twitter.com\/i\/web\/status\/1…",
							"indices": [
								117,
								140
							]
						}
					],
					"user_mentions": [],
					"symbols": []
				},
				"favorited": false,
				"retweeted": false,
				"possibly_sensitive": false,
				"filter_level": "low",
				"lang": "en"
			},
			"is_quote_status": false,
			"quote_count": 0,
			"reply_count": 0,
			"retweet_count": 0,
			"favorite_count": 0,
			"entities": {
				"hashtags": [],
				"urls": [],
				"user_mentions": [
					{
						"screen_name": "harmophone",
						"name": "Tyler Singletary",
						"id": 175187944,
						"id_str": "175187944",
						"indices": [
							3,
							14
						]
					}
				],
				"symbols": []
			},
			"favorited": false,
			"retweeted": false,
			"filter_level": "low",
			"lang": "en",
			"matching_rules": [
				{
					"tag": null
				}
			]
		}
	],
	"requestParameters": {
		"maxResults": 100,
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

<div id="accessing-the-counts-endpoint">
  #### counts 엔드포인트에 액세스하기
</div>

counts 엔드포인트를 사용해 `day` 단위로 그룹화된, @XDevelopers 계정에서 영어로 작성된 게시물 수를 가져옵니다.

<Tabs>
  <Tab title="cURL">
    *cURL은 URL 구문을 사용하여 파일을 가져오거나 전송하는 명령줄 도구입니다.*

    다음 항목을 변경한 후 아래 cURL 요청을 명령줄에 복사해 실행하세요:

    * **Username** `<USERNAME>` 예: `email@domain.com`

    * **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    * **Label** `<LABEL>` 예: `prod`

    * **fromDate 및 toDate** 예: `"fromDate":"201811010000", "toDate":"201811122359"`

    *요청을 전송한 후 비밀번호를 입력하라는 메시지가 표시됩니다.*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/30day/accounts/<ACCOUNT-NAME>/<LABEL>/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>","bucket":"day"}'
    ```
  </Tab>

  <Tab title="cURL 예제">
    *이것은 예시용 cURL 요청입니다. 그대로 실행하면 동작하지 않습니다.*

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/30day/accounts/john-doe/prod/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"201811100000","toDate":"201812012359","bucket":"day"}'
    ```
  </Tab>
</Tabs>

<div id="counts-endpoint-response-payload">
  #### Counts 엔드포인트 응답 페이로드
</div>

API 요청에 대한 응답 페이로드는 아래 예시와 같이 JSON 형식으로 표시됩니다.

```json
{
	"results": [
		{
			"timePeriod": "201811010000",
			"count": 0
		},
		{
			"timePeriod": "201811020000",
			"count": 1
		},
		{
			"timePeriod": "201811030000",
			"count": 0
		},
		{
			"timePeriod": "201811040000",
			"count": 0
		},
		{
			"timePeriod": "201811050000",
			"count": 0
		}
	],
	"totalCount": 1,
	"requestParameters": {
		"bucket": "day",
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

잘하셨습니다! 이제 enterprise Search Posts: 30-Day API에 성공적으로 접근하셨습니다.

<div id="referenced-articles">
  ##### **참고 문서**
</div>

* [게시물 객체 소개](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary)
* [검색 연산자](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)
* [게시물 객체와 페이로드](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#post-object)

<div id="getting-started-with-enterprise-search-posts-full-archive-api">
  ### enterprise Search Posts: Full-Archive API 시작하기
</div>

enterprise Search Posts: Full-Archive API는 2006년에 게시된 첫 번째 게시물부터의 게시물을 제공합니다. 게시물은 요청에서 지정한 쿼리를 기준으로 매칭되어 반환됩니다. 쿼리는 반환받을 게시물이 어떤 내용을 포함해야 하는지를 정의하는 규칙입니다. 이 튜토리얼에서는 X 계정 @XDevelopers에서 영어로 작성된 게시물을 검색합니다.

페이로드에 포함되어 반환되는 게시물은 전체 게시물 페이로드를 제공하는 `data` 형식이거나, 일치한 게시물 개수에 대한 수치 데이터(count)를 제공하는 counts 형식일 수 있습니다. 이 튜토리얼에서는 cURL을 사용하여 data 및 counts 엔드포인트에 요청을 보냅니다.

다음 항목이 필요합니다:

* [Enterprise 계정]https://developer.x.com/en/products/x-api/enterprise
* 사용자 이름, 비밀번호, 계정명
* console.gnip.com에 표시되는 검색 엔드포인트와 연결된 레이블

<div id="accessing-the-data-endpoint">
  #### 데이터 endpoint에 액세스하기
</div>

데이터 endpoint는 일치하는 게시물의 전체 게시물 페이로드를 제공합니다. `from:` 및 `lang:` 연산자를 사용하여 영어로 작성된 @XDevelopers의 게시물을 찾습니다. *더 많은 연산자는 [여기를 클릭](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)하세요.*

* [cURL](#tab1)
* [cURL 예제](#tab2)

<Tabs>
  <Tab title="cURL">
    *cURL은 URL 구문을 사용하여 파일을 가져오거나 전송하는 명령줄 도구입니다.*

    아래 cURL 요청에서 다음 항목을 변경한 뒤 명령줄에 복사하여 실행합니다:

    * **Username** `<USERNAME>` 예: `email@domain.com`

    * **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    * **Label** `<LABEL>` 예: `prod`

    * **fromDate 및 toDate** 예: `"fromDate":"201802010000", "toDate":"201802282359"`

    *요청을 전송하면 비밀번호 입력을 요청받게 됩니다.*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/fullarchive/accounts/<ACCOUNT-NAME>/<LABEL>.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>"}'
    ```
  </Tab>

  <Tab title="cURL 예제">
    *이는 예시용 cURL 요청입니다. 그대로 실행해도 실제로는 동작하지 않습니다.*

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/fullarchive/accounts/john-doe/prod.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"201802010000","toDate":"201802282359"}'
    ```
  </Tab>
</Tabs>

<div id="data-endpoint-response-payload">
  ##### 데이터 엔드포인트 응답 페이로드
</div>

API 요청에 대한 응답 페이로드는 아래 예시와 같이 JSON 형식으로 반환됩니다.

```json
{
	"results": [
		{
			"created_at": "Fri Nov 02 17:18:31 +0000 2018",
			"id": 1058408022936977409,
			"id_str": "1058408022936977409",
			"text": "RT @harmophone: \"Tagboard, Twitter, TEGNA 간 협업으로 가능해진 혁신적인 크라우드소싱이 지역 관련 대화를 이끌어내고 있습니…",
			"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter 웹 클라이언트<\/a>",
			"truncated": false,
			"in_reply_to_status_id": null,
			"in_reply_to_status_id_str": null,
			"in_reply_to_user_id": null,
			"in_reply_to_user_id_str": null,
			"in_reply_to_screen_name": null,
			"user": {
				"id": 2244994945,
				"id_str": "2244994945",
				"name": "Twitter Dev",
				"screen_name": "TwitterDev",
				"location": "인터넷",
				"url": "https:\/\/developer.x.com\/",
				"description": "Twitter 플랫폼 관련 뉴스, 업데이트 및 이벤트를 제공하는 공식 채널입니다. 기술적인 도움이 필요하신가요? https:\/\/devcommunity.com\/ 에 방문해 보세요. ⌨️ #TapIntoTwitter",
				"translator_type": "null",
				"protected": false,
				"verified": true,
				"followers_count": 503828,
				"friends_count": 1477,
				"listed_count": 1437,
				"favourites_count": 2199,
				"statuses_count": 3380,
				"created_at": "Sat Dec 14 04:35:55 +0000 2013",
				"utc_offset": null,
				"time_zone": null,
				"geo_enabled": true,
				"lang": "en",
				"contributors_enabled": false,
				"is_translator": false,
				"profile_background_color": "null",
				"profile_background_image_url": "null",
				"profile_background_image_url_https": "null",
				"profile_background_tile": null,
				"profile_link_color": "null",
				"profile_sidebar_border_color": "null",
				"profile_sidebar_fill_color": "null",
				"profile_text_color": "null",
				"profile_use_background_image": null,
				"profile_image_url": "null",
				"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/880136122604507136\/xHrnqf1T_normal.jpg",
				"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/2244994945\/1498675817",
				"default_profile": false,
				"default_profile_image": false,
				"following": null,
				"follow_request_sent": null,
				"notifications": null
			},
			"geo": null,
			"coordinates": null,
			"place": null,
			"contributors": null,
			"retweeted_status": {
				"created_at": "Tue Oct 30 21:30:25 +0000 2018",
				"id": 1057384253116289025,
				"id_str": "1057384253116289025",
				"text": "\"Tagboard, Twitter, TEGNA 간 협업으로 가능해진 혁신적인 크라우드소싱이 지역 관련 대화를 이끌어내고 있습니… https:\/\/t.co\/w46U5TRTzQ",
				"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter 웹 클라이언트<\/a>",
				"truncated": true,
				"in_reply_to_status_id": null,
				"in_reply_to_status_id_str": null,
				"in_reply_to_user_id": null,
				"in_reply_to_user_id_str": null,
				"in_reply_to_screen_name": null,
				"user": {
					"id": 175187944,
					"id_str": "175187944",
					"name": "Tyler Singletary",
					"screen_name": "harmophone",
					"location": "San Francisco, CA",
					"url": "http:\/\/medium.com\/@harmophone",
					"description": "@Tagboard 제품 담당 수석 부사장(SVP). @Klout 및 @LithiumTech 에서 데이터, 비즈니스, 제품 관련 업무를 했습니다. @BBI 이사회 멤버이자 @Insightpool 자문입니다. 세계에서 가장 형편없는 화이트보드 사용자입니다.",
					"translator_type": "null",
					"protected": false,
					"verified": false,
					"followers_count": 1982,
					"friends_count": 1877,
					"listed_count": 245,
					"favourites_count": 23743,
					"statuses_count": 12708,
					"created_at": "Thu Aug 05 22:59:29 +0000 2010",
					"utc_offset": null,
					"time_zone": null,
					"geo_enabled": false,
					"lang": "en",
					"contributors_enabled": false,
					"is_translator": false,
					"profile_background_color": "null",
					"profile_background_image_url": "null",
					"profile_background_image_url_https": "null",
					"profile_background_tile": null,
					"profile_link_color": "null",
					"profile_sidebar_border_color": "null",
					"profile_sidebar_fill_color": "null",
					"profile_text_color": "null",
					"profile_use_background_image": null,
					"profile_image_url": "null",
					"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/719985428632240128\/WYFHcK-m_normal.jpg",
					"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/175187944\/1398653841",
					"default_profile": false,
					"default_profile_image": false,
					"following": null,
					"follow_request_sent": null,
					"notifications": null
				},
				"geo": null,
				"coordinates": null,
				"place": null,
				"contributors": null,
				"is_quote_status": false,
				"extended_tweet": {
					"full_text": "\"Tagboard, Twitter, TEGNA 간 협업으로 가능해진 혁신적인 크라우드소싱이 지역 관련 대화를 실시간으로 포착하고, 토론 중에 유권자들이 질문을 할 수 있도록 돕고 있습니다.”  -- @adamostrow, @TEGNA\n자세히 알아보기: https:\/\/t.co\/ivAFtanfje",
					"display_text_range": [
						0,
						259
					],
					"entities": {
						"hashtags": [],
						"urls": [
							{
								"url": "https:\/\/t.co\/ivAFtanfje",
								"expanded_url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
								"display_url": "blog.tagboard.com\/twitter-and-ta…",
								"unwound": {
									"url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
									"status": 200,
									"title": "Twitter와 Tagboard, 최고의 선거 관련 콘텐츠를 뉴스 매체에 제공하기 위해 Tagboard와 협업…",
									"description": "작성자: Tyler Singletary, Tagboard 제품 총괄"
								},
								"indices": [
									236,
									259
								]
							}
						],
						"user_mentions": [
							{
								"screen_name": "adamostrow",
								"name": "Adam Ostrow",
								"id": 5695942,
								"id_str": "5695942",
								"indices": [
									204,
									215
								]
							},
							{
								"screen_name": "TEGNA",
								"name": "TEGNA",
								"id": 34123003,
								"id_str": "34123003",
								"indices": [
									217,
									223
								]
							}
						],
						"symbols": []
					}
				},
				"quote_count": 0,
				"reply_count": 1,
				"retweet_count": 6,
				"favorite_count": 19,
				"entities": {
					"hashtags": [],
					"urls": [
						{
							"url": "https:\/\/t.co\/w46U5TRTzQ",
							"expanded_url": "https:\/\/twitter.com\/i\/web\/status\/1057384253116289025",
							"display_url": "twitter.com\/i\/web\/status\/1…",
							"indices": [
								117,
								140
							]
						}
					],
					"user_mentions": [],
					"symbols": []
				},
				"favorited": false,
				"retweeted": false,
				"possibly_sensitive": false,
				"filter_level": "low",
				"lang": "en"
			},
			"is_quote_status": false,
			"quote_count": 0,
			"reply_count": 0,
			"retweet_count": 0,
			"favorite_count": 0,
			"entities": {
				"hashtags": [],
				"urls": [],
				"user_mentions": [
					{
						"screen_name": "harmophone",
						"name": "Tyler Singletary",
						"id": 175187944,
						"id_str": "175187944",
						"indices": [
							3,
							14
						]
					}
				],
				"symbols": []
			},
			"favorited": false,
			"retweeted": false,
			"filter_level": "low",
			"lang": "en",
			"matching_rules": [
				{
					"tag": null
				}
			]
		}
	],
	"requestParameters": {
		"maxResults": 100,
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

#### counts 엔드포인트에 접근하기

counts 엔드포인트를 사용하여, 영어로 작성된 @XDevelopers 계정에서 생성된 게시물 개수를 `day` 단위로 집계해 가져오겠습니다.

<Tabs>
  <Tab title="cURL">
    *cURL은 URL 구문을 사용해 파일을 가져오거나 전송하는 명령줄 도구입니다.*

    다음 항목들을 변경한 뒤, 아래 cURL 요청을 명령줄에 복사해 실행하세요.

    * **Username** `<USERNAME>` 예: `email@domain.com`

    * **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    * **Label** `<LABEL>` 예: `prod`

    * **fromDate 및 toDate** 예: `"fromDate":"201802010000", "toDate":"201802282359"`

    *요청을 전송한 후 비밀번호를 입력하라는 메시지가 표시됩니다.*

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/fullarchive/accounts/<ACCOUNT-NAME>/<LABEL>/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>","bucket":"day"}'
    ```
  </Tab>

  <Tab title="cURL 예시">
    *이것은 예시 cURL 요청입니다. 그대로 실행하면 동작하지 않습니다.*

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/fullarchive/accounts/john-doe/prod/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"201802010000","toDate":"201802282359","bucket":"day"}'
    ```
  </Tab>
</Tabs>

<div id="counts-endpoint-response-payload">
  #### Counts 엔드포인트 응답 페이로드
</div>

API 요청에 대한 응답 페이로드는 아래 예시와 같이 JSON 형식으로 반환됩니다.

```json
{
	"results": [
		{
			"timePeriod": "201811010000",
			"count": 0
		},
		{
			"timePeriod": "201811020000",
			"count": 1
		},
		{
			"timePeriod": "201811030000",
			"count": 0
		},
		{
			"timePeriod": "201811040000",
			"count": 0
		},
		{
			"timePeriod": "201811050000",
			"count": 0
		}
	],
	"totalCount": 1,
	"requestParameters": {
		"bucket": "day",
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

잘하셨습니다! 이제 Enterprise Search Posts: Full-Archive API에 성공적으로 접근할 수 있게 되었습니다.

##### 관련 문서

* [게시물 객체 소개](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary)
* [검색 연산자](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)
* [게시물 객체와 페이로드](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#post-object)

<div id="guides">
  ## 가이드
</div>

<div id="building-search-queries">
  ### 검색 쿼리 작성하기
</div>

<div id="enterprise-operators">
  ### Enterprise 연산자
</div>

아래는 X의 Enterprise 검색 API에서 지원되는 연산자의 전체 목록입니다:

* **Enterprise** 30일 검색 API
* **Enterprise** 전체 아카이브 검색 API

제품별 사용 가능한 연산자를 나란히 비교하려면 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#operators-by-product)를 참고하세요.

| 연산자                             | 설명                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| :------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 키워드                             | 게시물 본문이나 URL 내에서 토큰화된 keyword와 일치 여부를 확인합니다. 이는 토큰화된 매치로, 사용자의 keyword 문자열이 게시물 본문의 토큰화된 텍스트와 비교된다는 의미입니다. 토큰화는 문장 부호, 기호, 구분자 Unicode 기본 영역 문자를 기준으로 수행됩니다. 예를 들어, 텍스트가 “I like coca-cola”인 게시물은 다음 토큰으로 분리됩니다: I, like, coca, cola. 그런 다음 이 토큰들이 규칙에서 사용한 keyword 문자열과 비교됩니다. 문장 부호(예: coca-cola), 기호 또는 구분자 문자를 포함하는 문자열과 일치시키려면, 아래에 설명된 따옴표로 감싼 정확 일치(quoted exact match)를 사용해야 합니다.<br /><br />**Note:** Search API에서는 악센트 및 특수 문자가 표준 라틴 문자로 정규화되며, 이로 인해 외국어에서 의미가 바뀌거나 예기치 않은 결과가 반환될 수 있습니다.<br />예를 들어, &quot;músic&quot;은 “music”과 일치하며, 그 반대도 마찬가지입니다.<br />예를 들어, 스페인어의 흔한 문구인 &quot;Feliz Año Nuevo!&quot;는 &quot;Feliz Ano Nuevo&quot;로 인덱싱되며, 이로 인해 문구의 의미가 변경됩니다.<br /><br />**Note:** 이 연산자는 게시물 내의 URL과 언와인드(unwound) URL 모두에 대해 매치됩니다. |
| emoji                           | 게시물 본문 내의 이모지를 매칭합니다. 이모지는 토큰 단위 매치로 처리되며, 사용한 이모지가 토큰화된 게시물 본문 텍스트와 비교됩니다. 토큰화는 문장 부호, 기호/이모지, 구분자에 해당하는 유니코드 기본 평면(plane) 문자를 기준으로 이루어집니다. 예를 들어, 텍스트가 “I like <Icon icon="pizza-slice" iconType="solid" />”인 게시물은 다음 토큰들로 분리됩니다: I, like, <Icon icon="pizza-slice" iconType="solid" />. 그런 다음 이 토큰들을 규칙에 사용한 이모지와 비교합니다. 이모지에 변형(variant)이 있는 경우, 규칙에 추가하려면 반드시 “따옴표”로 감싸야 합니다.                                                                                                                                                                                                                                                                                                                                                                          |
| &quot;정확한 문구 일치&quot;           | 게시물 본문 또는 URL 안에서 토큰화되고 순서가 유지된 구문과 일치시킵니다. 이는 토큰화 기반 매칭으로, 키워드 문자열이 게시물 본문의 토큰화된 텍스트와 비교된다는 의미입니다. 토큰화는 문장 부호, 기호, 구분자에 해당하는 Unicode 기본 평면 문자들을 기준으로 수행됩니다. <br /><br />**참고:** 문장 부호는 토큰화되지 않으며, 공백으로 처리됩니다.<br />예를 들어, 따옴표로 감싼 “#hashtag”는 “hashtag”와는 일치하지만 #hashtag와는 일치하지 않습니다(실제 해시태그를 매칭하려면 따옴표 없이 해시태그 # 연산자를 사용하십시오).<br />예를 들어, 따옴표로 감싼 “$cashtag”는 “cashtag”와는 일치하지만 $cashtag와는 일치하지 않습니다(실제 캐시태그를 매칭하려면 따옴표 없이 캐시태그 $ 연산자를 사용하십시오).<br />예를 들어, &quot;Love Snow&quot;는 &quot;#love #snow&quot;와 일치합니다.<br />예를 들어, &quot;#Love #Snow&quot;는 &quot;love snow&quot;와 일치합니다.<br /><br />**참고:** 이 연산자는 게시물 내의 URL과 언와인드(unwound)된 URL 모두에 대해 매칭됩니다.                                                                                             |
| &quot;keyword1 keyword2&quot;~N | 일반적으로 근접 연산자로 불리며, 이 연산자는 키워드들이 서로 N개 토큰보다 멀리 떨어져 있지 않은 게시물을 매칭합니다. <br /><br />키워드의 순서가 역순인 경우에는 서로 N-2개 토큰보다 더 멀리 떨어져 있을 수 없습니다. 큰따옴표 안에는 키워드를 원하는 만큼 포함할 수 있습니다. N은 6을 초과할 수 없습니다.<br /><br />이 연산자는 `enterprise` 검색 API에서만 사용할 수 있다는 점에 유의하십시오.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| from:                           | 특정 사용자가 작성한 게시물과 일치합니다.<br />값은 해당 사용자의 X 계정 숫자 ID 또는 사용자 이름(@ 문자를 제외한)이어야 합니다. X 계정 숫자 ID를 조회하는 방법은 [여기](/ko/x-api/users/lookup/introduction) 또는 [여기](http://gettwitterid.com/)를 참고하십시오.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| to:                             | 특정 사용자에게 보낸 답글인 모든 게시물과 일치합니다.<br /><br />값은 사용자의 숫자형 계정 ID 또는 사용자 이름(@ 문자는 제외)이어야 합니다. 숫자형 X 계정 ID를 조회하는 방법은 [여기](/ko/x-api/users/lookup/introduction)를 참고하세요.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| url:                            | 게시물의 확장된 URL에 대해 토큰화된(키워드/구문) 방식으로 매칭을 수행합니다(url&#95;contains와 유사). 문장 부호나 특수 문자가 포함된 토큰과 구문은 큰따옴표로 감싸야 합니다. 예: url:&quot;/developer&quot;. 일반적으로는 권장되지 않지만, 특정 프로토콜에 대해 매칭하고 싶다면 큰따옴표로 감싸십시오: url:&quot;[https://developer.x.com](https://developer.x.com)&quot;.<br />**참고:** PowerTrack 또는 Historical PowerTrack을 사용할 때, 이 연산자는 인용 게시물(Quote Post)의 원본 게시물에 포함된 URL에도 매칭됩니다. 예를 들어, 규칙에 url:&quot;developer.x.com&quot;이 포함되어 있고, 어떤 게시물이 해당 URL을 포함하는 경우, 그 게시물을 인용한 모든 게시물도 결과에 포함됩니다. 이는 Search API를 사용할 때에는 그렇지 않습니다.                                                                                                                                                                                                                                |
| #                               | 지정한 해시태그가 있는 모든 게시물과 일치합니다.<br /><br />이 연산자는 토큰 기반 매칭이 아닌, 정확 일치 매칭을 수행합니다. 즉, 규칙 “2016”은 정확히 “2016” 해시태그가 있는 게시물과는 일치하지만, “2016election” 해시태그가 있는 게시물과는 일치하지 않습니다.<br /><br />참고: 해시태그 연산자는 게시물 본문에서 해시태그를 직접 추출하는 대신, X의 엔티티 추출 기능에 의존하여 해시태그를 매칭합니다. X Entities JSON 속성에 대한 더 자세한 내용은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#hashtags)를 참고하세요.                                                                                                                                                                                                                                                                                                                                                                                    |
| @                               | 지정한 사용자 이름을 언급한 모든 게시물과 일치합니다.<br />`to:` 연산자는 `@mention` 연산자의 결과 중 일부에 해당하는(부분 집합인) 결과만 반환합니다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| $                               | 지정된 ‘cashtag’를 포함하는 모든 게시물과 일치합니다(토큰의 첫 글자가 ‘$’ 문자인 경우).<br /><br />cashtag 연산자는 본문에서 직접 cashtag를 추출하려고 시도하는 대신, X의 ‘symbols’ 엔티티 추출 기능에 의존하여 cashtag를 매칭합니다. X Entities JSON 속성에 대한 자세한 내용은 [HERE](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#symbols)를 참조하세요.<br /><br />이 연산자는 `enterprise` 검색 API에서만 사용할 수 있습니다.<br /><br />                                                                                                                                                                                                                                                                                                                                                                                                               |
| retweets&#95;of:                | *사용 가능한 별칭*: retweets&#95;of&#95;user:<br />지정된 사용자의 리트윗인 게시물을 일치시킵니다. 사용자 이름과 숫자형 X 계정 ID(게시물 status ID 아님) 모두를 허용합니다.숫자형 X 계정 ID를 조회하는 방법은 [여기](/ko/x-api/users/lookup/introduction)를 참조하세요.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| lang:                           | 특정 언어로 분류된 게시물(해당 게시물이 분류된 경우에만)을 반환합니다. 각 게시물은 현재 하나의 언어로만 분류되므로, 여러 언어를 AND 연산자로 함께 사용하면 어떤 결과도 반환되지 않는다는 점에 유의해야 합니다.<br /><br />**참고:** 언어 분류를 할 수 없는 경우 제공되는 결과 값은 ‘und’(정의되지 않음을 의미)입니다.<br /><br />아래 목록은 현재 지원되는 언어와 해당 BCP 47 언어 식별자를 나타냅니다:<br />                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| 암하라어: am | 독일어: de | 말라얄람어: ml | 슬로바키아어: sk |
| 아랍어: ar | 그리스어: el | 몰디브어: dv | 슬로베니아어: sl |
| 아르메니아어: hy | 구자라티어: gu | 마라티어: mr | 소라니 쿠르드어: ckb |
| 바스크어: eu | 아이티 크리올어: ht | 네팔어: ne | 스페인어: es |
| 벵골어: bn | 히브리어: iw | 노르웨이어: no | 스웨덴어: sv |
| 보스니아어: bs | 힌디어: hi | 오리야어: or | 타갈로그어: tl |
| 불가리아어: bg | 로마자 힌디어: hi-Latn | 펀자브어: pa | 타밀어: ta |
| 버마어: my | 헝가리어: hu | 파슈토어: ps | 텔루구어: te |
| 크로아티아어: hr | 아이슬란드어: is | 페르시아어: fa | 태국어: th |
| 카탈루냐어: ca | 인도네시아어: in | 폴란드어: pl | 티베트어: bo |
| 체코어: cs | 이탈리아어: it | 포르투갈어: pt | 번체 중국어: zh-TW |
| 덴마크어: da | 일본어: ja | 루마니아어: ro | 터키어: tr |
| 네덜란드어: nl | 칸나다어: kn | 러시아어: ru | 우크라이나어: uk |
| 영어: en | 크메르어: km | 세르비아어: sr | 우르두어: ur |
| 에스토니아어: et | 한국어: ko | 간체 중국어: zh-CN | 위구르어: ug |
| 핀란드어: fi | 라오어: lo | 신디어: sd | 베트남어: vi |
| 프랑스어: fr | 라트비아어: lv | 신할라어: si | 웨일스어: cy |
| 조지아어: ka | 리투아니아어: lt |     |

|||
|:----|:---|
|place:|지정된 위치 또는 X place ID가 태그된 게시물과 일치합니다(예시 참조). 여러 단어로 이루어진 장소 이름(“New York City”, “Palo Alto”)은 따옴표로 감싸야 합니다.<br /><br />**참고:** X place ID를 얻는 방법은 [GET geo/search](https://developer.x.com/en/docs/x-api/v1/geo/place-information/overview) 공개 API 엔드포인트를 참고하세요.<br /><br />**참고:** 이 연산자는 리트윗의 장소 정보가 원본 게시물에 연결되므로 리트윗에는 매칭되지 않습니다. 또한 인용 트윗의 원본 게시물에 연결된 장소 정보에도 매칭되지 않습니다.|
|place&#95;country:|태그된 [place](https://developer.x.com/en/docs/x-api/v1/geo/place-information/overview)에 연결된 국가 코드가 주어진 ISO 알파-2 문자 코드와 일치하는 게시물을 매칭합니다.<br /><br />유효한 ISO 코드는 다음에서 확인할 수 있습니다: [http://en.wikipedia.org/wiki/ISO&#95;3166-1&#95;alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)<br /><br />**참고:** 이 연산자는 리트윗의 장소 정보가 원본 게시물에 연결되므로 리트윗에는 매칭되지 않습니다. 또한 인용 트윗의 원본 게시물에 연결된 장소 정보에도 매칭되지 않습니다.|
|point&#95;radius:[lon lat radius]|게시물에 정확한 위치(경도, 위도)가 있는 경우 해당 위치와, X에서 정의된 영역 내에 완전히 포함되는 “Place” 지오 폴리곤에 대해 매칭합니다.<br /><br />* 지원되는 반지름 단위는 마일(mi)과 킬로미터(km)입니다.<br />* 반지름은 25mi 미만이어야 합니다.<br />* 경도는 ±180 범위입니다.<br />* 위도는 ±90 범위입니다.<br />* 모든 좌표는 십진수 도(degree) 단위입니다.<br />* 규칙 인수는 대괄호 안에 포함되며 공백으로 구분됩니다.<br /><br />**참고:** 이 연산자는 리트윗의 장소 정보가 원본 게시물에 연결되므로 리트윗에는 매칭되지 않습니다. 또한 인용 트윗의 원본 게시물에 연결된 장소 정보에도 매칭되지 않습니다.|
|bounding&#95;box:[west&#95;long south&#95;lat east&#95;long north&#95;lat]|*사용 가능한 별칭*: geo&#95;bounding&#95;box:<br /><br />게시물에 정확한 위치(경도, 위도)가 있는 경우 해당 위치와, X에서 정의된 영역 내에 완전히 포함되는 “Place” 지오 폴리곤에 대해 매칭합니다.<br /><br />* west&#95;long, south&#95;lat는 바운딩 박스의 남서쪽 모서리를 나타내며, west&#95;long은 그 지점의 경도, south&#95;lat는 위도입니다.<br />* east&#95;long과 north&#95;lat는 바운딩 박스의 북동쪽 모서리를 나타내며, east&#95;long은 그 지점의 경도, north&#95;lat는 위도입니다.<br />* 바운딩 박스의 너비와 높이는 25mi 미만이어야 합니다.<br />* 경도는 ±180 범위입니다.<br />* 위도는 ±90 범위입니다.<br />* 모든 좌표는 십진수 도(degree) 단위입니다.<br />* 규칙 인수는 대괄호 안에 포함되며 공백으로 구분됩니다.<br />**참고:** 이 연산자는 리트윗의 장소 정보가 원본 게시물에 연결되므로 리트윗에는 매칭되지 않습니다. 또한 인용 트윗의 원본 게시물에 연결된 장소 정보에도 매칭되지 않습니다.|
|profile&#95;country:|Profile Geo enrichment의 “address” 객체에 있는 “countryCode” 필드와 정확히 일치합니다.<br />ISO-3166-1-alpha-2 명세를 기반으로 하는 정규화된 두 글자 국가 코드 집합을 사용합니다. 이 연산자는 간결성을 위해 “address” 객체의 “country” 필드를 위한 연산자 대신 제공됩니다.|
|profile&#95;region:|Profile Geo enrichment의 “address” 객체에 있는 “region” 필드와 매칭합니다.<br /><br />이는 전체 문자열에 대한 정확 일치입니다. 역슬래시로 문자를 이스케이프할 필요가 없습니다. 예를 들어 슬래시가 포함된 문자열을 매칭할 때는 “one/two”를 사용하고 “one\/two”는 사용하지 마세요. 공백이나 문장 부호가 포함된 부분 문자열을 매칭하려면 큰따옴표를 사용하세요.|
|profile&#95;locality:|Profile Geo enrichment의 “address” 객체에 있는 “locality” 필드와 매칭합니다.<br /><br />이는 전체 문자열에 대한 정확 일치입니다. 역슬래시로 문자를 이스케이프할 필요가 없습니다. 예를 들어 슬래시가 포함된 문자열을 매칭할 때는 “one/two”를 사용하고 “one\/two”는 사용하지 마세요. 공백이나 문장 부호가 포함된 부분 문자열을 매칭하려면 큰따옴표를 사용하세요.|

<Info>
  **참고:** 모든 is: 및 has: 연산자는 Search API에서 단독으로 사용할 수 없으며, 반드시 다른 절과 함께 사용해야 합니다.

  예: @XDeevelopers has:links
</Info>

|                     |                                                                                                                                                                                                                                                                                                                 |
| :------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| has:geo             | X에서 제공하는 게시물 고유의 지리 위치 데이터가 있는 게시물을 매칭합니다. 이는 “geo” 위도/경도 좌표이거나, 해당 표시 이름, 지리적 폴리곤 및 기타 필드가 포함된 X [“Place”](https://dev.x.com/overview/api/places) 형태의 “location”일 수 있습니다.<br /><br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 반드시 함께 사용해야 합니다.                          |
| has:profile&#95;geo | *사용 가능한 별칭*: has:derived&#95;user&#95;geo<br /><br />실제 값과 관계없이, [Profile Geo](http://support.gnip.com/enrichments/profile_geo.html) 메타데이터가 있는 게시물과 일치합니다.  <br />  <br /><br />**참고:** Search API를 사용할 때에는 이 연산자를 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 함께 사용해야 합니다.                                                |
| has:links           | 이 연산자는 메시지 본문에 링크가 포함된 게시물을 찾습니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 반드시 함께 사용해야 합니다.                                                                                                                                                                       |
| is:retweet          | 규칙과 일치하는 명시적인 리트윗만 전달합니다. 규칙과 일치하는 리트윗을 전달 대상에서 제외하도록 부정할 수도 있으며, 이 경우 원본 콘텐츠만 전달됩니다.<br /><br />이 연산자는 X의 리트윗 기능을 사용한 정식 리트윗만 찾습니다. X의 리트윗 기능을 사용하지 않는 인용 트윗 및 수정된 게시물은 이 연산자로는 일치하지 않습니다.<br /><br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다.             |
| is:reply            | 게시물이 다른 게시물에 대한 답글인지 여부를 기준으로 필터링하는 연산자입니다. 규칙과 일치하는 명시적인 답글만 전달합니다. 이 연산자를 부정형으로 사용해 규칙과 일치하는 답글을 전달 결과에서 제외할 수도 있습니다.<br /><br />이 연산자는 유료 프리미엄 및 Enterprise 검색에서만 제공되며, Sandbox 개발 환경에서는 사용할 수 없습니다.<br /><br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| is:quote            | Quote 트윗만 전달하거나, 게시물 페이로드에서 &quot;is&#95;quote&#95;status&quot;:true 로 표시된 다른 게시물을 참조하는 게시물만 전달합니다. Quote 트윗을 제외하도록 부정하여 사용할 수도 있습니다.  <br /><br />**Note:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자들과 함께 사용해야 합니다.                                                                            |
| is:verified         | 작성자가 X에 의해 ‘인증됨’ 상태인 게시물만 반환합니다. 또한 부정을 사용하여 작성자가 인증된 게시물을 제외할 수도 있습니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다.                                                                                                                                     |
| has:mentions        | 다른 X 사용자를 멘션하는 게시물과 일치합니다.  <br />  <br /><br />**참고:** Search API를 사용할 때는 이 연산자를 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 함께 사용해야 합니다.                                                                                                                                                                                 |
| has:hashtags        | 해시태그가 포함된 게시물과 일치합니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자들과 함께 사용해야 합니다.                                                                                                                                                                                      |
| has:media           | *사용 가능한 별칭*: has:media&#95;link<br /><br />X에서 미디어 URL로 분류한 URL을 포함하는 게시물과 일치합니다. 예: pic.x.com.  <br />  <br /><br />**참고:** Search API를 사용할 때는 이 연산자를 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 함께 사용해야 합니다.                                                                                                            |
| has:images          | X에서 분류한 미디어 URL을 포함하는 게시물을 찾습니다. 예: pic.x.com.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 함께 사용해야 합니다.                                                                                                                                                              |
| has:videos          | *사용 가능한 별칭*: has:video&#95;link<br /><br />X에 직접 업로드된 네이티브 X 동영상이 포함된 게시물과 일치합니다. Vine, Periscope에서 생성된 동영상이나 다른 동영상 호스팅 사이트로의 링크가 포함된 게시물에는 일치하지 않습니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다.                                                     |
| has:symbols         | 앞에 ‘$’ 문자가 붙은 캐시태그(예: $tag)가 포함된 게시물과 일치합니다. 이 연산자는 `enterprise` 검색 API에서만 사용할 수 있습니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 함께 사용해야 합니다.                                                                                                                      |

<div id="product-overview">
  ### 제품 개요
</div>

Enterprise 등급의 전체 아카이브 검색(Full-archive Search)은 2015년 8월에 출시되었고, 프리미엄 등급 버전은 2018년 2월에 출시되었습니다. 이 검색 제품을 사용하면 고객은 공개적으로 제공되는 모든 게시물에 즉시 액세스할 수 있습니다. Full-archive Search를 사용하면 단일 쿼리를 전송하고, 클래식 RESTful 방식으로 응답을 받게 됩니다. Full-archive Search는 응답당 최대 500개의 게시물을 반환하는 페이지네이션을 구현하며, 프리미엄의 경우 분당 최대 60회(rpm), Enterprise의 경우 분당 최대 120회(rpm)까지 rate limit를 지원합니다. 이러한 특성 덕분에 Full-archive Search는 동시 요청을 활용해 게시물을 빠르고 대규모로 검색하는 데 사용할 수 있습니다.

디스크에 있는 게시물 플랫 파일 세트에 기반한 아카이브를 사용하는 Historical PowerTrack과 달리, Full-archive Search 게시물 아카이브는 온라인 데이터베이스와 매우 비슷합니다. 모든 데이터베이스와 마찬가지로, 그 내용에 대해 쿼리를 수행할 수 있습니다. 또한 고성능 데이터 검색을 가능하게 하는 *인덱스(index)* 를 사용합니다. Full-archive Search 엔드포인트에서는 쿼리 언어가 PowerTrack Operator로 구성되며, 각 Operator는 인덱싱된 게시물 JSON 속성에 대응합니다.

또한 Historical PowerTrack과 마찬가지로, 쿼리를 수행하는 시점을 기준으로 최신 값이 적용되는 게시물 속성이 있습니다. 예를 들어, 오늘 Search API를 사용해 2010년에 게시된 게시물에 액세스하는 경우, 해당 사용자의 프로필 설명, 계정 ‘home’ 위치, 표시 이름, 그리고 즐겨찾기(Favorites) 및 리트윗(Retweet) 개수에 대한 게시물 메트릭은 2010년 당시가 아니라 오늘 시점의 값으로 반영됩니다. 

<div id="metadata-timelines">
  ### 메타데이터 타임라인
</div>

아래는 Full-archive search 엔드포인트 Operator가 매칭을 시작한 시점에 대한 타임라인입니다. 일부 경우에는 Operator 매칭이 X에서 특정 ‘커뮤니케이션 관행’이 일반화된 이후에야 *상당히 뒤늦게* 시작되었습니다. 예를 들어, @Replies는 2006년에 사용자 관행으로 등장했지만, 2007년 초가 되어서야 ‘지원하는’ JSON과 함께 *일급 객체* 또는 &#95;이벤트&#95;가 되었습니다. 따라서 2006년의 @Replies에 대한 매칭은 `to:` 및 `in_reply_to_status_id:` PowerTrack Operator에 의존하기보다는, 게시물 본문을 직접 검토해야 합니다.

여기에 제공된 세부 정보는 Full-Archive Search(수백 번의 검색을 기반으로 생성된 결과)를 사용해 도출되었습니다. 이 타임라인은 100% 완전하거나 정확하지는 않습니다. 사용 사례에 근본적인 다른 필터링/메타데이터의 “시작일(born on date)”을 확인하신 경우, 알려주시기 바랍니다.

기본이 되는 Search 인덱스는 재구성될 수 있다는 점에 유의하십시오. 따라서 이 타임라인의 세부 정보는 변경될 수 있습니다.

<div id="2006">
  #### 2006
</div>

* 3월 26일 - `lang:`. 검색 인덱스를 생성하는 동안 게시물 메타데이터를 소급 채우기(backfill)하는 예입니다.
* 7월 13일 - `has:mentions` 매칭이 시작됩니다.
* 10월 6일 - `has:symbols`. 주식 종목을 논의할 때 사용하는 $캐시태그(cashtag)(또는 심볼)은 2009년 초가 되어서야 일반적으로 사용됩니다. 그 전까지는 대부분의 사용이 아마 속어(예: $slang)였을 것입니다.
* 10월 26일 - `has:links` 매칭이 시작됩니다.
* 11월 23일 - `has:hashtags` 매칭이 시작됩니다.

<div id="2007">
  #### 2007
</div>

* 1월 30일 - 최초의 정식 @reply(`in_reply_to_user_id`) 도입, `reply_to_status_id:` 값 매칭이 시작됨.
* 8월 23일 - 해시태그가 주제와 대화를 정리하는 일반적인 관례로 등장. 일주일 뒤 첫 실제 사용이 나타남.

<div id="2009">
  #### 2009
</div>

* 5월 15일 - `is:retweet`. 이 연산자는 공식 리트윗의 ‘beta’ 릴리스와 해당 “Via @” 패턴부터 매칭되기 시작합니다. 이 베타 기간 동안에는 Post 동사가 ‘post’로 설정되어 있으며, 원본 게시물은 페이로드에 포함되지 않습니다.
* 8월 13일 - 공식 리트윗의 최종 버전이 “RT @” 패턴, 동사가 ‘share’로 설정된 상태, 그리고 원본 게시물을 포함하는 ‘retweet&#95;status’ 속성과 함께 릴리스됩니다(이로 인해 JSON 페이로드 크기가 대략 두 배가 됩니다).

<div id="2010">
  #### 2010
</div>

* 3월 6일 - `has:geo`, `bounding_box:` 및 `point_radius:` 지리 연산자가 일치 검색을 지원하기 시작합니다.
* 8월 28일 - `has:videos` (2015년 2월까지 이 연산자는 youtube.com, vimeo.com, vivo.com 등의 일부 동영상 호스팅 사이트로 연결되는 링크가 포함된 게시물과 일치합니다).

<div id="2011">
  #### 2011
</div>

* 7월 20일 - `has:media` 및 `has:images`가 매칭되기 시작했습니다. 네이티브 사진 기능은 2010년 8월 9일 공식 발표되었습니다.

<div id="2014">
  #### 2014
</div>

* 12월 3일경 - HTML 제목과 설명을 포함하는 *일부* [강화된 URL 메타데이터](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)가 페이로드에 포함되기 시작했습니다. 강화된 메타데이터는 2016년 5월에 보다 완전한 형태로 본격 도입되었습니다.

<div id="2015">
  #### 2015
</div>

* 2월 10일 - `has:videos`는 ‘네이티브’ X 동영상과 일치하기 시작합니다.
* 2월 17일 - `has:profile_geo`, `profile_country:`, `profile_region:`, `profile_locality:` [Profile Geo](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments#profile-geo) 연산자가 일치하기 시작합니다.
* 2월 17일 - `place_country:` 및 `place:` 게시물 위치(geo) 연산자가 일치하기 시작합니다.

<div id="2016">
  #### 2016
</div>

* 5월 1일 - [강화된 URL 메타데이터](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)가 보다 폭넓게 제공되었으며, [2016년 8월 Gnip 2.0 출시](https://blog.x.com/2016/gnip-2-is-here)의 일환으로 공식 발표되었습니다. Search API에서는 이러한 메타데이터를 위한 관련 Operator가 없습니다.

<div id="2017">
  #### 2017
</div>

* 2월 22일 - 투표 메타데이터가 Enriched Native 형식으로 제공되기 시작했습니다. 이 메타데이터와 연관된 연산자(Operator)는 없습니다.

<div id="2022">
  #### 2022
</div>

* 9월 27일 - 이 날짜 이후에 생성된 모든 게시물 객체에는 게시물 편집 메타데이터가 제공됩니다. 게시물 객체를 제공하는 모든 Enterprise 엔드포인트는 이 날짜부터 해당 메타데이터를 제공하도록 업데이트되었습니다. 제공되는 편집 메타데이터에는 `edit_history` 및 `edit_controls` 객체가 포함됩니다. 이 메타데이터는 2022년 9월 27일 이전에 생성된 게시물에는 반환되지 않습니다. 현재 이 메타데이터에 대응하는 Enterprise Operators는 제공되지 않습니다. 게시물 편집 메타데이터에 대해 자세히 알아보려면 [Edit Posts fundamentals](/ko/x-api/fundamentals/edit-posts) 페이지를 참조하세요.

<div id="2022">
  #### 2022
</div>

* 9월 29일 - 이 날짜 이후에 생성된 모든 게시물 객체에는 게시물 편집 메타데이터가 제공됩니다. 게시물 객체를 제공하는 모든 Enterprise 엔드포인트는 이 날짜부터 해당 메타데이터를 제공하도록 업데이트되었습니다. 제공되는 편집 메타데이터에는 `edit_history` 및 `edit_controls` 객체가 포함됩니다. 이 메타데이터는 2022년 9월 27일 이전에 생성된 게시물에는 반환되지 않습니다. 현재 이러한 메타데이터를 기준으로 사용할 수 있는 Enterprise 연산자는 제공되지 않습니다. 게시물 편집 메타데이터에 대해 더 알아보려면 [게시물 편집 기본 사항](/ko/x-api/fundamentals/edit-posts) 페이지를 참조하세요.

<div id="filtering-tips">
  ### 필터링 팁
</div>

위에서 설명한 타임라인 정보를 종합해 보면, Search API 필터를 작성할 때 고려해야 할 세부 사항이 매우 많다는 것을 알 수 있습니다. 특히 다음 두 가지를 유념해야 합니다.

* 일부 메타데이터에는 ‘생성 시점(born-on)’이 있기 때문에, 필터 결과에 &#95;거짓 부정(false negative)&#95;이 발생할 수 있습니다. 이런 검색에는 검색 기간 전체 또는 일부에 대해 존재하지 않았던 메타데이터에 의존하는 Operator들이 포함됩니다. 예를 들어 `has:images` Operator를 사용해 게시물을 검색하는 경우, 2011년 7월 이전 기간에는 일치하는 결과가 없습니다. 이는 해당 Operator가 *네이티브* 사진(X 사용자 인터페이스를 사용해 게시물에 첨부한 사진)에만 매칭되기 때문입니다. 사진 공유 게시물에 대한 보다 완전한 데이터 세트를 얻으려면, 2011년 7월 이전 구간에 대한 필터에는 대표적인 사진 호스팅 서비스 URL에 매칭하는 규칙 절을 포함해야 합니다.
* 일부 메타데이터는 게시물이 X에 게시된 시점 *이후* 의 메타데이터로 보강(backfill)되었습니다.

PowerTrack 쿼리를 만들 때 일반적으로 많이 사용하는 속성 유형은 다음과 같습니다.

* X 프로필
* 원본 또는 공유 게시물
* 게시물 언어 분류
* 지리 정보가 참조된 게시물
* 공유 링크 미디어

이들 중 일부는 제품별로 동작이 다르며, 나머지는 동일한 방식으로 동작합니다. 자세한 내용은 아래를 참고하세요.

<div id="x-profiles">
  #### X 프로필
</div>

Search API는 &#95;조회 시점&#95;의 사용자 프로필 데이터가 설정된 상태로 과거 게시물을 제공합니다. 예를 들어 2014년의 게시물을 요청하더라도, 해당 사용자의 프로필 메타데이터는 조회 시점에 존재하는 상태를 반영합니다.

<div id="original-posts-and-retweets">
  #### 원본 게시물과 리트윗
</div>

PowerTrack `_is:retweet_` 연산자를 사용하면 리트윗을 필터에서 포함할지 제외할지 선택할 수 있습니다. 이 연산자의 사용자는 2009년 8월 이전 데이터에 대해 리트윗 일치(또는 비일치)를 처리하기 위한 두 가지 전략을 사용해야 합니다. 2009년 8월 이전에는 게시물 본문 자체를 대상으로 “@RT ” 패턴과 일치하는지를 정확한 구문 일치 방식으로 검사해야 합니다(보다 구체적으로, 2009년 5월부터 8월 사이의 리트윗을 필터링하는 경우에는 “Via @” 패턴도 포함해야 합니다). 2009년 8월 이후 기간에 대해서는 *is:retweet* 연산자를 사용할 수 있습니다.

<div id="post-language-classifications">
  #### 게시물 언어 분류
</div>

게시물의 언어 분류를 기준으로 필터링할 때, X의 기존 제품들마다 상당한 차이가 있습니다. Search archive가 구축될 당시, 모든 게시물에는 X 언어 분류가 소급 적용(backfill)되었습니다. 따라서 `lang:` 연산자는 전체 게시물 아카이브에서 사용할 수 있습니다.

<div id="geo-referencing-posts">
  #### 게시물의 지리 정보(Geo) 참조
</div>

게시물에 지리 정보를 참조하는 주요 방법은 세 가지입니다.

* **게시물 메시지 내 지리적 참조.** 게시물 메시지 안에 포함된 지리적 참조를 기준으로 일치시키는 방법입니다. 지역에 대한 현지 지식에 의존해야 하므로 가장 까다로운 방법인 경우가 많지만, 전체 게시물 아카이브에 적용할 수 있는 방법입니다. 샌프란시스코 지역을 대상으로 ‘golden gate’ 필터를 사용해 2006년에 지리 정보가 참조된 일치 사례를 보여 주는 예시는 [여기](https://x.com/biz/statuses/28311)에서 확인할 수 있습니다.

* **사용자가 지오태깅한 게시물.** 검색 API에서는 일부 Geo Operator에 대해 2010년 3월부터, 다른 Operator에 대해서는 2015년 2월부터 지리 정보가 포함된 게시물을 기준으로 일치 검색을 시작할 수 있습니다.

  * 2010년 3월 6일: `has:geo`, `bounding_box:`, `point_radius:`
  * 2015년 2월 17일: `place_country:`, `place:`

* **사용자가 설정한 계정 프로필 ‘home’ 위치.** Profile Geo Operator들은 Historical PowerTrack과 Search API 모두에서 사용할 수 있습니다. Search API에서는 이러한 Profile Geo 메타데이터를 2015년 2월부터 사용할 수 있습니다. Profile Geo 메타데이터가 제공되기 이전에 게시된 게시물에 대해서는, 정규화되지 않은 사용자 입력을 기반으로 일치시킬 수 있는 `bio_location:` Operator를 사용할 수 있습니다.

<div id="shared-links-and-media">
  #### 공유 링크 및 미디어
</div>

2012년 3월에 확장 URL enrichment가 도입되었습니다. 그 이전까지는 게시물 페이로드에 사용자가 제공한 URL만 포함되었습니다. 따라서 사용자가 단축 URL을 포함한 경우, 관심 있는 (확장된) URL과 매칭하기가 어려울 수 있습니다. Search API에서는 이러한 메타데이터가 2012년 3월부터 제공됩니다.

2016년 7월에는 향상된 URL enrichment가 도입되었습니다. 이 향상된 버전은 게시물 페이로드에 웹사이트의 HTML 제목과 설명을 함께 제공하고, 이에 매칭하기 위한 연산자도 함께 제공합니다. 이러한 메타데이터는 2014년 12월부터 나타나기 시작합니다.

2016년 9월에는 X가 ‘네이티브 첨부’ 기능을 도입하여, 뒤에 오는 공유 링크가 140자 게시물 길이 제한에 포함되지 않도록 했습니다. 두 가지 URL enrichment는 여전히 이러한 공유 링크에 적용됩니다.

관련 Search 연산자가 매칭되기 시작한 시점은 다음과 같습니다:

* 2006년 10월 26일 - `has:links`
* 2011년 7월 20일 - `has:images` 및 `has:media`
* 2011년 8월 - `url:` ([Expanded URLs enrichment](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)와 함께). 이미 2006년 9월에는 `(url:"spotify.com" OR url:gnip OR url:microsoft OR url:google OR url:youtube)`가 twitter&#95;entities 및 gnip 객체에 urls[] 메타데이터가 없음에도 불구하고 http://x.com/Adam/statuses/16602 와 매칭됩니다. “youtube.com”은 urls[] 메타데이터 없이도 url:youtube와 매칭되는 메시지 콘텐츠의 한 예입니다.
* 2015년 2월 10일 - 네이티브 비디오용 `has:videos`. 2010/08/28부터 2015/02/10 사이에는 이 연산자가 youtube.com, vimeo.com, vivo.com과 같은 일부 비디오 호스팅 사이트로 연결되는 링크가 포함된 게시물과 매칭됩니다.
* 2016년 5월 1일 - [Enhanced URLs enrichment](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)를 기반으로 한 `url_title:` 및 `url_description:`이 일반적으로 제공되기 시작했습니다. 최초의 Enhanced URL 메타데이터는 2014년 12월에 나타나기 시작했습니다.

<div id="frequently-asked-questionsfaq">
  ## 자주 묻는 질문(FAQ)
</div>

<div id="general-search-post-api-questions">
  ### Search Post API 관련 일반 질문
</div>

<AccordionGroup>
  <Accordion title="data 엔드포인트로 받는 게시물 개수가 counts 엔드포인트에서 확인되는 게시물 개수와 일치하지 않습니다. 왜 이런 차이가 발생하나요?">
    `counts` 엔드포인트와 `data` 엔드포인트가 제공하는 결과 사이에는 이미 알려진 차이점이 있습니다. `counts` 엔드포인트는 사전 컴플라이언스(pre-compliance) 기준으로 동작하기 때문에(삭제된 게시물, scrub geo 처리 등은 반영하지 않음), 두 결과가 서로 일치하지 않을 수 있습니다. 반면 `data` 엔드포인트는 데이터가 전달되는 시점에 컴플라이언스를 준수하며, 모든 컴플라이언스 이벤트를 반영합니다.
  </Accordion>

  <Accordion title="내 쿼리와 일치해야 할 게시물을 받지 못했습니다. 왜 이런 거죠?">
    이러한 일이 발생했을 수 있는 이유로는 다음과 같은 것들이 있습니다.

    1. 예상했던 게시물이 비공개(보호된) 계정에서 작성된 경우
    2. 데이터 endpoint가 모든 컴플라이언스(compliance) 이벤트를 반영하기 때문에(삭제된 게시물, 삭제된 위치 정보(geo) 등은 응답에 포함되지 않습니다).
  </Accordion>

  <Accordion title="내 쿼리가 어떤 게시물과는 일치했는데, 내가 제외하도록 지정한 키워드도 포함되어 있습니다. 왜 이런 일이 발생하나요?">
    이는 프리미엄 규칙 및 필터링을 잘못 사용했기 때문일 가능성이 큽니다. [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering)의 문서를 검토하고, 규칙을 구성할 때 적용되는 제한 사항을 충분히 이해했는지 확인하십시오.
  </Accordion>

  <Accordion title="Search Post API를 처음 사용할 때 사용할 수 있는 라이브러리가 있나요?">
    네, 있습니다. 예를 들면 다음과 같습니다.

    * [Tweepy](http://www.tweepy.org/) - 표준 search/Posts 제품을 사용할 때 유용합니다(Python)
    * [X API](https://github.com/geduldig/TwitterAPI) - 표준 Search Post API를 사용할 때 유용합니다(Python)
    * [Search Posts Python](https://github.com/xdevplatform/search-tweets-python) 및 [Search Posts Ruby](https://github.com/xdevplatform/search-tweets-ruby) - Enterprise(및 v2!) Search Post API에서 사용할 수 있는 두 가지 유용한 도구입니다

    저희가 직접 지원하는 모든 라이브러리는 xdevplatform GitHub 페이지에서 확인할 수 있습니다: [https://github.com/xdevplatform](https://github.com/xdevplatform).

    또한 도움이 될 수 있는 [다른 서드파티 라이브러리](/ko/resources/fundamentals/authentication#oauth-1-0a-2)도 있습니다. 다만, 이들 중 일부는 premium 및 Enterprise 제품과 호환되지 않을 수 있다는 점에 유의해 주세요.
  </Accordion>

  <Accordion title="데이터 엔드포인트에 대한 요청에서 `maxResults` 값으로 설정한 숫자보다 적은 수의 게시물을 받게 되는 경우가 있나요?">
    예. 이 데이터 엔드포인트는 지정한 `maxResults`에 도달하거나 30일이 경과하면 결과를 페이지 단위로 나눕니다.

    예를 들어, 특정 30일 기간에 800개의 게시물이 있다면 전체 결과를 가져오기 위해 두 번의 요청을 해야 합니다. 요청 한 번당 반환할 수 있는 게시물의 최대 개수는 500개이기 때문입니다(`maxResults`). 또한 첫 번째 달에 400개의 게시물, 두 번째 달에 100개의 게시물이 있는 경우에도 전체 결과를 가져오기 위해 두 번의 요청을 사용해야 합니다. 첫 번째 요청에서 반환되는 게시물 수가 지정한 `maxResults`보다 적더라도, 페이지네이션은 30일 기간을 기준으로 이루어지기 때문입니다.
  </Accordion>

  <Accordion title="일치하는 게시물은 어떤 순서로 반환되나요?">
    게시물은 최신순(최근 게시물부터)으로 반환됩니다. 예를 들어, 첫 번째 페이지의 결과에는 쿼리와 일치하는 가장 최근 게시물이 표시되며, 페이지네이션은 결과의 게시 날짜가 처음 요청한 `fromDate`에 도달할 때까지 계속 진행됩니다.
  </Accordion>

  <Accordion title="게시물 편집 기능은 내 사용량과 요금 청구에 어떤 영향을 미치나요?">
    청구 기준에는 원본 게시물만 반영됩니다. 이후에 이루어진 수정은 모두 무시되며 전체 활동 개수에 포함되지 않습니다. 

    `Enterprise`
  </Accordion>

  <Accordion title="Enterprise Search Post API의 가격에 대해 더 알아보고, 이 오퍼링을 신청하려면 어떻게 하면 되나요?">
    당사의 Enterprise 솔루션은 예측 가능한 가격으로 귀사의 비즈니스 요구사항에 맞게 맞춤 제공됩니다. 자세한 내용 확인 및 신청은 [여기](/ko/x-api/enterprise-gnip-2.0/enterprise-gnip)를 이용해 주세요.
  </Accordion>

  <Accordion title="내 사용 사례에 맞는 규칙 세트는 어떻게 구성하나요?">
    * Enterprise Search Post API 문서는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-search-apis)를 참고하세요
    * 규칙과 필터링에 대한 유용한 정보는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#enterprise-operators)에서 확인할 수 있습니다
    * data endpoint 사용에 대한 유용한 정보는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#data-endpoint)에서 확인할 수 있습니다
    * counts endpoint 사용에 대한 유용한 정보는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#counts-endpoint)에서 확인할 수 있습니다
    * 사용 가능한 연산자 목록은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)에서 확인할 수 있습니다
  </Accordion>

  <Accordion title="이번 달 요청 한도/제한을 초과했는데 더 많은 데이터에 접근해야 합니다. 어떻게 해야 하나요?">
    이와 관련해 도움을 받으시려면 X 담당 Account Manager에게 문의해 주세요.
  </Accordion>
</AccordionGroup>

<div id="error-troubleshooting-guide">
  ### 오류 문제 해결 가이드
</div>

**코드 404 - Not Found**

1. 각 endpoint에 맞는 올바른 파라미터를 사용하고 있는지 확인하세요. (예: `buckets` 필드는 data endpoint가 아니라 counts endpoint에서만 사용할 수 있습니다.)
2. `:product`, `:account_name`, `:label` 필드가 올바른지 다시 한 번 확인하세요. GNIP Console(Enterprise 고객 전용)에서 `:label` 필드를 확인할 수 있습니다.

<div id="api-reference">
  ## API 레퍼런스
</div>

<div id="enterprise-search-apis">
  ### Enterprise 검색 APIs
</div>

두 가지 Enterprise 검색 API가 있습니다:

* 30-Day Search API - 지난 30일 이내에 게시된 트윗을 제공합니다.
* Full-Archive Search API - 2006년 3월에 게시된 첫 트윗부터 현재까지의 트윗을 제공합니다.

이 검색 API는 공통 설계를 사용하며, 아래 문서는 두 API 모두에 적용됩니다. 2022년 9월 29일부터 생성된 트윗의 경우, 트윗 객체에는 수정 이력을 설명하는 트윗 편집 메타데이터가 포함됩니다. 자세한 내용은 [&quot;Edit Tweets&quot;](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets) 기본 개념 페이지를 참조하세요.

아래에서는 Enterprise 검색 API 연동 시 필요한 중요한 세부 정보를 확인할 수 있습니다:

* 트윗 데이터 및 개수를 요청하는 메서드
* 인증
* 페이지네이션
* API 요청 파라미터 및 요청 예시
* API 응답 JSON 페이로드 및 응답 예시
* HTTP 응답 코드

Enterprise 검색 API는 트윗 아카이브에 대한 낮은 지연 시간, 손실 없는(full-fidelity), 쿼리 기반 접근을 제공합니다. 두 API 간의 유일한 차이는 검색할 수 있는 기간으로, 직전 30일이거나 2006년부터 현재까지입니다. 기간은 분 단위까지 지정할 수 있습니다. 트윗 데이터는 쿼리에 일치하는 가장 최신 트윗부터 시작하여 역순(최신순)으로 제공됩니다. 트윗은 게시된 후 약 30초 뒤에 검색 API에서 검색할 수 있습니다.

<div id="methods">
  #### Methods
</div>

Enterprise search API의 기본 URI는 `https://gnip-api.x.com/search/` 입니다.

| Method | Description |
| :--- | :--- |
| [POST /search/:product/accounts/:account&#95;name/:label](#SearchRequests) | 지정한 PowerTrack 규칙과 일치하는, 최근 30일 이내의 트윗을 조회합니다. |
| [POST /search/:product/accounts/:account&#95;name/:label/counts](#CountRequests) | 지정한 PowerTrack 규칙과 일치하는, 최근 30일 이내의 트윗 개수를 조회합니다. |

다음은 각 경로 변수에 대한 설명입니다.

* `:product` 는 요청을 보내는 search endpoint를 나타내며, `30day` 또는 `fullarchive` 중 하나입니다.
* `:account_name` 은 console.gnip.com에 표시되는, 계정에 연결된 (대소문자를 구분하는) 이름입니다.
* `:label` 은 console.gnip.com에 표시되는, search endpoint에 연결된 (대소문자를 구분하는) 레이블입니다.

예를 들어 TwitterDev 계정이 레이블이 &#39;prod&#39;(production의 약자)인 30일 search product를 보유하고 있다면, search endpoint는 다음과 같습니다.

* Data endpoint: [https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod.json](https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod.json)
* Counts endpoint: [https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod/counts.json](https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod/counts.json)

완전한 enterprise search API endpoint는 [https://console.gnip.com](https://console.gnip.com)에서 확인할 수 있습니다.

아래에는 curl이라는 간단한 HTTP 유틸리티를 사용한 예시 요청들이 있습니다. 이 예시들은 `:product`, `:account_name`, `:label` 이 포함된 URL을 사용합니다. 이 예시들을 사용할 때에는 URL을 사용자 계정 정보에 맞게 수정해야 합니다.

<div id="authentication">
  #### 인증
</div>

Enterprise search API에 대한 모든 요청은 [https://console.gnip.com](https://console.gnip.com)에서 계정에 로그인할 때 사용하는 유효한 이메일 주소와 비밀번호 조합을 기반으로 한 HTTP &#95;Basic Authentication&#95;을 사용해야 합니다. 자격 증명은 각 요청의 *Authorization* 헤더 값으로 전달되어야 합니다.

<div id="requestresponse-behavior">
  #### 요청/응답 동작
</div>

`fromDate` 및 `toDate` 매개변수를 사용하면 API가 지원하는 원하는 기간을 요청할 수 있습니다. 30-Day search API는 가장 최근 31일치 트윗을 제공합니다(‘30-Day’ API로 불리지만, 사용자가 월 단위로 온전한 기간을 요청할 수 있도록 31일을 제공합니다). Full-Archive search API는 가장 첫 번째 트윗(2006년 3월 21일)까지의 트윗을 제공합니다. 다만, 단일 응답에는 지정한 `maxResults` 값 또는 31일 중 더 작은 범위까지만 포함됩니다. 일치하는 데이터의 양이나 요청한 기간이 지정한 `maxResults` 또는 31일을 초과하는 경우, 나머지 지정 기간을 페이지네이션하는 데 사용해야 하는 `next` 토큰을 받게 됩니다.

예를 들어, Full-Archive search를 사용하면서 2017년 1월 1일부터 2017년 6월 30일까지 쿼리와 일치하는 모든 트윗을 가져오고 싶다고 가정해 보겠습니다. 이 전체 6개월 기간을 요청에 `fromDate` 및 `toDate` 매개변수로 지정합니다. search API는 `maxResults` 매개변수(기본값은 100)에 해당하는 개수만큼의 트윗을 포함하는 첫 번째 ‘페이지’를 응답으로 반환합니다. 더 많은 트윗이 존재한다고 가정하면(대부분 이런 경우가 많습니다), API는 다음 ‘페이지’의 데이터를 요청할 수 있도록 하는 `next` 토큰도 함께 제공합니다. 이 과정은 API가 더 이상 `next` 토큰을 반환하지 않을 때까지 반복됩니다. 자세한 내용은 다음 섹션을 참고하세요.

<div id="pagination">
  #### Pagination
</div>

데이터 요청과 개수 요청을 모두 수행할 때는, 단일 응답으로 반환할 수 있는 것보다 더 많은 데이터가 있을 가능성이 큽니다. 이런 경우 응답에는 ‘next’ 토큰이 포함됩니다. ‘next’ 토큰은 루트 레벨 JSON 속성으로 제공됩니다. ‘next’ 토큰이 제공될 때마다 추가로 가져와야 할 데이터가 있다는 의미이므로, 계속해서 API 요청을 보내야 합니다.

**Note:** ‘next’ 토큰의 동작은 데이터 요청과 개수 요청에서 약간 다르며, 두 경우 모두 아래의 API Reference 섹션에서 예시 응답과 함께 설명합니다.

<div id="data-pagination">
  ##### 데이터 페이지네이션
</div>

데이터에 대한 요청은 단일 응답으로 반환될 수 있는 것보다 더 많은 데이터를 발생시키는 경우가 많습니다. 각 데이터 요청에는 요청당 반환할 트윗 수의 최대값을 설정하는 파라미터가 포함됩니다. 이 `maxResults` 파라미터의 기본값은 100이며, 10–500 범위 내에서 설정할 수 있습니다. 쿼리가 요청에서 사용한 `maxResults` 파라미터 값보다 더 많은 트윗과 일치하는 경우, 응답에는 루트 수준 JSON 속성으로 &#39;next&#39; 토큰이 포함됩니다. 이 &#39;next&#39; 토큰은 이후 요청에서 해당 쿼리에 대해 일치하는 트윗의 다음 부분(즉, 다음 &#39;page&#39;)을 가져오는 데 사용됩니다. &#39;next&#39; 토큰은 해당 쿼리에 대한 마지막 &#39;page&#39;에 도달하여 더 이상 &#39;next&#39; 토큰이 제공되지 않을 때까지 계속 제공됩니다.

다음 &#39;page&#39;의 데이터를 요청하려면, 사용한 경우 `query`, `toDate`, `fromDate` 파라미터를 포함해 원래와 완전히 동일한 쿼리를 만들어야 하며, 이전 응답에서 받은 값으로 설정한 &#39;next&#39; 요청 파라미터도 함께 포함해야 합니다. 이는 GET 또는 POST 요청 중 어느 쪽과도 함께 사용할 수 있습니다. 단, GET 요청의 경우 &#39;next&#39; 파라미터는 URL 인코딩되어야 합니다.

이전 쿼리에서 받은 &#39;next&#39; 요소를 계속 전달해, 쿼리에서 지정한 기간 동안의 모든 트윗을 받을 때까지 요청을 이어갈 수 있습니다. &#39;next&#39; 요소가 포함되지 않은 응답을 받으면, 이는 마지막 페이지에 도달했으며 지정한 쿼리와 기간에 대해 더 이상 사용할 수 있는 데이터가 없음을 의미합니다.

<div id="counts-pagination">
  ##### Counts 페이지네이션
</div>

`counts` 엔드포인트는 쿼리와 연관된 트윗 볼륨을 일 단위, 시간 단위, 혹은 분 단위 기준으로 제공합니다. `counts` API 엔드포인트는 최대 31일 분량의 카운트에 대한 타임스탬프가 포함된 카운트 배열을 반환합니다. 31일을 초과하는 기간의 카운트를 요청하는 경우 `next` 토큰이 제공됩니다. 데이터용 `next` 토큰과 마찬가지로, 원래 요청과 완전히 동일한 쿼리를 다시 사용해야 하며, 이전 응답에서 받은 값을 `next` 요청 매개변수로 함께 보내야 합니다.

31일을 초과하는 카운트를 요청하는 경우 외에도, `next` 토큰이 제공되는 또 다른 상황이 있습니다. 대량 결과를 반환하는 쿼리의 경우, 카운트 생성에 소요되는 시간이 길어져 응답 타임아웃이 발생할 수 있습니다. 이 경우 31일보다 적은 기간의 카운트만 받게 되지만, 전체 카운트 페이로드를 계속 요청할 수 있도록 `next` 토큰이 제공됩니다. ***중요:*** 타임아웃이 발생하면 전체 &quot;버킷&quot;만 반환됩니다. 예를 들어 2.5일 분량의 카운트를 요청한 경우, 2일 분량의 전체 &quot;버킷&quot;으로만 반환됩니다.

<div id="additional-notes">
  ##### 추가 참고 사항
</div>

* 검색 요청에서 fromDate 또는 toDate를 사용할 경우, 지정한 시간 범위 내의 결과만 반환됩니다. 시간 범위 내에서 마지막 결과 그룹에 도달하면 더 이상 &#39;next&#39; 토큰이 반환되지 않습니다.
* &#39;next&#39; 요소는 10–500 사이의 어떤 maxResults 값과도 함께 사용할 수 있으며, 기본값은 100입니다. maxResults는 각 응답에서 반환되는 트윗 개수를 결정하지만, 결국 모든 결과를 가져오는 것을 제한하지는 않습니다.
* &#39;next&#39; 요소는 만료되지 않습니다. 동일한 &#39;next&#39; 쿼리를 사용한 여러 요청은, 요청 시점과 관계없이 동일한 결과를 받습니다.
* &#39;next&#39; 매개변수를 사용해 결과를 페이지 단위로 조회할 때, 쿼리 경계에서 중복 결과가 발생할 수 있습니다. 애플리케이션은 이러한 중복을 허용하도록 구현되어야 합니다.

<div id="data-endpoint">
  #### 데이터 엔드포인트
</div>

<div id="post-searchproductlabel">
  ##### POST /search/:product/:label
</div>

<div id="endpoint-pattern">
  ###### 엔드포인트 패턴:
</div>

이 엔드포인트는 지정된 쿼리와 기간에 해당하는 데이터를 반환합니다. 기간이 지정되지 않으면 시간 파라미터는 기본적으로 최근 30일로 설정됩니다. 참고: 아래에 설명된 파라미터를 URL에 인코딩하면 POST 대신 GET 요청을 사용해도 동일한 기능을 구현할 수 있습니다.

<div id="data-request-parameters">
  ##### 데이터 요청 파라미터
</div>

| Parameters | Description | Required | Sample Value |
| :--- | :--- | :--- | :--- |
| query | 하나의 PowerTrack 규칙에 해당하며, 길이는 최대 2,048자입니다(긍정/부정 절의 개수에는 제한이 없음).  <br />  <br />이 파라미터에는 PowerTrack 규칙의 모든 연산자를 포함한 **전체** 규칙이 포함되어야 하며, 규칙의 일부를 쿼리의 다른 파라미터로 분리해서는 안 됩니다.  <br />  <br />**참고:** 모든 PowerTrack 연산자가 지원되는 것은 아닙니다. 지원되는 연산자는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)에 나열되어 있습니다. | Yes | (snow OR cold OR blizzard) weather |
| tag | 태그는 규칙과 해당 규칙과 일치하는 데이터를 서로 다른 논리적 그룹으로 분리하는 데 사용할 수 있습니다. 규칙 태그를 지정하면 해당 태그가 &#39;matching&#95;rules&#39; 속성에 포함됩니다.  <br />  <br />규칙별 UUID를 규칙 태그에 할당하고, 원하는 매핑을 클라이언트 측에서 관리할 것을 권장합니다. | No  | 8HYG54ZGTU |
| fromDate | 트윗이 제공될 수 있는 가장 오래된 UTC 타임스탬프입니다(Full-Archive 검색의 경우 2006년 3월 21일까지). 타임스탬프는 분 단위 정밀도를 가지며, 포함 범위입니다(예: 12:00은 00분을 포함).  <br />  <br />*지정된 경우:* `toDate` 파라미터 없이 fromDate만 사용하는 경우, now( ) 시점부터 fromDate까지 거슬러 올라가며 쿼리에 대한 결과를 제공합니다.  <br />  <br />*지정되지 않은 경우:* fromDate가 지정되지 않으면, API는 now( ) 또는(지정된 경우) toDate 이전 30일 동안의 모든 결과를 제공합니다.  <br />  <br />fromDate와 toDate 파라미터를 모두 사용하지 않으면, API는 요청 시점을 기준으로 가장 최근 30일 동안의 모든 결과를 과거 방향으로 제공합니다. | No  | 201207220000 |
| toDate | 트윗이 제공될 수 있는 가장 최신 UTC 타임스탬프입니다. 타임스탬프는 분 단위 정밀도를 가지며, 비포함 범위입니다(예: 11:59는 해당 시의 59분째를 포함하지 않음).  <br />  <br />*지정된 경우:* fromDate 파라미터 없이 toDate만 사용하는 경우, toDate 이전 최근 30일 동안의 데이터를 제공합니다.  <br />  <br />*지정되지 않은 경우:* toDate가 지정되지 않으면, API는 now( )부터 fromDate까지 거슬러 올라가며 쿼리에 대한 모든 결과를 제공합니다.  <br />  <br />fromDate와 toDate 파라미터를 모두 사용하지 않으면, API는 요청 시점을 기준으로 전체 30일 인덱스 범위에 대한 모든 결과를 과거 방향으로 제공합니다. | No  | 201208220000 |
| maxResults | 요청에서 반환할 검색 결과의 최대 개수입니다. 10과 시스템 한도(현재 500) 사이의 숫자여야 합니다. 기본적으로 요청 응답은 100개의 결과를 반환합니다. | No  | 500 |
| next | 이 파라미터는 [여기](#Pagination)에 설명된 대로 다음 &#39;페이지&#39;의 결과를 가져오는 데 사용됩니다. 이 파라미터에 사용할 값은 API가 제공한 응답에서 직접 가져와야 하며, 수정해서는 안 됩니다. | No  | NTcxODIyMDMyODMwMjU1MTA0 |

<div id="additional-details">
  ###### 추가 세부 정보
</div>

|     |     |
| :--- | :--- |
| **사용 가능 기간** | 30-Day: 최근 31일  <br />Full-Archive: 2006년 3월 21일 - 현재 |
| **쿼리 형식** | 최대 2,048자까지의 하나의 PowerTrack 규칙과 동일합니다(포함 및 제외 절의 개수에는 제한이 없습니다).  <br />  <br />**참고:** 모든 PowerTrack 연산자가 지원되는 것은 아닙니다. 지원되는 연산자 목록은 [Available operators](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)를 참조하세요. |
| **요청 한도** | 파트너에는 분 단위와 초 단위 두 수준의 요청 한도가 적용됩니다. 분당 요청 한도는 계약서에 명시된 대로 파트너별로 다릅니다. 다만 이 분당 요청 한도는 한 번에 몰아서(버스트 형태로) 사용하는 것을 전제로 하지는 않습니다. 분당 요청 한도와 관계없이, 모든 파트너는 데이터 및/또는 카운트에 대한 모든 요청을 합산하여 초당 최대 20개의 요청으로 제한됩니다. |
| **규정 준수** | Full-Archive Search API를 통해 제공되는 모든 데이터는 제공 시점에 규정 준수 상태입니다. |
| **실시간 가용성** | 데이터는 Twitter Platform에서 생성된 후 30초 이내에 인덱스에서 사용할 수 있습니다. |

<div id="example-data-requests-and-responses">
  ##### 데이터 요청 및 응답 예시
</div>

<div id="example-post-request">
  ###### POST 요청 예시
</div>

* POST 요청의 요청 파라미터는 아래 예시와 같이 JSON 형식의 본문으로 전송됩니다.
* 조회하려는 PowerTrack 규칙의 모든 구성 요소(예: 키워드, bounding&#95;box:와 같은 기타 연산자)는 &#39;query&#39; 매개변수에 포함해야 합니다.
* 규칙의 일부를 쿼리 URL의 개별 매개변수로 분리하지 마십시오.

다음은 초기 데이터 요청을 보내기 위한 POST(cURL 사용) 명령 예시입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label.json" -d '{"query":"from:twitterDev","maxResults":500,"fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm"}'
```

API 데이터 응답에 &#39;next&#39; 토큰이 포함된 경우, 아래는 원래 요청을 기반으로 &#39;next&#39; 매개변수에 제공된 토큰을 설정한 후속 요청의 예시입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label.json" -d '{"query":"from:twitterDev","maxResults":500,"fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm",
    "next":"NTcxODIyMDMyODMwMjU1MTA0"}'
```

<div id="example-get-request">
  ###### 예시 GET 요청
</div>

* GET 요청의 요청 파라미터는 표준 URL 인코딩 방식을 사용하여 URL에 인코딩됩니다.
* 조회하려는 PowerTrack rule의 모든 구성 요소(예: 키워드, bounding&#95;box:와 같은 기타 operator)는 &#39;query&#39; 파라미터에 넣어야 합니다.
* 쿼리 URL에서 rule의 일부를 별도의 파라미터로 분리하지 마십시오.

다음은 초기 데이터 요청을 수행하기 위한 예시 GET(cURL 사용) 명령입니다:

```bash
    curl -u<username> "http://gnip-api.x.com/search/:product/accounts/:account_name/:label.json?query=from%3Atwitterdev&maxResults=500&fromDate=yyyymmddhhmm&toDate=yyyymmddhhmm"
```

<div id="example-data-responses">
  ###### 예시 데이터 응답
</div>

2022년 9월 29일부터 생성된 트윗 객체에는 해당 트윗의 수정 이력을 설명하는 트윗 수정 메타데이터가 포함됩니다. 자세한 내용은 [&quot;트윗 수정&quot;](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets) 기본 사항 페이지를 참조하세요.

아래는 데이터 쿼리에 대한 예시 응답입니다. 이 예시는 사용 가능한 트윗이 &#39;maxResults&#39; 값보다 많아서 이후 요청을 위해 &#39;next&#39; 토큰이 제공되는 경우를 가정합니다. 쿼리와 연관된 트윗이 &#39;maxResults&#39; 이하인 경우, 응답에 &#39;next&#39; 토큰은 포함되지 않습니다.
&#39;next&#39; 요소의 값은 각 쿼리마다 변경되며, 별도의 의미를 해석하지 않는 임의의 문자열로 취급해야 합니다. 응답 본문에서 &#39;next&#39; 요소는 다음과 같은 형태로 표시됩니다:

```json
{
    "results":
      [
            {--트윗 1--},
            {--트윗 2--},
            ...
            {--트윗 500--}
      ],
    "next":"NTcxODIyMDMyODMwMjU1MTA0",
    "requestParameters":
      {
        "maxResults":500,
        "fromDate":"201101010000",
        "toDate":"201201010000"
      }
  }
```

이후 요청에 대한 응답은 다음과 같을 수 있습니다(새 트윗과 변경된 &#39;next&#39; 값에 주목하세요).

```json
{
      "results":
      [
            {--Tweet 501--},
            {--Tweet 502--},
            ...
            {--Tweet 1000--}
      ],
      "next":"R2hCDbpBFR6eLXGwiRF1cQ",
      "requestParameters":
      {
        "maxResults":500,
        "fromDate":"201101010000",
        "toDate":"201201010000"
      }
  }
```

이전 쿼리의 응답에서 받은 &#39;next&#39; 요소를 계속 전달해, 쿼리에서 지정한 기간에 포함된 모든 트윗을 수신할 때까지 요청을 이어갈 수 있습니다. &#39;next&#39; 요소가 포함되지 않은 응답을 받으면 마지막 페이지에 도달했다는 의미이며, 지정한 기간 내에 더 이상 사용할 수 있는 추가 데이터가 없습니다.

<div id="counts-endpoint">
  #### Counts 엔드포인트
</div>

<div id="searchstreamcounts">
  ##### /search/:stream/counts
</div>

<div id="endpoint-pattern">
  ###### 엔드포인트 패턴:
</div>

`/search/fullarchive/accounts/:account_name/:label/counts.json`

이 엔드포인트는 지정된 쿼리에 대한 개수(데이터 볼륨) 데이터를 반환합니다. 기간이 지정되지 않으면 시간 관련 파라미터는 기본적으로 최근 30일로 설정됩니다. 데이터 볼륨은 일 단위, 시간 단위(기본값), 또는 분 단위 중 하나로 타임스탬프가 포함된 배열로 반환됩니다.

**참고:** 아래에 설명된 파라미터를 URL에 인코딩하면, POST 대신 GET 요청으로도 동일한 기능을 사용할 수 있습니다.

<div id="counts-request-parameters">
  ##### Counts request parameters
</div>

| Parameters | Description | Required | Sample Value |
| :--- | :--- | :--- | :--- |
| query | 최대 2,048자까지 사용할 수 있는 하나의 PowerTrack rule에 해당하며(긍정/부정 절의 개수에는 제한이 없습니다).  <br />  <br />이 파라미터에는 모든 연산자(operator)를 포함한 PowerTrack rule의 모든 부분이 포함되어야 하며, rule의 일부를 query의 다른 파라미터로 분리해서는 안 됩니다.  <br />  <br />**참고:** 모든 PowerTrack operator가 지원되는 것은 아닙니다. 지원되는 operator 목록은 [Available operators](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)를 참조하세요. | Yes | (snow OR cold OR blizzard) weather |
| fromDate | 트윗이 제공될 수 있는 가장 오래된 UTC 타임스탬프(최대 2006년 3월 21일까지)입니다. 타임스탬프는 분 단위 정밀도를 가지며, 포함 범위입니다(예: 12:00은 00분을 포함).  <br />  <br />*지정한 경우:* `fromDate`만 사용하고 `toDate` 파라미터를 사용하지 않으면, API는 현재 시점부터 `fromDate`까지 거슬러 올라가면서 쿼리에 대한 카운트(데이터 볼륨)를 제공합니다. `fromDate`가 현재 시점(now())으로부터 31일보다 이전인 경우, 요청 결과를 페이지네이션할 수 있도록 `next` 토큰을 받게 됩니다.  <br />  <br />*지정하지 않은 경우:* `fromDate`를 지정하지 않으면, API는 현재 시점(now()) 또는(지정된 경우) `toDate`로부터 30일 이전까지의 카운트(데이터 볼륨)를 제공합니다.  <br />  <br />`fromDate`와 `toDate` 파라미터를 모두 사용하지 않으면, API는 요청 시점부터 과거로 거슬러 올라가며 가장 최근 30일에 대한 카운트(데이터 볼륨)를 제공합니다. | No  | 201207220000 |
| toDate | 트윗이 제공될 수 있는 가장 최신 UTC 타임스탬프입니다. 타임스탬프는 분 단위 정밀도를 가지며, 비포함 범위입니다(예: 11:59는 해당 시의 59분을 포함하지 않음).  <br />  <br />*지정한 경우:* `toDate`만 사용하고 `fromDate` 파라미터를 사용하지 않으면, `toDate`로부터 30일 이전까지의 가장 최근 카운트(데이터 볼륨)를 제공합니다.  <br />  <br />*지정하지 않은 경우:* `toDate`를 지정하지 않으면, API는 `fromDate`까지 거슬러 올라가면서 쿼리에 대한 카운트(데이터 볼륨)를 제공합니다. `fromDate`가 현재 시점(now())으로부터 31일보다 이전인 경우, 요청 결과를 페이지네이션할 수 있도록 `next` 토큰을 받게 됩니다.  <br />  <br />`fromDate`와 `toDate` 파라미터를 모두 사용하지 않으면, API는 요청 시점부터 과거로 거슬러 올라가며 가장 최근 30일에 대한 카운트(데이터 볼륨)를 제공합니다. | No  | 201208220000 |
| bucket | 카운트 데이터가 제공될 시간 단위입니다. 요청한 기간 동안 일, 시간, 분 단위의 카운트 데이터를 반환할 수 있습니다. 기본적으로 시간 단위 카운트가 제공됩니다. 옵션: &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39; | No  | minute |
| next | 이 파라미터는 [여기](#Pagination)에 설명된 대로 결과의 다음 &#39;page&#39;를 가져오는 데 사용됩니다. 이 파라미터에 사용되는 값은 API가 제공한 응답에서 직접 가져와야 하며, 수정해서는 안 됩니다. | No  | NTcxODIyMDMyODMwMjU1MTA0 |

<div id="additional-details">
  ###### 추가 세부 정보
</div>

|     |     |
| :--- | :--- |
| **사용 가능 기간** | 30-Day: 최근 31일간  <br />Full-Archive: 2006년 3월 21일 ~ 현재 |
| **쿼리 형식** | PowerTrack 규칙 1개에 해당하며, 최대 2,048자까지 사용할 수 있습니다.  <br />  <br />**참고:** 모든 PowerTrack 연산자가 지원되는 것은 아닙니다. 지원되는 연산자 목록은 [사용 가능한 연산자](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)를 참고하세요. |
| **요청 한도** | 파트너는 분 단위와 초 단위 두 수준 모두에서 요청 한도가 적용됩니다. 분당 요청 한도는 계약서에 명시된 대로 파트너별로 달라집니다. 다만 이러한 분당 요청 한도는 짧은 시간에 한꺼번에 소진하도록 설계된 것은 아닙니다. 분당 요청 한도와 관계없이, 모든 파트너는 데이터 및/또는 개수에 대한 모든 요청을 합산하여 초당 최대 20개의 요청으로 제한됩니다. |
| **개수 정밀도** | 이 엔드포인트를 통해 제공되는 개수는 실제로 발생한 트윗 수를 반영하며, 이후의 컴플라이언스 이벤트(삭제, 위치 정보 제거 등)는 반영하지 않습니다. 집계에 포함된 일부 트윗은 이용자 컴플라이언스 조치로 인해 데이터 엔드포인트를 통해 더 이상 제공되지 않을 수 있습니다. |

<div id="example-counts-requests-and-responses">
  ##### 개수 요청 및 응답 예시
</div>

<div id="example-post-request">
  ###### POST 요청 예시
</div>

* POST 요청의 매개변수는 아래와 같이 JSON 형식의 본문(body)에 담아 전송됩니다.
* 조회하려는 PowerTrack 규칙의 모든 구성 요소(예: 키워드, `bounding_box:`와 같은 기타 operator)는 `query` 매개변수에 포함해야 합니다.
* 규칙의 일부를 쿼리 URL의 별도 매개변수로 분리하지 마십시오.

다음은 초기 counts 요청을 보낼 때 사용할 수 있는 POST(cURL 사용) 명령 예시입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label/counts.json" -d '{"query":"TwitterDev","fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm","bucket":"day"}'
```

API counts 응답에 &#39;next&#39; 토큰이 포함되어 있다면, 아래 예시는 제공된 토큰을 &#39;next&#39; 매개변수로 설정한 후속 요청으로, 원래 요청에 이를 추가한 것입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label/counts.json" -d '{"query":"TwitterDev","fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm","bucket":"day",
    "next":"YUcxO87yMDMyODMwMjU1MTA0"}'
```

<div id="example-get-request">
  ###### 예시 GET 요청
</div>

* GET 요청의 요청 매개변수는 표준 URL 인코딩을 사용하여 URL에 인코딩됩니다.
* 조회하려는 PowerTrack 규칙의 모든 부분(예: 키워드, bounding&#95;box:와 같은 기타 연산자)은 `query` 매개변수에 포함되어야 합니다.
* 쿼리 URL에서 규칙의 일부를 별도의 매개변수로 분리하지 마세요.

다음은 counts 요청을 처음 보낼 때 사용하는 GET(cURL 사용) 명령 예시입니다:

```bash
    curl -u<username> "http://gnip-api.x.com/search/fullarchive/accounts/:account_name/:label/counts.json?query=TwitterDev&bucket=day&fromDate=yyyymmddhhmm&toDate=yyyymmddhhmm"
```

<div id="example-counts-responses">
  #### counts 응답 예시
</div>

아래는 counts(데이터 볼륨) 쿼리에 대한 예시 응답입니다. 이 예시 응답에는 &#39;next&#39; 토큰이 포함되어 있는데, 이는 counts 요청 기간이 31일을 초과했거나, 제출한 쿼리와 연관된 데이터 볼륨이 충분히 커서 부분 응답이 반환되었음을 의미합니다.

&#39;next&#39; 요소의 값은 쿼리마다 달라지며, 불투명한 문자열로 취급해야 합니다. 응답 본문에서 &#39;next&#39; 요소는 다음과 같은 형태로 표시됩니다:

```json
    {
      "results": [
        { "timePeriod": "201101010000", "count": 32 },
        { "timePeriod": "201101020000", "count": 45 },
        { "timePeriod": "201101030000", "count": 57 },
        { "timePeriod": "201101040000", "count": 123 },
        { "timePeriod": "201101050000", "count": 134 },
        { "timePeriod": "201101060000", "count": 120 },
        { "timePeriod": "201101070000", "count": 43 },
        { "timePeriod": "201101080000", "count": 65 },
        { "timePeriod": "201101090000", "count": 85 },
        { "timePeriod": "201101100000", "count": 32 },
        { "timePeriod": "201101110000", "count": 23 },
        { "timePeriod": "201101120000", "count": 85 },
        { "timePeriod": "201101130000", "count": 32 },
        { "timePeriod": "201101140000", "count": 95 },
        { "timePeriod": "201101150000", "count": 109 },
        { "timePeriod": "201101160000", "count": 34 },
        { "timePeriod": "201101170000", "count": 74 },
        { "timePeriod": "201101180000", "count": 24 },
        { "timePeriod": "201101190000", "count": 90 },
        { "timePeriod": "201101200000", "count": 85 },
        { "timePeriod": "201101210000", "count": 93 },
        { "timePeriod": "201101220000", "count": 48 },
        { "timePeriod": "201101230000", "count": 37 },
        { "timePeriod": "201101240000", "count": 54 },
        { "timePeriod": "201101250000", "count": 52 },
        { "timePeriod": "201101260000", "count": 84 },
        { "timePeriod": "201101270000", "count": 120 },
        { "timePeriod": "201101280000", "count": 34 },
        { "timePeriod": "201101290000", "count": 83 },
        { "timePeriod": "201101300000", "count": 23 },
        { "timePeriod": "201101310000", "count": 12 }
       ],
      "totalCount":2027,
      "next":"NTcxODIyMDMyODMwMjU1MTA0",
      "requestParameters":
        {
          "bucket":"day",
          "fromDate":"201101010000",
          "toDate":"201201010000"
        }
    }
```

후속 요청에 대한 응답은 다음과 같을 수 있습니다(새 counts 타임라인과 변경된 ‘next’ 값에 유의하십시오):

```json
    {
      "results": [
        { "timePeriod": "201102010000", "count": 45 },
        { "timePeriod": "201102020000", "count": 76 },
         ....
        { "timePeriod": "201103030000", "count": 13 }
     ],
     "totalCount":3288,
     "next":"WE79fnakFanyMDMyODMwMjU1MTA0",
     "requestParameters":
        {
          "bucket":"day",
          "fromDate":"201101010000",
          "toDate":"201201010000"
        }
    }
```

이전 쿼리에서 받은 &#39;next&#39; 요소를 계속 전달해서 해당 쿼리 시간 범위에 대한 모든 개수를 받을 때까지 요청을 이어갈 수 있습니다. &#39;next&#39; 요소가 포함되지 않은 응답을 받으면, 마지막 페이지에 도달했으며 지정한 시간 범위에서 추가 개수가 더 이상 제공되지 않는다는 의미입니다.

<div id="http-response-codes">
  #### HTTP 응답 코드
</div>

| Status | Text | Description |
| :--- | :--- | :--- |
| 200 | OK  | 요청이 성공했습니다. JSON 응답은 다음 예시와 유사한 형태입니다. |
| 400 | Bad Request | 일반적으로 이 응답은 요청에 유효하지 않은 JSON이 포함되어 있거나, 요청에서 JSON 페이로드를 전혀 보내지 않은 경우에 발생합니다. |
| 401 | Unauthorized | 유효하지 않은 자격 증명 때문에 HTTP 인증에 실패했습니다. 요청에서 자격 증명을 올바르게 사용하고 있는지 확인하기 위해 console.gnip.com에 해당 자격 증명으로 로그인하세요. |
| 404 | Not Found | 요청이 전송된 URL에서 리소스를 찾을 수 없습니다. 주로 잘못된 URL을 사용한 경우에 발생합니다. |
| 422 | Unprocessable Entity | 쿼리에 유효하지 않은 매개변수가 있기 때문에 반환됩니다(예: 잘못된 PowerTrack 규칙). |
| 429 | Unknown Code | 앱이 연결 요청 한도를 초과했습니다. 해당 JSON 메시지는 다음 예시와 유사한 형태입니다. |
| 500 | Internal Server Error | 서버 측에서 오류가 발생했습니다. 지수 백오프(exponential backoff) 패턴을 사용해 요청을 다시 시도하세요. |
| 502 | Proxy Error | 서버 측에서 오류가 발생했습니다. 지수 백오프(exponential backoff) 패턴을 사용해 요청을 다시 시도하세요. |
| 503 | Service Unavailable | 서버 측에서 오류가 발생했습니다. 지수 백오프(exponential backoff) 패턴을 사용해 요청을 다시 시도하세요. |