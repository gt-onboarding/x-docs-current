---
keywords: ["Account Activity API", "AAA", "웹훅", "계정 이벤트", "사용자 활동", "실시간 이벤트", "활동 구독", "웹훅 이벤트"]
---

<div id="v2-account-activity-api">
  # V2 Account Activity API
</div>

<Note>
  Account Activity API v2는 이제 [**Pro**](https://developer.x.com/en/portal/products)에서 이용하실 수 있습니다!
</Note>

<div id="overview">
  ## 개요
</div>

Account Activity API(AAA)는 웹훅을 통해 X 사용자 계정과 관련된 실시간 이벤트를 수신할 수 있는 기능을 제공합니다. 미리 구성된 웹훅에 특정 사용자 계정을 구독하면, 하나의 연결만으로 여러분이 소유하거나 구독한 하나 이상의 계정에서 발생하는 게시물, 다이렉트 메시지, 좋아요, 팔로우, 차단 등의 다양한 활동에 대한 알림을 애플리케이션에서 받을 수 있습니다.\
이 API는 사용자 동작에 즉시 반응해야 하거나 사용자 활동을 기반으로 최신 상태를 유지해야 하는 애플리케이션을 구축할 때 주로 사용됩니다. 웹훅에 등록된 각 사용자 구독마다 아래에 나열된 모든 관련 활동을 수신하게 됩니다:

<div id="activity-types">
  ## 활동 유형
</div>

* **게시물** (사용자가 작성한)
* **게시물 삭제** (사용자가 삭제한)
* **@멘션** (사용자에 대한)
* **답글** (사용자가 보낸 또는 받은)
* **리포스트** (사용자가 한 또는 사용자에 대한)
* **인용 게시물** (사용자가 작성한 또는 사용자에 대한)
* **인용 게시물의 리포스트** (사용자가 한 또는 사용자에 대한)
* **좋아요** (사용자가 한 또는 사용자에 대한)
* **팔로우** (사용자가 한 또는 사용자에 대한)
* **언팔로우** (사용자가 한 또는 사용자에 대한)
* **차단** (사용자가 한 또는 사용자에 대한)
* **차단 해제** (사용자가 한 또는 사용자에 대한)
* **뮤트** (사용자가 한 또는 사용자에 대한)
* **뮤트 해제** (사용자가 한 또는 사용자에 대한)
* **다이렉트 메시지 전송** (사용자가 보낸)
* **다이렉트 메시지 수신** (사용자가 받은)
* **입력 중 표시** (사용자에게 전송된)
* **읽음 확인** (사용자에게 전송된)
* **구독 취소** (사용자가 한)

**참고**: Account Activity API를 통해서는 홈 타임라인 데이터를 제공하지 않습니다. 이 데이터를 가져오려면 User ID 기준 User Posts 타임라인 엔드포인트를 사용하십시오.

<div id="feature-summary">
  ## 기능 요약
</div>

| Tier | 요금 | 고유 구독 개수 | Webhook 개수 |
| :----- | :----- | :----- | :----- |
| Pro | $5,000 / 월 | 3 | 1 |
| Enterprise | [영업팀 문의](/ko/enterprise/forms/enterprise-api-interest) | 5000+ | 5+ |

이 문서는 v2 Account Activity API 엔드포인트를 사용해 Webhook과 연결된 사용자 구독을 관리하는 방법에 중점을 둡니다.

<div id="manage-subscriptions">
  ## 구독 관리
</div>

Account Activity API는 사용자의 서비스에 구독되어 있는 X 계정과 관련된 이벤트가 발생할 때마다 웹훅 기반 JSON 메시지를 제공합니다. X는 이러한 활동을 사용자가 등록한 웹훅으로 전송합니다. 다음 단계에서는 사용자 계정에 대한 구독을 설정하고 관리하는 방법을 설명합니다.

<Warning>
  Account Activity API v2는 현재 User Auth 2.0을 지원하지 않습니다. 현재 이를 개선 중이며, OAuth 2.0이 지원되면 이 문서를 업데이트할 예정입니다.
</Warning>

<div id="1-create-an-x-app">
  ### 1. X 앱 만들기
</div>

승인된 개발자 계정을 사용해 [developer portal](https://developer.x.com/en/portal/products/enterprise)에서 X 앱을 생성합니다. 회사 명의로 앱을 생성하는 경우, 회사의 X 계정을 사용하세요.

* 앱 페이지의 Permissions 탭에서 &quot;Read, Write, and Access direct messages&quot; 권한을 활성화합니다.
* &quot;Keys and Access Tokens&quot; 탭에서 앱의 **Consumer Key (API Key)**, **Consumer Token (API Secret)**, **Bearer Token** 값을 기록해 두세요.
* 앱의 **Access Token(액세스 토큰)** 및 **Access Token Secret**을 생성합니다. 이는 사용자 계정을 구독하는 데 필요합니다.
* X 로그인(X Sign-in)과 사용자 컨텍스트에 익숙하지 않다면 [Obtaining Access Tokens](https://developer.x.com/en/docs/authentication)를 검토하세요.
* developer portal의 &quot;Apps&quot; 페이지에서 앱의 숫자형 id를 기록해 두세요. 이는 Account Activity API 액세스를 신청할 때 필요합니다.

<div id="2-get-account-activity-api-access">
  ### 2. Account Activity API 액세스 받기
</div>

Account Activity API는 Enterprise 티어에서만 사용할 수 있습니다. Enterprise 액세스를 받으려면 [Developer Portal](https://developer.x.com/en/portal/products/enterprise)을 통해 신청하십시오.

<div id="3-register-a-webhook">
  ### 3. 웹훅 등록
</div>

Account Activity 이벤트를 수신하려면 공개적으로 접근 가능한 HTTPS URL을 가진 웹훅을 등록해야 합니다. 웹훅 consumer 앱을 개발하는 방법, 웹훅을 등록하는 방법, 보안을 구성하는 방법, Challenge-Response Checks(CRC)를 처리하는 방법에 대해서는 V2 Webhooks API 문서를 참고하세요.

* 웹훅이 JSON으로 인코딩된 이벤트 페이로드가 포함된 POST 요청을 처리하도록 설정되어 있는지 확인하십시오.
* 구독을 관리할 때 필요하므로, 웹훅 등록 응답에서 **webhook&#95;id**를 확보해 두십시오.

<div id="4-validate-setup">
  ### 4. 설정 검증
</div>

앱과 webhook이 올바르게 구성되었는지 확인하려면:

* 사용자 계정을 webhook에 구독하도록 설정하세요(아래 &quot;Adding a Subscription&quot;을 참조).
* 앱이 구독한 X 계정 중 하나가 게시한 게시물을 즐겨찾기(Favorite)하세요.
* webhook URL로의 POST 요청을 통해 `favorite_events` payload를 수신해야 합니다.
* **참고**: 구독을 추가한 후 이벤트가 전달되기 시작하기까지 최대 10초가 걸릴 수 있습니다.

<div id="important-notes">
  ### 중요 사항
</div>

* **인증**: 사용자를 구독할 때는 해당 사용자의 계정에 대한 consumer key, consumer secret, access token, access token secret을 사용해야 합니다.
* **Direct Messages**: 모든 수신 및 발신 Direct Message(POST /2/dm&#95;conversations/with/:participant&#95;id/messages를 통해 전송되는 메시지)는 웹훅을 통해 전달되어, 앱이 모든 DM 활동을 인지할 수 있도록 합니다.
* **이벤트 중복**:
  * 두 명의 구독된 사용자가 같은 DM 대화에 있는 경우, 웹훅은 각 사용자마다 한 번씩, 중복된 이벤트를 수신합니다. 이를 구분하기 위해 for&#95;user&#95;id 필드를 사용하십시오.
  * 여러 앱이 동일한 webhook URL과 사용자를 공유하는 경우, 이벤트는 앱당 한 번씩 여러 번 전송됩니다.
  * 앱은 간헐적으로 발생하는 중복 이벤트를 처리할 수 있도록 event ID를 사용해 이벤트를 중복 제거해야 합니다.
* **예제 코드**: 웹훅 이벤트를 표시하는 웹 앱 예시는 [Account Activity API Setup](https://github.com/xdevplatform/account-activity-dashboard-enterprise/tree/master)를 참고하십시오.

<div id="managing-subscribed-users-v2-api">
  ## 구독 사용자 관리 (v2 API)
</div>

유효한 webhook&#95;id가 있는 webhook을 이미 등록했다면, 해당 사용자 계정의 활동을 수신하기 위한 사용자 구독을 관리할 수 있습니다. 다음 엔드포인트를 사용해 구독을 추가, 조회 또는 제거할 수 있습니다.

<div id="adding-a-subscription">
  ### [구독 추가](https://docs.x.com/x-api/account-activity/subscribes-the-provided-application-to-all-events-for-the-provided-user-context-for-all-message-types)
</div>

**엔드포인트**: POST /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all
**설명**: 지정된 webhook을 통해 이벤트를 수신할 수 있도록 인증 사용자에 대한 구독을 생성합니다.
**인증 방식**: OAuthUser (구독 대상 사용자를 나타내는 3-legged OAuth 플로우 필요).

* **Consumer Key**: 예: xvz1evFS...
* **Access Token**: 예: 370773112-GmHxMAgYyLbN...

**경로 매개변수**:

| 매개변수           | 설명                      |
| :------------- | :---------------------- |
| webhook&#95;id | 구독을 연결할 webhook의 ID입니다. |

**요청**:
bash

```
curl --request POST --url 'https://api.twitter.com/2/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all' \
--header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<ACCESS_TOKEN>", oauth_version="1.0"'
```

**응답**:

* **성공 (200 OK)**:
* JSON

```
{
  "data": {
    "subscribed": true
  }
}
```

* **실패 (400 Bad Request)**:

| Reason                      | Description                                     |
| :-------------------------- | :---------------------------------------------- |
| WebhookIdInvalid            | 제공된 webhook&#95;id를 찾을 수 없거나 앱과 연결되어 있지 않습니다.   |
| DuplicateSubscriptionFailed | 해당 사용자에 대한 구독이 지정된 webhook&#95;id에 대해 이미 존재합니다. |
| SubscriptionLimitExceeded   | 앱이 모든 webhook에 대한 구독 한도에 도달했습니다.                |

###

<div id="checking-a-subscription">
  ### [구독 확인](https://docs.x.com/x-api/account-activity/check-if-a-subscription-exists-for-a-given-webhook-and-user)
</div>

**Endpoint**: GET /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all
**Description**: 인증된 사용자가 지정된 webhook을(를) 구독 중인지 확인합니다.
**Authentication**: OAuthUser (3-legged OAuth 플로우 필요).
**Path Parameters**:

| Parameter      | Description         |
| :------------- | :------------------ |
| webhook&#95;id | 확인할 webhook의 ID입니다. |

**Request**:
bash

```
curl --request GET --url 'https://api.twitter.com/2/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all' \
--header 'authorization: OAuth oauth_consumer_key="<CONSUMER_KEY>", oauth_nonce="GENERATED", oauth_signature="GENERATED", oauth_signature_method="HMAC-SHA1", oauth_timestamp="GENERATED", oauth_token="<ACCESS_TOKEN>", oauth_version="1.0"'
```

**응답**:

* **성공 (200 OK)**:
* JSON

```
{
  "data": {
    "subscribed": true // 또는 false
  }
}
```

* **실패 (400 Bad Request)**:

| Reason           | Description                                   |
| :--------------- | :-------------------------------------------- |
| WebhookIdInvalid | 제공된 webhook&#95;id를 찾을 수 없거나 앱과 연관되어 있지 않습니다. |

###

<div id="removing-subscriptions">
  ### [구독 제거](https://docs.x.com/x-api/account-activity/deactivates-a-subscription-for-the-specified-webhook-and-user-id)
</div>

**Endpoint**: DELETE /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all
**Description**: 특정 사용자 ID에 대한 구독을 비활성화하여 webhook으로 전달되는 이벤트를 중지합니다.
**Authentication**: OAuth 2.0 앱 전용 Bearer Token.

* **Bearer Token**: 예: AAAAAAAAAAAA0%2EUifi76ZC9Ub0wn...

**Path Parameters**:

| Parameter      | Description             |
| :------------- | :---------------------- |
| webhook&#95;id | 구독이 포함된 webhook의 ID입니다. |
| user&#95;id    | 구독을 취소할 사용자의 숫자형 ID입니다. |

**Request**:
bash

```
curl --request DELETE --url 'https://api.twitter.com/2/account_activity/webhooks/:WEBHOOK_ID/subscriptions/:USER_ID/all' \
--header 'authorization: Bearer <BEARER_TOKEN>'
```

**응답**:

* **성공(200 OK)**:
* json

```
{
  "data": {
    "subscribed": false
  }
}
```

* **실패 (400 Bad Request)**:

| Reason               | Description                                              |
| :------------------- | :------------------------------------------------------- |
| SubscriptionNotFound | 지정된 user&#95;id에 대해 해당 webhook&#95;id에 대한 구독이 존재하지 않습니다. |
| WebhookIdInvalid     | 제공된 webhook&#95;id를 찾을 수 없거나 앱과 연결되어 있지 않습니다.            |

<div id="viewing-all-subscriptions">
  ### [모든 구독 보기](https://docs.x.com/x-api/account-activity/get-a-list-of-the-current-all-activity-type-subscriptions-for-the-specified-webhook)
</div>

**Endpoint**: GET /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list
**Description**: 지정된 webhook에 현재 구독되어 있는 모든 사용자 ID 목록을 조회합니다.
**Authentication**: OAuth2 앱 전용 Bearer Token.
**Path Parameters**:

| Parameter      | Description                |
| :------------- | :------------------------- |
| webhook&#95;id | 구독 목록을 조회할 webhook의 ID입니다. |

**Request**:
bash

```
curl --request GET --url 'https://api.twitter.com/2/account_activity/webhooks/:WEBHOOK_ID/subscriptions/all/list' \
--header 'authorization: Bearer <BEARER_TOKEN>'
```

**응답**:

* **성공(200 OK)**:
* JSON

```
{
  "data": {
    "application_id": "<your app id>",
    "webhook_id": "<webhook id>",
    "webhook_url": "<the webhook's callback url>",
    "subscriptions": [
      { "user_id": "<user_id_1>" },
      { "user_id": "<user_id_2>" }
    ]
  }
}
```

* **실패 (400 Bad Request)**:

| 이유               | 설명                                               |
| :--------------- | :----------------------------------------------- |
| WebhookIdInvalid | 제공된 webhook&#95;id를 찾을 수 없거나 해당 앱과 연결되어 있지 않습니다. |

###

<div id="subscriptions-count">
  ### [구독 개수(Subscriptions Count)](https://docs.x.com/x-api/account-activity/get-a-count-of-subscriptions-that-are-currently-active-on-your-account)
</div>

**엔드포인트**: GET /2/account&#95;activity/subscriptions/count
**설명**: 활성 구독의 총 개수와 인증에 사용된 앱에 할당된 한도를 반환합니다.
**인증 방식**: OAuth2 앱 전용 Bearer Token.
**요청**:
bash

```
curl --request GET --url 'https://api.twitter.com/2/account_activity/subscriptions/count' \
--header 'authorization: Bearer <BEARER_TOKEN>'
```

**응답**:

* **성공(200 OK)**:
* json

```
{
  "data": {
    "account_name": "<your application name>",
    "provisioned_count": "<subscription limit allocated>",
    "subscriptions_count_all": "<current active subscription count>",
    "subscriptions_count_direct_messages": "0" // DM 전용 구독은 더 이상 지원되지 않습니다
  }
}
```

<div id="replay">
  ## [Replay](https://docs.x.com/x-api/account-activity/request-activity-replay)
</div>

AAAv2는 지정된 시간 범위의 과거 이벤트를 검색하여 웹훅으로 다시 전달할 수 있는 replay 기능을 제공합니다. 이는 다운타임으로 인해 누락된 이벤트를 복구하는 데 유용합니다.

**Endpoint**: POST /2/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all

**Description**: replay 작업을 시작합니다

**Authentication**: OAuth2 App Only Bearer Token

**Path Parameters**:

| Parameter      | Description        |
| :------------- | :----------------- |
| webhook&#95;id | replay를 시작할 웹훅의 ID |

**Query Parameters**:

| Parameter     | Description                                                                                                                                                                                                                 |
| :------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| from&#95;date | 이벤트가 제공될 가장 오래된(시작) UTC 타임스탬프입니다. ‘yyyymmddhhmm’ 형식이어야 합니다. 타임스탬프는 분 단위이며 포함 범위입니다(예: 12:00은 00분을 포함). 유효한 시간은 UTC 기준으로 최근 24시간 이내여야 하고, 현재 시점으로부터 최소 31분 이전이어야 합니다. from&#95;date와 to&#95;date는 약 2시간 이내 범위로 설정할 것을 권장합니다. |
| to&#95;date   | 이벤트가 제공될 가장 최신(종료) UTC 타임스탬프입니다. ‘yyyymmddhhmm’ 형식이어야 합니다. 타임스탬프는 분 단위이며 제외(배타) 범위입니다(예: 12:30은 해당 시각의 30분을 포함하지 않음). 유효한 시간은 UTC 기준으로 최근 24시간 이내여야 하고, 현재 시점으로부터 최소 10분 이전이어야 합니다.                                         |

**Responses**:

Success:

```
200

{
  "for_user_id": "<USER_ID>"
  "replay_event": {
    "job_id": <REPLAY_JOB_ID>",
    "created_at: "yyyy-mm-ddThh:mm:ss.000Z"
  }
}
```

Failures:

| Reason              | Description                                      |
| :------------------ | :----------------------------------------------- |
| QueryParamInvalid   | from&#95;date가 현재 시각 기준 24시간보다 이전입니다.            |
| QueryParamInvalid   | from&#95;date가 to&#95;date보다 더 최근입니다.            |
| QueryParamInvalid   | from&#95;date가 미래 시각입니다.                         |
| QueryParamInvalid   | to&#95;date가 미래 시각입니다.                           |
| QueryParamInvalid   | from&#95;date 또는 to&#95;date의 형식이 올바르지 않습니다.     |
| CrcValidationFailed | CRC 검증 중 webhook URL에서 잘못된 응답이 반환되었습니다.          |
| ReplayConflictError | 지정된 webhook에 대해 재생 작업이 이미 진행 중입니다.               |
| WebhookIdInvalid    | 제공된 webhook&#95;id가 유효하지 않거나 해당 앱과 연결되어 있지 않습니다. |

<div id="job-completed-messages">
  ### 작업 완료 메시지
</div>

리플레이 작업이 성공적으로 완료되면 X가 다음과 같은 작업 완료 이벤트를 전송합니다. 이 이벤트를 수신하면 해당 작업이 종료된 것이며, 다른 작업을 새로 제출할 수 있습니다.

```
{
  "replay_job_status": {
    "webhook_id": "<WEBHOOK_ID>",
    "job_state": "Complete",
    "job_state_description": "Job completed successfully",
    "job_id": "<JOB_ID>"
  }
}
```

작업이 성공적으로 완료되지 않으면 Replay Job을 다시 시도하도록 안내하는 다음 메시지를 반환합니다. 이 이벤트를 수신하면 해당 작업의 실행은 완료된 것이며, 다른 작업을 제출할 수 있습니다.

```
{
  "replay_job_status": {
    "webhook_id": "<WEBHOOK_ID>",
    "job_state": "Incomplete",
    "job_state_description": "작업이 모든 이벤트를 전달하지 못했습니다. 재생 작업을 다시 시도하세요",
    "job_id": "<JOB_ID>"
  }
}
```

<div id="account-activity-data-object-structure">
  ## Account Activity 데이터 객체 구조
</div>

| Object | Details |
| :----- | :----- |
| for&#95;user&#95;id | 이벤트와 관련된 사용자 구독을 식별합니다. |
| is&#95;blocked&#95;by | (조건부) Post 멘션 이벤트의 경우, 언급한 사용자가 구독한 사용자에게 차단되어 있는 때에만 표시됩니다. |
| source | 활동을 수행하는 사용자입니다(예: 팔로우, 차단 또는 뮤트하는 사용자). |
| target | 활동이 적용되는 사용자입니다(예: 팔로우되거나, 차단되거나, 뮤트되는 사용자). |

<div id="available-activities">
  ### 사용 가능한 활동
</div>

| Message Type | Details |
| :----- | :----- |
| tweet&#95;create&#95;events | 게시물, 리트윗, 답글, @멘션, 인용 트윗 또는 인용 트윗의 리트윗에 대한 게시물 상태입니다. |
| favorite&#95;events | 사용자와 대상 사용자가 포함된 좋아요 이벤트입니다. |
| follow&#95;events | 사용자와 대상 사용자가 포함된 팔로우 이벤트입니다. |
| unfollow&#95;events | 사용자와 대상 사용자가 포함된 언팔로우 이벤트입니다. |
| block&#95;events | 사용자와 대상 사용자가 포함된 차단 이벤트입니다. |
| unblock&#95;events | 사용자와 대상 사용자가 포함된 차단 해제 이벤트입니다. |
| mute&#95;events | 사용자와 대상 사용자가 포함된 뮤트 이벤트입니다. |
| unmute&#95;events | 사용자와 대상 사용자가 포함된 뮤트 해제 이벤트입니다. |
| user&#95;event | 사용자가 앱 권한을 제거할 때 발생하는 권한 취소 이벤트입니다(구독 자동 삭제). |
| direct&#95;message&#95;events | 발신 또는 수신된 DM에 대한 DM 상태입니다. |
| direct&#95;message&#95;indicate&#95;typing&#95;events | 사용자와 대상 사용자가 포함된 DM 입력 중 이벤트입니다. |
| direct&#95;message&#95;mark&#95;read&#95;events | 사용자와 대상 사용자가 포함된 DM 읽음 이벤트입니다. |
| tweet&#95;delete&#95;events | 규정 준수를 위한 게시물 삭제 알림입니다. |
| spaces&#95;events | 현재는 지원되지 않습니다. 곧 제공될 예정입니다. |

<div id="payload-examples">
  ## 페이로드 예시
</div>

다음은 각 Account Activity 이벤트별 페이로드 예시입니다.

<div id="tweet_create_events-posts-retweets-replies-quotetweets">
  ### tweet&#95;create&#95;events (게시물, 리트윗, 답글, 인용 트윗)
</div>

```json
{
  "for_user_id": "2244994945",
  "tweet_create_events": [
    {
      <Tweet Object>
    }
  ]
}
```

###

<div id="tweet_create_events-mentions">
  ### tweet&#95;create&#95;events (@멘션)
</div>

```json
{
  "for_user_id": "2244994945",
  "user_has_blocked": "false",
  "tweet_create_events": [
    {
      <Tweet Object>
    }
  ]
}
```

<div id="favorite_events">
  ### favorite&#95;events
</div>

```json
{
  "for_user_id": "2244994945",
  "favorite_events": [{
    "id": "a7ba59eab0bfcba386f7acedac279542",
    "created_at": "Mon Mar 26 16:33:26 +0000 2018",
    "timestamp_ms": 1522082006140,
    "favorited_status": {
      <Tweet Object>
    },
    "user": {
      <User Object>
    }
  }]
}
```

<div id="follow_events">
  ### follow&#95;events
</div>

```json
{
  "for_user_id": "2244994945",
  "follow_events": [{
    "type": "follow",
    "created_timestamp": "1517588749178",
    "target": {
      <User Object>
    },
    "source": {
      <User Object>
    }
  }]
}
```

<div id="unfollow_events">
  ### unfollow&#95;events
</div>

```json
{
  "for_user_id": "2244994945",
  "follow_events": [{
    "type": "unfollow",
    "created_timestamp": "1517588749178",
    "target": {
      <User Object>
    },
    "source": {
      <User Object>
    }
  }]
}
```

<div id="block_events">
  ### block&#95;events
</div>

```json
{
  "for_user_id": "2244994945",
  "block_events": [{
    "type": "block",
    "created_timestamp": "1518127020304",
    "source": {
      <User Object>
    },
    "target": {
      <User Object>
    }
  }]
}
```

<div id="unblock_events">
  ### unblock&#95;events
</div>

```json
{
  "for_user_id": "2244994945",
  "block_events": [{
    "type": "unblock",
    "created_timestamp": "1518127020304",
    "source": {
      <User Object>
    },
    "target": {
      <User Object>
    }
  }]
}
```

<div id="mute_events">
  ### mute&#95;events
</div>

```json
{
  "for_user_id": "2244994945",
  "mute_events": [
    {
      "type": "mute",
      "created_timestamp": "1518127020304",
      "source": {
        <User Object>
      },
      "target": {
        <User Object>
      }
    }
  ]
}
```

<div id="unmute_events">
  ### unmute&#95;events
</div>

```json
{
  "for_user_id": "2244994945",
  "mute_events": [
    {
      "type": "unmute",
      "created_timestamp": "1518127020304",
      "source": {
        <User Object>
      },
      "target": {
        <User Object>
      }
    }
  ]
}
```

<div id="user_event">
  ### user&#95;event
</div>

```json
{
  "user_event": {
    "revoke": {
      "date_time": "2018-05-24T09:48:12+00:00",
      "target": {
        "app_id": "13090192"
      },
      "source": {
        "user_id": "63046977"
      }
    }
  }
}
```

<div id="direct_message_events">
  ### direct&#95;message&#95;events
</div>

```json
{
  "for_user_id": "4337869213",
  "direct_message_events": [{
    "type": "message_create",
    "id": "954491830116155396",
    "created_timestamp": "1516403560557",
    "message_create": {
      "target": {
        "recipient_id": "4337869213"
      },
      "sender_id": "3001969357",
      "source_app_id": "13090192",
      "message_data": {
        "text": "Hello World!",
        "entities": {
          "hashtags": [],
          "symbols": [],
          "user_mentions": [],
          "urls": []
        }
      }
    }
  }],
  "apps": {
    "13090192": {
      "id": "13090192",
      "name": "FuriousCamperTestApp1",
      "url": "https://x.com/furiouscamper"
    }
  },
  "users": {
    "3001969357": {
      "id": "3001969357",
      "created_timestamp": "1422556069340",
      "name": "Jordan Brinks",
      "screen_name": "furiouscamper",
      "location": "Boulder, CO",
      "description": "Alter Ego - X PE 의견은 제 개인 의견입니다",
      "url": "https://t.co/SnxaA15ZuY",
      "protected": false,
      "verified": false,
      "followers_count": 22,
      "friends_count": 45,
      "statuses_count": 494,
      "profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
    },
    "4337869213": {
      "id": "4337869213",
      "created_timestamp": "1448312972328",
      "name": "Harrison Test",
      "screen_name": "Harris_0ff",
      "location": "Burlington, MA",
      "protected": false,
      "verified": false,
      "followers_count": 8,
      "friends_count": 8,
      "statuses_count": 240,
      "profile_image_url_https": "https://abs.twimg.com/sticky/default_profile_images/default_profile_normal.png"
    }
  }
}
```

<div id="direct_message_indicate_typing_events">
  ### direct&#95;message&#95;indicate&#95;typing&#95;events
</div>

```json
{
  "for_user_id": "4337869213",
  "direct_message_indicate_typing_events": [{
    "created_timestamp": "1518127183443",
    "sender_id": "3284025577",
    "target": {
      "recipient_id": "3001969357"
    }
  }],
  "users": {
    "3001969357": {
      "id": "3001969357",
      "created_timestamp": "1422556069340",
      "name": "Jordan Brinks",
      "screen_name": "furiouscamper",
      "location": "Boulder, CO",
      "description": "Alter Ego - X PE opinions-are-my-own",
      "url": "https://t.co/SnxaA15ZuY",
      "protected": false,
      "verified": false,
      "followers_count": 23,
      "friends_count": 47,
      "statuses_count": 509,
      "profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
    },
    "3284025577": {
      "id": "3284025577",
      "created_timestamp": "1437281176085",
      "name": "Bogus Bogart",
      "screen_name": "bogusbogart",
      "protected": true,
      "verified": false,
      "followers_count": 1,
      "friends_count": 4,
      "statuses_count": 35,
      "profile_image_url_https": "https://pbs.twimg.com/profile_images/763383202857779200/ndvZ96mE_normal.jpg"
    }
  }
}
```

<div id="direct_message_mark_read_events">
  ### direct&#95;message&#95;mark&#95;read&#95;events
</div>

```json
{
  "for_user_id": "4337869213",
  "direct_message_mark_read_events": [{
    "created_timestamp": "1518452444662",
    "sender_id": "199566737",
    "target": {
      "recipient_id": "3001969357"
    },
    "last_read_event_id": "963085315333238788"
  }],
  "users": {
    "199566737": {
      "id": "199566737",
      "created_timestamp": "1286429788000",
      "name": "Le Braat",
      "screen_name": "LeBraat",
      "location": "Denver, CO",
      "description": "data by day @X, design by dusk",
      "protected": false,
      "verified": false,
      "followers_count": 299,
      "friends_count": 336,
      "statuses_count": 752,
      "profile_image_url_https": "https://pbs.twimg.com/profile_images/936652894371119105/YHEozVAg_normal.jpg"
    },
    "3001969357": {
      "id": "3001969357",
      "created_timestamp": "1422556069340",
      "name": "Jordan Brinks",
      "screen_name": "furiouscamper",
      "location": "Boulder, CO",
      "description": "Alter Ego - X PE opinions-are-my-own",
      "url": "https://t.co/SnxaA15ZuY",
      "protected": false,
      "verified": false,
      "followers_count": 23,
      "friends_count": 48,
      "statuses_count": 510,
      "profile_image_url_https": "https://pbs.twimg.com/profile_images/851526626785480705/cW4WTi7C_normal.jpg"
    }
  }
}
```

<div id="tweet_delete_events">
  ### tweet&#95;delete&#95;events
</div>

```json
{
  "for_user_id": "930524282358325248",
  "tweet_delete_events": [
    {
      "status": {
        "id": "1045405559317569537",
        "user_id": "930524282358325248"
      },
      "timestamp_ms": "1432228155593"
    }
  ]
}
```

<div id="support-for-longform-posts">
  ## 장문 게시물 지원
</div>

V2 Account Activity API는 이제 280자를 초과하는 **장문** 게시물을 지원합니다. 장문 게시물이 `tweet_create_events` 페이로드에 포함되면 `text` 필드에는 처음 140자(또는 그보다 적은 글자)만 포함되며, `truncated` 필드는 true로 설정됩니다. 게시물의 전체 내용은 다음을 포함하는 `extended_tweet` 객체로 제공됩니다:

* `full_text`: 280자 제한을 초과한 모든 글자를 포함한 게시물의 전체 텍스트입니다.
* `entities`: 전체 텍스트에 나타나는 모든 엔티티(예: 해시태그, URL, 사용자 멘션, 심볼)로, 280번째 문자 이후에 있는 것들도 포함합니다.
* `display_text_range`: 전체 텍스트를 기준으로 표시할 문자 범위입니다.

이를 통해 애플리케이션은 텍스트 후반부에 나타나는 멘션이나 기타 엔티티를 포함해 장문 게시물의 전체 콘텐츠를 처리할 수 있습니다. 아래는 장문 게시물에 대한 `tweet_create_events` 페이로드 예시입니다:

```json
{
  "for_user_id": "1603419180975409153",
  "tweet_create_events": [
    {
      "created_at": "Mon May 19 14:01:46 +0000 2025",
      "id": 1924465506158879000,
      "id_str": "1924465506158878979",
      "text": "안티키테라 메커니즘: 고대 창의성으로의 창 1901년 그리스 안티키테라 섬 인근 로마 선박의 잔해 속에서 발견된… https://t.co/bzbEKj8cd8",
      "display_text_range": [
        0,
        140
      ],
      ...
      "user": {
        ...
      },
      ...
      "extended_tweet": {
        "full_text": "안티키테라 메커니즘: 고대 창의성으로의 창 1901년 그리스 안티키테라 섬 인근 로마 선박의 잔해 속에서 발견된 안티키테라 메커니즘은 세계 최초의 아날로그 컴퓨터로 자주 칭송받습니다. 기원전 100년경으로 거슬러 올라가는 이 정교한 청동 장치는 정교한 설계와 신비로운 목적으로 역사학자, 고고학자, 과학자들을 매료시켜 왔습니다. 이 메커니즘은 복잡한 기어 시스템으로 구성되어 있으며, 당시로서는 놀랍도록 발전된 계산을 수행하도록 세심하게 제작되었습니다. 그 발견은 고대 세계의 기술적 능력에 대한 오랫동안 지속된 가정에 도전했습니다. 안티키테라 메커니즘의 주요 기능은 천문학적인 것으로 보입니다. 태양, 달, 그리고 아마도 행성들의 위치를 예측하고, 월식과 일식을 추적하며, 심지어 올림픽 경기의 날짜까지 계산할 수 있었습니다. 고대 그리스어 비문과 결합된 이 장치의 다이얼과 포인터는 과학적 탐구와 문화 행사 모두를 위한 도구였음을 시사합니다. 19세기 시계 제작과 비교할 만한 정밀도 수준은 헬레니즘 세계 출신으로 추정되는 제작자들의 놀라운 창의성을 강조합니다. 수십 년간의 연구에도 불구하고 많은 질문이 남아 있습니다. 누가, 누구를 위해 만들었을까요? 그것은 독특한 걸작이었을까요, 아니면 역사 속에서 사라진 기계 장치의 더 넓은 전통의 일부였을까요? X선 이미징과 현대 컴퓨팅 기술은 내부 작동에 대해 많은 것을 밝혀냈지만, 그 능력의 전체 범위는 여전히 논쟁 중입니다. 일부는 점성술적 예측에 사용되었다고 제안하는 반면, 다른 이들은 천문학자들을 위한 교육 도구로 봅니다. 안티키테라 메커니즘은 인간의 호기심과 혁신의 증거로서, 고대와 현대 세계를 연결합니다. 그것은 고대에도 사람들이 오늘날 기술의 복잡성에 필적하는 도구로 우주를 이해하려 했음을 상기시켜 줍니다. 그 지속적인 미스터리는 계속해서 경외감과 조사를 불러일으키며, 지금까지 발굴된 가장 놀라운 유물 중 하나로 만듭니다.\n@xai\n@HistoryInPics",
        "display_text_range": [
          0,
          2051
        ],
        "entities": {
          "hashtags": [],
          "urls": [],
          "user_mentions": [
            {
              "screen_name": "xai",
              "name": "xAI",
              "id": 1661523610111193000,
              "id_str": "1661523610111193088",
              "indices": [
                2032,
                2036
              ]
            },
            {
              "screen_name": "HistoryInPics",
              "name": "History Photographed",
              "id": 1582853809,
              "id_str": "1582853809",
              "indices": [
                2037,
                2051
              ]
            }
          ],
          "symbols": []
        }
      },
      ...
      "entities": {
        "hashtags": [],
        "urls": [
          {
            "url": "https://t.co/bzbEKj8cd8",
            "expanded_url": "https://twitter.com/i/web/status/1924465506158878979",
            "display_url": "twitter.com/i/web/status/1…",
            "indices": [
              117,
              140
            ]
          }
        ],
        "user_mentions": [],
        "symbols": []
      },
      ...
    }
  ]
}
```

<div id="account-activity-api-migrating-from-legacy-enterprise-to-v2">
  ## Account Activity API Legacy Enterprise에서 v2로 마이그레이션하기
</div>

[Migration Guide](https://docs.x.com/x-api/account-activity/migrate/overview)를 확인하세요!

<div id="frequently-asked-questions">
  ## 자주 묻는 질문
</div>

**Account Activity API를 사용하면 어떤 장점이 있나요?**

Account Activity API는 웹훅을 사용해, 지속적인 연결(스트리밍 API와 달리)이나 빈번한 폴링(REST API와 달리) 없이 실시간으로 데이터를 전달합니다. 주요 이점은 다음과 같습니다:

* **속도**: X에서 일어나는 속도로 데이터를 전달합니다.
* **단순성**: 단일 웹훅 연결을 통해 게시물, @언급, 답글, 리포스트, 인용 트윗, 좋아요, DM, 팔로우, 차단, 뮤트 등 모든 계정 이벤트를 제공합니다.
* **확장성**: Enterprise 티어에서 관리하는 계정의 모든 활동을 요청 한도나 이벤트 상한 없이 지원합니다.

**Account Activity API용 개발, 스테이징, 운영 환경이 모두 필요한데, 가능한가요?**

가능합니다! 여러 개의 웹훅 URL을 등록하고 [V2 Webhooks API](https://docs.x.com/x-api/webhooks/introduction)를 통해 구독을 개별적으로 관리할 수 있습니다.

**Account Activity API를 설정하는 방법에 대한 단계별 가이드가 있나요?**

있습니다! [웹훅 시작하기 가이드](https://docs.x.com/x-api/webhooks/introduction)와 [Account Activity API 샘플 애플리케이션](https://github.com/m-rosinsky/XWebhookTest/blob/main/app.py)을 참고하세요.

**Account Activity API에는 어떤 인증 방식을 사용해야 하나요?**

인증 요구 사항은 엔드포인트별로 정의되어 있습니다. 자세한 내용은 [인증 섹션](https://developer.x.com/en/docs/authentication)을 확인하세요.

**서로 상호작용하는 여러 사용자에게 구독을 걸어두면 중복 활동을 받게 되나요?**

그렇습니다. 예를 들어 앱이 사용자 A와 사용자 B 모두에 대해 구독되어 있고, 사용자 A가 게시물에서 사용자 B를 언급하면 웹훅은 두 개의 이벤트(각 사용자당 하나)를 수신합니다. 구독을 식별하기 위해 `for_user_id` 필드를 사용하세요.

**내 웹훅에 대한 구독을 생성할 때, 전달되는 활동을 제한하기 위해 엔드포인트의** /all/ **부분을 다른 계정 활동 데이터 오브젝트로 대체할 수 있나요?**

아니요. /all/ 상품만 사용 가능하며, 지원되는 모든 이벤트 유형을 전달합니다.

**세 개의 웹훅에 대한 액세스 권한이 있는 경우, 엔터프라이즈용으로 등록한 각 앱에 대해 세 개의 웹훅을 각각 사용할 수 있나요?**

웹훅 한도는 앱 단위가 아니라 계정 단위로 설정됩니다. 예를 들어 세 개의 웹훅과 두 개의 앱이 있는 경우, 한 앱에는 두 개의 웹훅을, 다른 앱에는 한 개의 웹훅을 사용할 수는 있지만, 앱당 세 개씩 사용할 수는 없습니다.

<div id="account-activity-api-reference-index">
  ## Account Activity API 참조 목차
</div>

| 목적 | V2 Endpoint |
| :----- | :----- |
| 앱을 계정의 이벤트에 구독합니다 | POST /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all |
| 현재 활성 구독의 개수를 반환합니다 | GET /2/account&#95;activity/subscriptions/count |
| 웹훅이 해당 계정에 대해 구독되어 있는지 확인합니다 | GET /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all |
| 현재 활성 구독 목록을 반환합니다 | GET /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/all/list |
| 앱 전용 OAuth를 사용하여 구독을 비활성화합니다 | DELETE /2/account&#95;activity/webhooks/:webhook&#95;id/subscriptions/:user&#95;id/all |
| 리플레이 작업을 생성합니다 | POST /2/account&#95;activity/replay/webhooks/:webhook&#95;id/subscriptions/all |

웹훅 관리 endpoint(등록, 조회, 유효성 검사, 삭제)에 대해서는 [V2 Webhooks API 문서](https://docs.x.com/x-api/webhooks/introduction)를 참고하세요