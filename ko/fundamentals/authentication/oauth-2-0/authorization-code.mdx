---
title: OAuth 2.0 Authorization Code 플로우(PKCE 사용)
sidebarTitle: OAuth 2.0 Authorization Code 플로우(PKCE 사용)
keywords: ["OAuth 2.0 PKCE", "authorization code flow", "PKCE", "OAuth 2.0 flow", "PKCE flow", "OAuth 2.0 authorization", "code challenge"]
---

<div id="oauth-20-authorization-code-flow-with-pkce">
  ### PKCE를 사용하는 OAuth 2.0 Authorization Code Flow
</div>

<div id="introduction">
  #### 소개
</div>

OAuth 2.0은 업계 표준 권한 부여 프로토콜로, 애플리케이션의 스코프(scope)와 여러 기기에 걸친 권한 부여 플로우를 보다 세밀하게 제어할 수 있게 해 줍니다. OAuth 2.0을 사용하면 사용자 대신 특정 권한을 부여하는 세분화된 스코프를 선택할 수 있습니다. 

앱에서 OAuth 2.0을 사용하려면 developer portal의 앱 설정 섹션에 있는 인증 설정에서 OAuth 2.0을 활성화해야 합니다.

<div id="how-long-will-my-credentials-stay-valid">
  #### 내 자격 증명은 얼마나 오래 유효한가요?
</div>

기본적으로 PKCE를 사용하는 Authorization Code Flow로 발급한 액세스 토큰은 `offline.access` scope를 지정하지 않은 경우 2시간만 유효합니다.

<div id="refresh-tokens">
  #### 리프레시 토큰
</div>

리프레시 토큰을 사용하면 애플리케이션이 리프레시 토큰 플로우를 통해 사용자의 추가 동의 없이 새로운 액세스 토큰을 받을 수 있습니다.

scope `offline.access`가 적용되면 OAuth 2.0 리프레시 토큰이 발급됩니다. 이 리프레시 토큰을 사용해 액세스 토큰을 받을 수 있습니다. 이 scope가 전달되지 않으면 리프레시 토큰은 생성되지 않습니다.

리프레시 토큰을 사용해 새로운 액세스 토큰을 얻기 위해 수행해야 하는 요청 예시는 다음과 같습니다.

```bash
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE' \
--data-urlencode 'grant_type=refresh_token' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ
```

<div id="app-settings">
  #### 앱 설정
</div>

앱의 인증 설정을 OAuth 1.0a 또는 OAuth 2.0으로 선택할 수 있습니다. 또한 하나의 앱이 OAuth 1.0a와 OAuth 2.0 둘 다를 사용하도록 설정할 수도 있습니다.

OAuth 2.0은 X API v2와만 함께 사용할 수 있습니다. OAuth 2.0을 선택한 경우 앱의 키와 토큰 섹션에서 Client ID를 확인할 수 있습니다. 

<div id="confidential-clients">
  #### 기밀 클라이언트
</div>

[기밀 클라이언트](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)는 자격 증명을 무단 당사자에게 노출하지 않고 안전하게 보관할 수 있으며, 인증 서버와 안전하게 인증해 클라이언트 시크릿을 보호합니다. 퍼블릭 클라이언트는 일반적으로 브라우저나 모바일 기기에서 실행되므로 클라이언트 시크릿을 사용할 수 없습니다. 기밀 클라이언트 유형의 앱을 선택하면 클라이언트 시크릿이 제공됩니다. 

developer portal에서 클라이언트 유형으로 기밀 클라이언트를 선택한 경우 Client Secret도 확인할 수 있습니다. 선택 가능한 옵션은 Native App, Single page App, Web App, Automated App 또는 bot입니다. Native App과 Single page App은 퍼블릭 클라이언트이고, Web App과 Automated App 또는 bot은 기밀 클라이언트입니다.

유효한 Authorization Header를 사용하는 기밀 클라이언트의 경우에는 client id가 필요하지 않습니다. 퍼블릭 클라이언트를 사용하는 요청에서는 여전히 요청 본문에 client id를 포함해야 합니다. 

<div id="scopes">
  #### Scopes
</div>

Scopes를 사용하면 앱에 대해 세분화된 액세스를 설정하여 앱에 필요한 권한만 부여할 수 있습니다. 어떤 scope가 어떤 엔드포인트에 매핑되는지 알아보려면 [인증 매핑 가이드](/ko/resources/fundamentals/authentication/guides/v2-authentication-mapping)를 확인하세요.

|     |     |
| :--- | :--- |
| **Scope** | **Description** |
| tweet.read | 보호된 계정을 포함해 사용자가 볼 수 있는 모든 트윗. |
| tweet.write | 사용자를 대신해 트윗을 작성하고 리트윗. |
| tweet.moderate.write | 사용자의 트윗에 대한 답글을 숨기거나 다시 표시. |
| users.email | 인증된 사용자의 이메일 주소. |
| users.read | 보호된 계정을 포함해 사용자가 볼 수 있는 모든 계정. |
| follows.read | 사용자를 팔로우하는 사람과 사용자가 팔로우하는 사람들. |
| follows.write | 사용자를 대신해 다른 사람을 팔로우하거나 언팔로우. |
| offline.access | 사용자가 액세스를 취소할 때까지 계정에 계속 연결 상태 유지. |
| space.read | 사용자가 볼 수 있는 모든 Space. |
| mute.read | 사용자가 뮤트한 계정. |
| mute.write | 사용자를 대신해 계정을 뮤트하거나 뮤트 해제. |
| like.read | 사용자가 좋아요를 누른 트윗과, 사용자가 볼 수 있는 모든 좋아요. |
| like.write | 사용자를 대신해 트윗에 좋아요 및 좋아요 취소. |
| list.read | 사용자가 생성했거나 멤버로 있는 리스트와 해당 리스트의 멤버 및 팔로워(비공개 리스트 포함). |
| list.write | 사용자를 대신해 리스트를 생성하고 관리. |
| block.read | 사용자가 차단한 계정. |
| block.write | 사용자를 대신해 계정을 차단하거나 차단 해제. |
| bookmark.read | 인증된 사용자의 북마크된 트윗을 조회. |
| bookmark.write | 트윗을 북마크하거나 북마크를 제거. |
| media.write | 미디어 업로드. |

<div id="rate-limits">
  #### 요청 한도
</div>

요청 한도는 대부분 OAuth 1.0a로 인증할 때와 동일하지만, 트윗 조회 및 사용자 조회는 예외입니다. OAuth 2.0을 사용해 트윗 조회 및 사용자 조회 요청을 보내는 경우, 15분당 앱당 요청 한도를 300건에서 900건으로 상향했습니다. 자세한 내용은 [요청 한도 관련 문서](/ko/resources/fundamentals/rate-limits)를 참고하세요.

<div id="grant-types">
  #### 권한 유형
</div>

이 초기 출시에서는 [PKCE](https://oauth.net/2/pkce/)가 적용된 [authorization code](https://oauth.net/2/grant-types/authorization-code/)와 [refresh token](https://oauth.net/2/grant-types/refresh-token/)만 지원되는 [grant types](https://oauth.net/2/grant-types/)로 제공합니다. 향후 더 많은 grant type을 지원할 수 있습니다.

<div id="oauth-20-flow">
  #### OAuth 2.0 Flow
</div>

OAuth 2.0은 현재 OAuth 1.0a에 사용 중인 것과 유사한 플로우를 사용합니다. 이 주제에 대한 [문서](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)에서 다이어그램과 자세한 설명을 확인할 수 있습니다. 

<div id="glossary">
  #### 용어집
</div>

|     |     |
| :--- | :--- |
| **Term** | **Description** |
| Grant types | OAuth 프레임워크는 다양한 사용 사례를 위한 여러 grant type과, 새로운 grant type을 정의하기 위한 프레임워크를 규정합니다. 예로 authorization code, client credentials, device code, refresh token 등이 있습니다. |
| Confidential client | confidential client는 등록된 client secret을 안전하게 보관하는 등, 인가 서버에 대해 안전하게 인증할 수 있는 애플리케이션을 의미합니다. |
| Public client | public client는 브라우저나 모바일 기기에서 실행되는 애플리케이션처럼, 등록된 client secret을 사용할 수 없는 클라이언트입니다. |
| Authorization code flow | confidential client와 public client가 authorization code를 액세스 토큰으로 교환할 때 사용하는 플로우입니다. |
| PKCE | 여러 공격을 방지하고 public client에서도 안전하게 OAuth 교환을 수행할 수 있도록 authorization code flow를 확장한 방식입니다. |
| Client ID | developer portal의 키와 토큰 섹션에서 &quot;Client ID&quot; 헤더 아래에서 확인할 수 있습니다. 이 항목이 보이지 않는 경우, 당사 팀에 직접 문의해 주세요. Client ID는 authorize URL을 생성하는 데 필요합니다. |
| Redirect URI | 콜백 URL입니다. [exact match validation](https://datatracker.ietf.org/doc/html/rfc6749#section-10.6)이 필요합니다. |
| Authorization code | 애플리케이션이 사용자 대신 API를 호출할 수 있도록 해 줍니다. auth&#95;code라고도 합니다. auth&#95;code는 App 소유자가 사용자로부터 승인된 auth&#95;code를 받은 시점부터 30초의 유효 기간이 있습니다. 30초 이내에 액세스 토큰으로 교환해야 하며, 그렇지 않으면 auth&#95;code는 만료됩니다. |
| Access token | 액세스 토큰은 애플리케이션이 사용자 대신 API 요청을 보낼 때 사용하는 토큰입니다. |
| Refresh token | refresh token flow를 통해, 애플리케이션이 사용자에게 다시 동의를 요청하지 않고도 새 액세스 토큰을 얻을 수 있도록 해 줍니다. |
| Client Secret | confidential client 타입의 App을 선택한 경우, App의 키와 토큰 섹션에서 “Client ID” 아래에 “Client Secret”이 제공됩니다. |

<div id="parameters">
  #### 매개변수
</div>

OAuth 2.0 authorize URL을 구성하려면 인증 URL에 다음 매개변수가 포함되어 있는지 확인해야 합니다. 

|     |     |
| :--- | :--- |
| **Parameter** | **Description** |
| response&#95;type | 이 값이 코드임을 나타내기 위해 “code”라는 단어를 지정해야 합니다. |
| client&#95;id | developer portal의 &quot;Client ID&quot; 항목에서 확인할 수 있습니다. |
| redirect&#95;uri | 콜백 URL입니다. 이 값은 App 설정에 정의된 Callback URL 중 하나와 일치해야 합니다. OAuth 2.0의 경우 콜백 URL에 대해 [exact match validation](https://datatracker.ietf.org/doc/html/rfc6749#section-10.6)이 필요합니다. |
| state | [CSRF 공격](https://auth0.com/docs/protocols/state-parameters)을 방지하기 위해 제공하는 임의의 문자열입니다. 이 문자열의 길이는 최대 500자까지 가능합니다. |
| code&#95;challenge | 각 요청마다 사용하는 임의의 비밀값인 [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/) 매개변수입니다. |
| code&#95;challenge&#95;method | 요청을 보낼 때 사용하는 방법을 지정합니다(S256 또는 plain). |

<div id="authorize-url">
  #### Authorize URL
</div>

OAuth 2.0에서는 X의 “로그인”과 유사한 인증 플로우를 통해 사용자가 인증하도록 하기 위한 authorize URL을 생성합니다. 

다음은 생성할 URL의 예시입니다:

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20account.follows.read%20account.follows.write&state=state&code_challenge=challenge&code_challenge_method=plain
```

이 URL이 올바르게 작동하려면 올바른 인코딩이 필요합니다. [percent encoding](/ko/resources/fundamentals/authentication/oauth-1-0a/percent-encoding-parameters)에 대한 문서를 반드시 확인하세요.
