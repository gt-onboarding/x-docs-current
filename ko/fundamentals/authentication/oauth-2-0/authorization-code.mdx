---
title: PKCE를 사용하는 OAuth 2.0 Authorization Code 플로우
sidebarTitle: PKCE를 사용하는 OAuth 2.0 Authorization Code 플로우
keywords: ["OAuth 2.0 PKCE", "Authorization Code 플로우", "PKCE", "OAuth 2.0 플로우", "PKCE 플로우", "OAuth 2.0 인가", "코드 챌린지"]
---

<div id="oauth-20-authorization-code-flow-with-pkce">
  ### PKCE를 사용하는 OAuth 2.0 Authorization Code 플로우
</div>

<div id="introduction">
  #### 소개
</div>

OAuth 2.0은 애플리케이션의 권한 범위(scope)와 여러 기기에 걸친 인가 플로를 보다 세밀하게 제어할 수 있게 해주는 업계 표준 인가(authorization) 프로토콜입니다. OAuth 2.0을 사용하면 사용자를 대신해 수행할 수 있는 작업에 대해, 세분화된 개별 scope를 선택하여 해당 작업에 필요한 권한만 부여할 수 있습니다. 

앱에서 OAuth 2.0을 사용하려면, developer portal의 App settings 섹션에 있는 Authentication settings에서 OAuth 2.0을 활성화해야 합니다.

<div id="how-long-will-my-credentials-stay-valid">
  #### 내 자격 증명은 얼마나 동안 유효한가요?
</div>

기본적으로 PKCE를 사용하는 Authorization Code Flow를 통해 발급된 액세스 토큰은 `offline.access` scope를 사용하지 않았다면 두 시간 동안만 유효합니다.

<div id="refresh-tokens">
  #### 리프레시 토큰
</div>

리프레시 토큰을 사용하면 앱이 리프레시 토큰 플로우를 통해 사용자에게 다시 동의를 요청하지 않고도 새로운 액세스 토큰을 받을 수 있습니다.

`offline.access` scope가 적용되면 OAuth 2.0 리프레시 토큰이 발급됩니다. 이 리프레시 토큰으로 새로운 액세스 토큰을 받을 수 있습니다. 이 scope가 포함되지 않으면 리프레시 토큰은 발급되지 않습니다.

리프레시 토큰을 사용해 새로운 액세스 토큰을 얻기 위해 보내는 요청 예시는 다음과 같습니다.

```bash
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE' \
--data-urlencode 'grant_type=refresh_token' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ
```

<div id="app-settings">
  #### 앱 설정
</div>

앱의 인증 설정을 OAuth 1.0a 또는 OAuth 2.0으로 지정할 수 있습니다. 또한 하나의 앱이 OAuth 1.0a와 OAuth 2.0을 모두 사용하도록 설정할 수도 있습니다.

OAuth 2.0은 X API v2와만 함께 사용할 수 있습니다. OAuth 2.0을 선택한 경우, 앱의 Keys and Tokens(키와 토큰) 섹션에서 Client ID를 확인할 수 있습니다. 

<div id="confidential-clients">
  #### 기밀 클라이언트
</div>

[기밀 클라이언트](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)는 자격 증명을 안전하게 보관해 무단 당사자에게 노출하지 않으면서 권한 부여 서버에 대해 안전하게 인증할 수 있는 클라이언트로, client secret을 안전하게 보호할 수 있습니다. 퍼블릭 클라이언트는 일반적으로 브라우저나 모바일 기기에서 실행되므로 client secret을 안전하게 사용할 수 없습니다. 기밀 클라이언트 유형의 App을 선택하면 client secret이 제공됩니다. 

개발자 포털에서 기밀 클라이언트 유형의 클라이언트를 선택한 경우, client secret도 확인할 수 있습니다. 선택 가능한 옵션은 Native App, Single page App, Web App, Automated App, 또는 bot입니다. Native App과 Single page App은 퍼블릭 클라이언트이고, Web App과 Automated App 또는 bot은 기밀 클라이언트입니다.

유효한 Authorization 헤더를 사용하는 기밀 클라이언트의 경우 client id가 필요하지 않습니다. 퍼블릭 클라이언트로 요청하는 경우에는 여전히 요청 본문에 client id를 포함해야 합니다. 

<div id="scopes">
  #### 스코프
</div>

스코프를 사용하면 앱에 필요한 권한만 갖도록 세밀하게 접근 권한을 설정할 수 있습니다. 어떤 스코프가 어떤 엔드포인트에 매핑되는지 자세히 알아보려면 [인증 매핑 가이드](/ko/resources/fundamentals/authentication/guides/v2-authentication-mapping)를 참조하세요.

|     |     |
| :--- | :--- |
| **Scope** | **설명** |
| tweet.read | 보호된 계정을 포함해, 앱이 볼 수 있는 모든 트윗. |
| tweet.write | 앱이 사용자를 대신해 트윗 및 리트윗. |
| tweet.moderate.write | 앱이 사용자의 트윗에 대한 답글을 숨기거나 다시 표시. |
| users.email | 인증된 사용자의 이메일. |
| users.read | 보호된 계정을 포함해, 앱이 볼 수 있는 모든 계정. |
| follows.read | 사용자를 팔로우하는 계정과 사용자가 팔로우하는 계정. |
| follows.write | 앱이 사용자를 대신해 계정을 팔로우하거나 팔로우 해제. |
| offline.access | 사용자가 접근을 취소할 때까지 계정에 계속 연결 유지. |
| space.read | 앱이 볼 수 있는 모든 Space. |
| mute.read | 사용자가 뮤트한 계정. |
| mute.write | 앱이 사용자를 대신해 계정을 뮤트하거나 뮤트 해제. |
| like.read | 사용자가 좋아요한 트윗과, 앱이 볼 수 있는 좋아요. |
| like.write | 앱이 사용자를 대신해 트윗에 좋아요하거나 좋아요 취소. |
| list.read | 사용자가 만들었거나 멤버로 속해 있는 리스트(비공개 리스트 포함), 해당 리스트의 멤버 및 팔로워. |
| list.write | 앱이 사용자를 대신해 리스트를 생성 및 관리. |
| block.read | 사용자가 차단한 계정. |
| block.write | 앱이 사용자를 대신해 계정을 차단하거나 차단 해제. |
| bookmark.read | 인증된 사용자의 북마크된 트윗 가져오기. |
| bookmark.write | 트윗에 북마크를 추가하거나 제거. |
| media.write | 미디어 업로드. |

<div id="rate-limits">
  #### 요청 한도
</div>

대부분의 경우 요청 한도는 OAuth 1.0a로 인증할 때와 동일하지만, 트윗 조회와 사용자 조회는 예외입니다. OAuth 2.0을 사용해 트윗 조회와 사용자 조회를 수행하는 경우, 앱당 요청 한도를 15분당 300회에서 900회로 증가시켰습니다. 자세한 내용은 [요청 한도 관련 문서](/ko/resources/fundamentals/rate-limits)를 확인하세요.

<div id="grant-types">
  #### Grant 유형
</div>

이번 초기 출시에서는 지원되는 [grant type](https://oauth.net/2/grant-types/)으로 [authorization code](https://oauth.net/2/grant-types/authorization-code/)와 [PKCE](https://oauth.net/2/pkce/), 그리고 [refresh token](https://oauth.net/2/grant-types/refresh-token/)만 지원합니다. 향후 더 많은 grant type을 지원할 수 있습니다.

<div id="oauth-20-flow">
  #### OAuth 2.0 플로우
</div>

OAuth 2.0는 현재 OAuth 1.0a에서 사용 중인 것과 유사한 플로우를 따릅니다. 이 주제에 대한 다이어그램과 자세한 설명은 [관련 문서](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)에서 확인할 수 있습니다. 

<div id="glossary">
  #### 용어 설명
</div>

|     |     |
| :--- | :--- |
| **용어** | **설명** |
| Grant types | OAuth 프레임워크는 다양한 사용 사례를 위한 여러 grant 유형과, 새로운 grant 유형을 만들기 위한 프레임워크를 정의합니다. 예를 들어 authorization code, client credentials, device code, refresh token 등이 있습니다. |
| Confidential client | confidential client는 등록된 client secret을 안전하게 보관하는 등, 인가 서버와 안전하게 인증할 수 있는 애플리케이션을 의미합니다. |
| Public client | public client는 브라우저나 모바일 디바이스에서 실행되는 애플리케이션처럼, 등록된 client secret을 사용할 수 없는 클라이언트를 의미합니다. |
| Authorization code flow | confidential client와 public client 모두가 authorization code를 액세스 토큰으로 교환할 때 사용하는 플로우입니다. |
| PKCE | 여러 가지 공격을 방지하고 public client에서도 안전하게 OAuth 교환을 수행할 수 있도록 authorization code flow를 확장한 방식입니다. |
| Client ID | developer portal의 키와 토큰 섹션에 있는 &quot;Client ID&quot; 항목에서 확인할 수 있습니다. 이 항목이 보이지 않는 경우, 저희 팀에 직접 문의해 주세요. authorize URL을 생성하려면 Client ID가 필요합니다. |
| Redirect URI | 콜백 URL입니다. [exact match validation](https://datatracker.ietf.org/doc/html/rfc6749#section-10.6)을 충족해야 합니다. |
| Authorization code | 애플리케이션이 사용자를 대신해 API를 호출할 수 있도록 해 줍니다. `auth_code`라고도 합니다. App 소유자가 사용자로부터 승인된 `auth_code`를 받으면, 해당 `auth_code`의 유효 기간은 30초입니다. 30초 안에 액세스 토큰으로 교환해야 하며, 그렇지 않으면 `auth_code`는 만료됩니다. |
| Access token | 액세스 토큰은 애플리케이션이 사용자를 대신해 API 요청을 보낼 때 사용하는 토큰입니다. |
| Refresh token | refresh token flow를 통해 사용자를 다시 요청(prompt)하지 않고도, 애플리케이션이 새로운 액세스 토큰을 얻을 수 있도록 해 줍니다. |
| Client Secret | confidential client 유형의 App을 선택한 경우, App의 키와 토큰 섹션에서 “Client ID” 아래에 “Client Secret”이 제공됩니다. |

<div id="parameters">
  #### 매개변수
</div>

OAuth 2.0 승인 URL을 구성하려면, 인증 URL에 다음 매개변수들이 포함되어 있는지 확인해야 합니다. 

|     |     |
| :--- | :--- |
| **매개변수** | **설명** |
| response&#95;type | 이 값이 코드임을 나타내기 위해 `"code"`로 설정해야 합니다. |
| client&#95;id | Developer Portal에서 &quot;Client ID&quot; 헤더 아래에서 확인할 수 있습니다. |
| redirect&#95;uri | 사용자의 콜백 URL입니다. 이 값은 앱 설정에 정의된 콜백 URL 중 하나와 정확히 일치해야 합니다. OAuth 2.0의 경우 콜백 URL에 대해 [exact match validation](https://datatracker.ietf.org/doc/html/rfc6749#section-10.6)이 필요합니다. |
| state | [CSRF 공격](https://auth0.com/docs/protocols/state-parameters)을 방지하기 위한 검증에 사용하는, 사용자가 임의로 지정하는 문자열입니다. 이 문자열의 길이는 최대 500자까지 가능합니다. |
| code&#95;challenge | 각 요청마다 사용하는 임의의 비밀 값인 [PKCE](https://www.oauth.com/oauth2-servers/pkce/authorization-request/) 매개변수입니다. |
| code&#95;challenge&#95;method | 요청을 보낼 때 사용하는 방법(S256 또는 plain)을 지정합니다. |

<div id="authorize-url">
  #### Authorize URL
</div>

OAuth 2.0을 사용할 때는 사용자가 X의 “로그인”과 유사한 인증 플로우를 통해 인증할 수 있도록 authorize URL을 생성합니다. 

생성하게 될 URL의 예시는 다음과 같습니다:

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20account.follows.read%20account.follows.write&state=state&code_challenge=challenge&code_challenge_method=plain
```

이 URL이 정상적으로 동작하려면 적절한 인코딩이 필요합니다. [퍼센트 인코딩](/ko/resources/fundamentals/authentication/oauth-1-0a/percent-encoding-parameters)에 대한 문서를 참고해 주세요.
