---
title: 요청 인가하기
sidebarTitle: 요청 인가하기
keywords: ["요청 인가", "OAuth 인가", "요청 인가", "OAuth 1.0a 인가", "API 요청 인가"]
---

import { Button } from "/snippets/ko/button.mdx";

<div id="authorizing-a-request">
  ### 요청 승인하기
</div>

이 문서는 HTTP 요청을 수정하여 X API로 승인된 요청을 보내는 방법을 설명합니다.

X의 모든 API는 HTTP 프로토콜을 기반으로 합니다. 이는 여러분이 X API를 사용해 작성하는 모든 소프트웨어가 X의 서버로 일련의 구조화된 메시지를 전송한다는 뜻입니다. 예를 들어, 텍스트 “**Hello Ladies + Gentlemen, a signed OAuth request!**”를 트윗으로 게시하기 위한 요청은 다음과 비슷한 형태가 됩니다:

```
POST /1.1/statuses/update.json?include_entities=true HTTP/1.1
Accept: */*
Connection: close
User-Agent: OAuth gem v0.4.4
Content-Type: application/x-www-form-urlencoded
Content-Length: 76
Host: api.x.com

status=Hello%20Ladies%20%2b%20Gentlemen%2c%20a%20signed%20OAuth%20request%21
```

어떤 HTTP 라이브러리든 위와 같은 요청을 비교적 쉽게 생성하고 전송할 수 있습니다. 그러나 다음과 같은 사항을 알 수 없기 때문에, 위 요청은 유효하지 않은 것으로 간주됩니다:

1. 어떤 애플리케이션이 요청을 보내고 있는지
2. 어떤 사용자를 대신해 게시하려는 요청인지
3. 사용자가 애플리케이션에 사용자를 대신해 게시할 수 있는 권한을 부여했는지
4. 전송 중 제3자에 의해 요청이 변조되었는지

애플리케이션이 이 정보를 제공할 수 있도록, X의 API는 [OAuth 1.0a 프로토콜](http://tools.ietf.org/html/rfc5849)을 사용합니다. 아주 단순화해서 설명하면, X의 구현에서는 인가가 필요한 요청에 위의 질문들에 답할 수 있을 만큼 충분한 정보를 담고 있는 추가 HTTP Authorization 헤더가 포함되도록 요구합니다. 위에 제시된 HTTP 요청에 이 헤더를 포함하도록 수정한 버전은 다음과 같습니다(일반적으로 Authorization 헤더는 한 줄에 있어야 하지만, 여기에서는 가독성을 위해 줄바꿈을 했습니다):

```
POST /1.1/statuses/update.json?include_entities=true HTTP/1.1
Accept: */*
Connection: close
User-Agent: OAuth gem v0.4.4
Content-Type: application/x-www-form-urlencoded
Authorization:
OAuth oauth\_consumer\_key="xvz1evFS4wEEPTGEFPHBog",
oauth_nonce="kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg",
oauth_signature="tnnArxj06cWHq44gCs1OSKk%2FjLY%3D",
oauth\_signature\_method="HMAC-SHA1",
oauth_timestamp="1318622958",
oauth_token="370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb",
oauth_version="1.0"
Content-Length: 76
Host: api.x.com

status=Hello%20Ladies%20%2b%20Gentlemen%2c%20a%20signed%20OAuth%20request%21
```

이 요청이 생성되었을 당시에는 X API에서 유효한 것으로 허용되었을 것입니다.

이 서명 과정이 통합에서 감당하기 어려워 보인다면, X API와 상호작용하기 위해 OAuth를 사용할 필요가 없는 [Web Intents](https://dev.x.com/web/intents) 사용을 고려해 보세요.
 

**매개변수 수집하기**

헤더에 7개의 key/value 쌍이 있고, 이 키들이 모두 문자열 “oauth&#95;”로 시작한다는 것을 확인할 수 있습니다. 특정 X API 요청에 대해 이 7개 값을 수집하고 이와 유사한 헤더를 생성하면, 해당 요청에 대한 인가를 지정할 수 있습니다. 각 값이 어떻게 생성되었는지는 아래에 설명되어 있습니다:

**Consumer key**

oauth&#95;consumer&#95;key는 어떤 애플리케이션이 요청을 보내고 있는지를 식별합니다. 이 값은 [developer portal](/ko/resources/fundamentals/developer-portal) 내 [X app](/ko/resources/fundamentals/developer-apps)의 설정 페이지에서 가져올 수 있습니다.

|                            |                        |
| :------------------------- | :--------------------- |
| oauth&#95;consumer&#95;key | xvz1evFS4wEEPTGEFPHBog |

**Nonce**

oauth&#95;nonce 매개변수는 애플리케이션이 각 고유 요청마다 생성해야 하는 고유 토큰입니다. X는 이 값을 사용해 요청이 여러 번 제출되었는지 여부를 판단합니다. 이 예시 요청의 값은 32바이트의 랜덤 데이터를 base64 인코딩한 뒤, 단어 문자가 아닌 모든 문자를 제거하여 생성되었습니다. 그러나 상대적으로 랜덤한 영숫자 문자열을 생성하는 방법이라면 어떤 접근 방식이든 여기에서 사용해도 괜찮습니다.

|                 |                                            |
| :-------------- | :----------------------------------------- |
| oauth&#95;nonce | kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg |

**서명**

`oauth_signature` 파라미터에는 다른 모든 요청 파라미터들과 두 개의 비밀 값을 서명 알고리즘에 적용해 생성한 값이 포함됩니다. 서명의 목적은 X가 전송 중에 요청이 수정되지 않았는지 검증하고, 요청을 보내는 애플리케이션을 검증하며, 해당 애플리케이션이 사용자의 계정과 상호작용할 권한을 가지고 있는지 검증하기 위한 것입니다.

이 요청에 대한 `oauth_signature`를 계산하는 과정은 [서명 생성하기](/ko/resources/fundamentals/authentication/oauth-1-0a/creating-a-signature)에 설명되어 있습니다.

|     |     |
| :--- | :--- |
| oauth&#95;signature | tnnArxj06cWHq44gCs1OSKk/jLY= |

**Signature method**

X에서 사용하는 `oauth_signature_method`는 `HMAC-SHA1`입니다. 이 값은 X API로 보내는 모든 인가된 요청에 사용해야 합니다.

|     |     |
| :--- | :--- |
| oauth&#95;signature&#95;method | HMAC-SHA1 |

**Timestamp**

`oauth_timestamp` 파라미터는 요청이 생성된 시점을 나타냅니다. 이 값은 요청이 생성되는 시점의 유닉스 에포크(Unix epoch) 이후 경과한 초(second) 수여야 하며, 대부분의 프로그래밍 언어에서 쉽게 생성할 수 있습니다. X는 너무 오래 전에 생성된 요청은 거부하므로, 요청을 생성하는 컴퓨터의 시계를 NTP와 동기화하는 것이 중요합니다.

|     |     |
| :--- | :--- |
| oauth&#95;timestamp | 1318622958 |

**Token**

`oauth_token` 파라미터는 일반적으로 사용자가 자신의 계정에 대한 액세스 권한 공유를 애플리케이션에 허용했다는 것을 나타냅니다. 이 값이 전달되지 않거나 다른 형태의 토큰이 사용되는 몇 가지 인증 요청이 있지만, 이러한 경우는 [액세스 토큰 획득하기](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)에서 자세히 다룹니다. 대부분의 범용 요청에서는 **access token**(액세스 토큰)이라고 부르는 값을 사용하게 됩니다.

[developer portal](/ko/resources/fundamentals/developer-portal)에 있는 [X app](/ko/resources/fundamentals/developer-apps)의 설정 페이지에서 자신의 계정에 대해 유효한 [access token](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)을 생성할 수 있습니다.

|     |     |
| :--- | :--- |
| oauth&#95;token | 370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb |

**Version**

`oauth_version` 파라미터는 X API로 보내는 모든 요청에서 항상 `1.0`이어야 합니다.

|     |     |
| :--- | :--- |
| oauth&#95;version | 1.0 |

<div id="building-the-header-string">
  #### 헤더 문자열 구성하기
</div>

헤더 문자열을 구성하려면 DST라는 이름의 문자열에 작성한다고 가정해 봅니다.

1. 문자열 `OAuth ` (끝의 공백 포함)을 DST에 추가합니다.
2. 위에 나열된 7개 파라미터 각각의 키/값 쌍에 대해:
   1. 키를 [퍼센트 인코딩](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)하고 DST에 추가합니다.
   2. 등호 문자 `=`를 DST에 추가합니다.
   3. 큰따옴표 문자 `"`를 DST에 추가합니다.
   4. 값을 [퍼센트 인코딩](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)하고 DST에 추가합니다.
   5. 큰따옴표 문자 `"`를 DST에 추가합니다.
   6. 남아 있는 키/값 쌍이 있다면, 쉼표 `,`와 공백 문자 ` `를 DST에 추가합니다.

이 문자열을 구성할 때 값의 퍼센트 인코딩에 특히 주의해야 합니다. 예를 들어, `oauth_signature` 값인 `tnnArxj06cWHq44gCs1OSKk/jLY=`는 `tnnArxj06cWHq44gCs1OSKk%2FjLY%3D`로 인코딩되어야 합니다.

위에서 수집한 파라미터에 대해 이 단계를 수행하면 다음과 같은 문자열이 생성됩니다:

```
OAuth oauth\_consumer\_key="xvz1evFS4wEEPTGEFPHBog", oauth\_nonce="kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg", oauth\_signature="tnnArxj06cWHq44gCs1OSKk%2FjLY%3D", oauth\_signature\_method="HMAC-SHA1", oauth\_timestamp="1318622958", oauth\_token="370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb", oauth_version="1.0"
```

이 값은 요청의 Authorization 헤더 값으로 설정해야 합니다.
