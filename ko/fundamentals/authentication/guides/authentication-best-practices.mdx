---
title: 모범 사례
keywords: ["인증 모범 사례", "OAuth 모범 사례", "보안 모범 사례", "API 키 보안", "토큰 보안", "인증 보안"]
---

import { Button } from "/snippets/ko/button.mdx";

API 키와 토큰은 매우 신중하게 보호해야 합니다. 

이러한 자격 증명은 [developer App](/ko/resources/fundamentals/developer-apps)과 직접적으로 연결되어 있으며, 사용자가 자신의 대신 요청을 보낼 수 있도록 승인한 X 계정과도 연결되어 있습니다. 키가 유출되면 악의적인 사용자가 해당 키를 사용해 사용자의 개발자 앱 또는 그 앱이 승인한 사용자들을 대신해 X 엔드포인트에 요청을 보낼 수 있습니다. 이로 인해 예기치 않게 요청 한도에 도달하거나, 유료 액세스 할당량을 소진하거나, 심지어 개발자 앱이 사용 중지될 수도 있습니다.

다음 섹션에서는 API 키와 토큰을 관리할 때 고려해야 할 모범 사례를 설명합니다.

<div id="regenerate-api-keys-and-tokens">
  ## API 키와 토큰 재생성
</div>

API 키가 노출된 것으로 판단되는 경우, 다음 단계를 따라 API 키를 재생성해야 합니다.

1. [developer portal의 &quot;Projects and Apps&quot; 페이지](https://developer.x.com/en/portal/projects-and-apps.html)로 이동합니다.
2. 해당 앱 옆에 있는 &quot;Keys and tokens&quot; 아이콘(🗝 )을 클릭합니다.
3. 재생성하려는 키와 토큰 집합 옆의 &quot;Regenerate&quot; 버튼을 클릭합니다. 

Access Token 또는 Bearer Token을 프로그래밍 방식으로 재생성하려는 경우, 인증 엔드포인트를 사용하여 이를 수행할 수 있습니다.

* Access Token을 재생성하려면, 먼저 [POST oauth/invalidate&#95;token](/ko/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) 엔드포인트를 사용하여 토큰을 무효화한 다음, [3-legged OAuth flow](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)를 사용하여 토큰을 다시 발급받아야 합니다.
* Bearer Token을 재생성하려면, 먼저 [POST oauth2/invalidate&#95;token](/ko/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) 엔드포인트를 사용하여 토큰을 무효화한 다음, [POST oauth2/token](/ko/resources/fundamentals/authentication/api-reference#post-oauth2-token) 엔드포인트를 사용하여 토큰을 다시 발급받아야 합니다.

<div id="having-a-central-file-for-your-secrets">
  ## 시크릿을 한 파일에서 관리하기
</div>

시크릿을 저장하는 `.env` 파일이나 `.yaml` 파일과 같은 단일 파일을 사용하는 것은 도움이 될 수 있는 한 가지 방법이지만, 이러한 파일이 실수로 git 저장소에 커밋되지 않도록 막아 줄 충분히 잘 구성된 `.gitignore` 설정을 반드시 갖추어야 합니다. 

<div id="environment-variables">
  ## 환경 변수
</div>

환경 변수를 활용해 코드를 작성하면 유용할 수 있습니다. 

Python으로 작성된 예시는 다음과 같습니다:

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

터미널에서 다음과 같이 입력하세요:

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## 소스 코드와 버전 관리
</div>

개발자가 저지르는 가장 일반적인 보안 실수는 GitHub 및 Bitbucket과 같은 접근 가능한 버전 관리 시스템에 API 키와 토큰이 포함된 코드를 커밋하는 것입니다. 이러한 코드 저장소 중 상당수는 공개적으로 접근 가능합니다. 이 실수는 공개 코드 저장소에서 너무 자주 발생하기 때문에, API 키를 찾아 스크레이핑하는 수익성 높은 봇들까지 존재합니다.

* 서버 환경 변수를 사용하세요. API 키를 환경 변수에 저장하면 코드와 버전 관리 저장소 밖에 둘 수 있습니다. 또한 환경별로 서로 다른 키를 쉽게 사용할 수 있습니다.
* 버전 관리에서 제외된 구성 파일을 사용하세요. 파일 이름을 [.gitignore](https://git-scm.com/docs/gitignore) 파일에 추가하여, 버전 관리에서 해당 파일이 추적되지 않도록 합니다.
* 버전 관리를 사용한 후 코드에서 API 키를 제거하더라도, 코드베이스의 이전 버전에 접근하면 여전히 API 키에 접근할 수 있을 가능성이 큽니다. 다음 섹션에 설명된 대로 API 키를 재발급받으세요.

<div id="databases">
  ## 데이터베이스
</div>

데이터베이스에 액세스 토큰을 저장해야 하는 경우 다음 사항을 유의하십시오.

* 액세스 토큰이 해당 토큰의 소유자만 읽을 수 있도록 데이터베이스에 대한 액세스를 제한하십시오.
* 액세스 토큰용 데이터베이스 테이블에 대한 수정/쓰기 권한을 제한하십시오. 이는 키 관리 시스템으로 자동화되어야 합니다.
* 어떤 데이터 저장소에 저장하더라도, 저장하기 전에 액세스 토큰을 암호화하십시오.

<div id="password-management-tools">
  ## 비밀번호 관리 도구
</div>

1Password나 LastPass와 같은 비밀번호 관리 도구는 키와 토큰을 안전하게 보관하는 데 도움이 될 수 있습니다. 다만 팀에서 함께 사용하는 비밀번호 관리 도구 안에서는 이러한 정보를 공유하지 않는 것이 좋습니다.

<div id="web-storage-cookies">
  ## Web storage &amp; cookies
</div>

웹 스토리지는 LocalStorage와 SessionStorage의 두 가지 유형이 있습니다. 이는 쿠키(Cookies)를 사용하는 방식의 개선을 위해 만들어졌으며, 웹 스토리지는 쿠키보다 훨씬 큰 저장 용량을 제공합니다. 다만 각 저장 방식마다 서로 다른 장단점이 있습니다.
 

**Web Storage: LocalStorage**

로컬 웹 스토리지에 저장된 데이터는 영속적입니다. 즉, 데이터를 명시적으로 삭제하지 않는 한 계속 유지됩니다. 프로젝트의 요구 사항에 따라 이러한 특성을 장점으로 볼 수도 있습니다. 그러나 LocalStorage를 사용할 때는 주의해야 합니다. 데이터에 대한 모든 변경이나 추가 내용이 해당 웹페이지를 이후에 방문할 때마다 계속해서 사용 가능하기 때문입니다. 일반적으로는 LocalStorage 사용을 권장하지 않지만, 예외적인 몇 가지 경우는 있을 수 있습니다. LocalStorage를 사용하기로 했다면 동일 출처 정책(same-origin policy)을 지원한다는 점을 알아 두는 것이 좋습니다. 여기에 저장된 모든 데이터는 동일한 출처에서만 접근할 수 있습니다. LocalStorage 사용 시 성능상의 또 다른 이점은, 모든 HTTP 요청마다 데이터를 서버로 다시 보낼 필요가 없으므로 클라이언트-서버 트래픽이 줄어든다는 점입니다.
 

**Web Storage: SessionStorage**

SessionStorage는 LocalStorage와 유사하지만, 핵심적인 차이점은 SessionStorage의 데이터는 영속적이지 않다는 것입니다. SessionStorage에 쓰기 작업을 수행한 창(또는 사용하는 브라우저에 따라 탭)을 닫는 즉시 데이터는 사라집니다. 이는 사용자 세션 내에서 토큰에 대한 읽기 접근을 제한하는 데 유용합니다. 보안 관점에서 보면, 일반적으로 SessionStorage를 사용하는 것이 LocalStorage를 사용하는 것보다 더 바람직합니다. LocalStorage와 마찬가지로, 동일 출처 정책 지원과 클라이언트-서버 트래픽 감소라는 이점은 SessionStorage에도 동일하게 적용됩니다.
 

**Cookies**

쿠키는 세션 데이터를 저장하는 보다 전통적인 방식입니다. 각 쿠키에 만료 시간을 설정할 수 있으므로, 접근 권한 철회와 제한을 더 쉽게 처리할 수 있습니다. 그러나 쿠키를 사용하면 모든 HTTP 요청마다 데이터가 서버로 다시 전송되므로 클라이언트-서버 트래픽이 확실히 증가합니다. 쿠키를 사용하기로 했다면 세션 하이재킹에 대비해야 합니다. 기본적으로 쿠키는 HTTP 상에서 평문으로 전송되므로, 패킷 스니핑 및/또는 공격자가 트래픽을 변조할 수 있는 중간자(Man-in-the-middle) 공격에 노출되기 쉽습니다. 전송 중인 데이터를 보호하기 위해서는 항상 HTTPS를 강제해야 합니다. 이렇게 하면 기밀성, 무결성(데이터의), 그리고 인증을 보장할 수 있습니다. 다만 웹 애플리케이션이나 사이트가 HTTP와 HTTPS 둘 다를 통해 접근 가능하다면, 쿠키에 &#39;Secure&#39; 플래그를 사용하는 것이 좋습니다. 이렇게 하면 공격자가 사이트의 HTTP 버전에 대한 링크를 사용자에게 보내고, 그로 인해 생성되는 HTTP 요청을 도청하는 것을 방지할 수 있습니다.

쿠키 사용 시 세션 하이재킹에 대한 또 다른 2차 방어 수단은, 고위험 작업을 수행하기 전에 사용자의 신원을 다시 검증하는 것입니다. 쿠키의 보안을 강화하기 위해 고려해야 할 또 다른 플래그는 &#39;HttpOnly&#39; 플래그입니다. 이 플래그는 해당 쿠키가 지정된 서버에서만 접근 가능하도록 브라우저에 지시합니다. 클라이언트 측 스크립트에서 이 쿠키에 접근하려는 모든 시도는 이 플래그에 의해 차단되며, 이를 통해 대부분의 크로스 사이트 스크립팅(XSS) 공격에 대한 방어에 도움이 됩니다.