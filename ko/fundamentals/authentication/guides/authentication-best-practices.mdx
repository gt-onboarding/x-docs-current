---
title: 모범 사례
keywords: ["인증 모범 사례", "OAuth 모범 사례", "보안 모범 사례", "API 키 보안", "토큰 보안", "인증 보안"]
---

import { Button } from "/snippets/ko/button.mdx";

API 키와 토큰은 각별히 주의해서 보호해야 합니다. 

이러한 자격 증명은 여러분의 [developer App](/ko/resources/fundamentals/developer-apps)과, 여러분이 해당 계정을 대신해 요청을 보낼 수 있도록 권한을 부여한 X 계정에 직접 연결되어 있습니다. 키가 유출되면, 악의적인 행위자가 이를 사용해 여러분의 개발자 앱이나 해당 앱에 권한을 부여한 사용자를 대신하여 X 엔드포인트로 요청을 보낼 수 있습니다. 이는 예기치 않게 요청 한도에 걸리거나, 유료 액세스 할당량을 모두 소진하거나, 심지어 여러분의 개발자 앱이 일시 중단되는 결과를 초래할 수도 있습니다.

다음 섹션에서는 API 키와 토큰을 관리할 때 고려해야 할 모범 사례를 설명합니다.

<div id="regenerate-api-keys-and-tokens">
  ## API 키와 토큰 재생성
</div>

API 키가 노출된 것으로 의심되는 경우, 다음 단계를 따라 API 키를 재생성해야 합니다.

1. [developer portal의 &quot;Projects and Apps&quot; 페이지](https://developer.x.com/en/portal/projects-and-apps.html)로 이동합니다.
2. 해당 App 옆에 있는 &quot;Keys and tokens&quot; 아이콘(🗝 )을 클릭합니다.
3. 재생성하려는 키와 토큰 세트 옆의 &quot;Regenerate&quot; 버튼을 클릭합니다. 

Access Token 또는 Bearer Token을 프로그래밍 방식으로 재생성하려면 인증 엔드포인트를 사용하면 됩니다.

* Access Token을 재생성하려는 경우, 먼저 [POST oauth/invalidate&#95;token](/ko/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) 엔드포인트를 사용하여 토큰을 무효화한 다음, [3-legged OAuth 플로우](/ko/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens)를 사용해 토큰을 재생성해야 합니다.
* Bearer Token을 재생성하려는 경우, 먼저 [POST oauth2/invalidate&#95;token](/ko/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) 엔드포인트를 사용하여 토큰을 무효화한 다음, [POST oauth2/token](/ko/resources/fundamentals/authentication/api-reference#post-oauth2-token) 엔드포인트를 사용해 토큰을 재생성해야 합니다.

<div id="having-a-central-file-for-your-secrets">
  ## 시크릿을 위한 단일 파일 사용
</div>

`.ENV` 파일이나 기타 `.yaml` 파일처럼 시크릿을 모아 두는 전용 파일을 사용하는 것은 유용할 수 있지만, 이러한 파일이 실수로 git 리포지토리에 커밋되지 않도록 막아 줄 탄탄한 `.gitignore` 설정을 반드시 준비해야 합니다. 

<div id="environment-variables">
  ## 환경 변수
</div>

환경 변수를 사용하는 방식으로 코드를 작성하면 유용할 수 있습니다. 

다음은 Python으로 작성한 예시입니다:

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

터미널에서 다음과 같이 입력합니다:

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## 소스 코드와 버전 관리
</div>

개발자가 저지르는 가장 흔한 보안 실수 가운데 하나는 GitHub 및 Bitbucket과 같이 접근 가능한 버전 관리 시스템의 소스 코드에 API 키와 토큰을 커밋하는 것입니다. 이러한 코드 리포지토리 중 상당수는 공개되어 있습니다. 공개 코드 리포지토리에서 이런 실수가 매우 자주 발생하기 때문에, API 키를 찾아 수집하는 수익성 높은 봇들까지 존재합니다.

* 서버 환경 변수를 사용하세요. API 키를 환경 변수에 저장하면 코드와 버전 관리 시스템 밖에 둘 수 있습니다. 이를 통해 환경별로 서로 다른 키를 쉽게 사용할 수도 있습니다.
* 버전 관리에서 제외된 설정 파일을 사용하세요. 파일이 버전 관리에서 추적되지 않도록 해당 파일명을 [.gitignore](https://git-scm.com/docs/gitignore) 파일에 추가하세요.
* 버전 관리를 사용한 후 코드에서 API 키를 제거하더라도, 코드베이스의 이전 버전에 접근하면 여전히 해당 API 키에 접근할 수 있는 상태일 가능성이 높습니다. 다음 섹션에 설명된 대로 API 키를 다시 생성하세요.

<div id="databases">
  ## 데이터베이스
</div>

데이터베이스에 액세스 토큰을 저장해야 하는 경우 다음 사항을 유의하십시오:

* 액세스 토큰이 해당 토큰의 소유자만 읽을 수 있도록 데이터베이스에 대한 액세스를 제한하십시오.
* 액세스 토큰용 데이터베이스 테이블에 대한 수정/쓰기 권한을 제한하십시오. 이는 키 관리 시스템으로 자동화되어야 합니다.
* 어떤 데이터 저장소에든 저장하기 전에 액세스 토큰을 암호화하십시오.

<div id="password-management-tools">
  ## 비밀번호 관리 도구
</div>

1password나 Last Pass와 같은 비밀번호 관리 도구는 키와 토큰을 안전한 곳에 보관하는 데 도움이 될 수 있습니다. 다만 팀에서 함께 사용하는 공유 비밀번호 관리 도구에 이러한 정보를 저장하거나 공유하는 일은 피하는 것이 좋습니다.

<div id="web-storage-cookies">
  ## Web storage &amp; cookies
</div>

웹 스토리지는 LocalStorage와 SessionStorage 두 가지 유형이 있습니다. 웹 스토리지는 쿠키 저장소보다 저장 용량이 훨씬 크기 때문에, 쿠키 사용 방식의 개선책으로 만들어졌습니다. 다만 각 스토리지 옵션마다 서로 다른 장단점이 있습니다.
 

**Web Storage: LocalStorage**

로컬 웹 스토리지에 저장된 항목은 지속적(persistent)입니다. 이는 데이터를 명시적으로 삭제하기 전까지 데이터가 유지된다는 뜻입니다. 프로젝트의 필요에 따라서는 이를 장점으로 볼 수도 있습니다. 그러나 LocalStorage를 사용할 때에는 주의해야 합니다. 데이터에 대한 모든 변경/추가 사항이 문제가 된 웹페이지에 대한 이후의 모든 방문에서도 계속해서 사용 가능하기 때문입니다. 일반적으로 LocalStorage 사용은 권장하지 않지만, 몇 가지 예외적인 경우에는 사용할 수 있습니다. LocalStorage를 사용하기로 했다면 동일 출처 정책(same-origin policy)을 지원한다는 점을 알아두는 것이 좋습니다. 여기 저장된 모든 데이터는 동일한 출처를 통해서만 접근할 수 있습니다. LocalStorage를 사용할 때의 추가적인 성능상의 이점은, 데이터가 매 HTTP 요청마다 서버로 다시 전송될 필요가 없으므로 클라이언트-서버 트래픽이 감소한다는 점입니다.
 

**Web Storage: SessionStorage**

SessionStorage는 LocalStorage와 비슷하지만, 핵심적인 차이는 SessionStorage는 지속적이지 않다는 점입니다. SessionStorage에 쓰기를 수행한 창(또는 브라우저에 따라 탭)을 닫는 순간 데이터는 사라집니다. 이는 사용자 세션 내에서 토큰에 대한 읽기 접근을 제한하는 데 유용합니다. 보안 관점에서 보면, 일반적으로 SessionStorage 사용이 LocalStorage보다 더 바람직합니다. LocalStorage와 마찬가지로, 동일 출처 정책 지원과 클라이언트-서버 트래픽 감소라는 이점은 SessionStorage에도 동일하게 적용됩니다.
 

**Cookies**

쿠키는 세션 데이터를 저장하는 보다 전통적인 방식입니다. 각 쿠키마다 만료 시간을 설정할 수 있어, 손쉬운 해지 및 접근 제한이 가능합니다. 그러나 데이터를 매 HTTP 요청마다 서버로 다시 전송하므로, 쿠키를 사용하면 클라이언트-서버 트래픽이 확실히 증가하게 됩니다. 쿠키 사용을 선택했다면 세션 하이재킹에 대비해야 합니다. 기본적으로 쿠키는 HTTP 상에서 평문으로 전송되므로, 그 내용이 패킷 스니핑 및/또는 중간자 공격(man-in-the-middle attack)에 취약해질 수 있고, 이 경우 공격자가 트래픽을 수정할 수도 있습니다. 데이터 전송 중 보호를 위해서는 항상 HTTPS를 강제해야 합니다. 이렇게 하면 기밀성, 무결성(데이터의 무결성) 및 인증을 확보할 수 있습니다. 다만 웹 애플리케이션이나 사이트가 HTTP와 HTTPS 둘 다로 접속 가능한 경우에는 쿠키에 &#39;Secure&#39; 플래그도 설정해야 합니다. 이를 통해 공격자가 사용자에게 사이트의 HTTP 버전에 대한 링크를 보내고, 그로 인해 생성되는 HTTP 요청을 도청하는 것을 방지할 수 있습니다.

쿠키 사용 시 세션 하이재킹에 대한 또 다른 2차 방어 수단으로, 높은 영향력을 가지는 작업을 수행하기 전에 사용자의 신원을 다시 검증하는 방법이 있습니다. 쿠키의 보안을 강화하기 위해 고려해야 할 또 다른 플래그는 &#39;HttpOnly&#39; 플래그입니다. 이 플래그는 문제의 쿠키가 지정된 서버에서만 접근 가능하도록 브라우저에 지시합니다. 클라이언트 측 스크립트에 의한 접근 시도는 이 플래그에 의해 차단되므로, 대부분의 크로스 사이트 스크립팅(XSS) 공격으로부터 보호하는 데 도움이 됩니다.